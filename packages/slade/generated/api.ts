/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Marqeta Core API
 * Simplified management of your payment programs
 *
 * OpenAPI spec version: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost/v3".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ACHListResponse
 */
export interface ACHListResponse {
    /**
     * 
     * @type {number}
     * @memberof ACHListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof ACHListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof ACHListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ACHListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<BaseAchResponseModel>}
     * @memberof ACHListResponse
     */
    data?: Array<BaseAchResponseModel>;
}

/**
 * 
 * @export
 * @interface ACHReturn
 */
export interface ACHReturn {
    /**
     * 
     * @type {number}
     * @memberof ACHReturn
     */
    amount?: number;
    /**
     * 
     * @type {Date}
     * @memberof ACHReturn
     */
    date?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ACHReturn
     */
    dateInitiated?: Date;
    /**
     * 
     * @type {string}
     * @memberof ACHReturn
     */
    orderId?: string;
    /**
     * 
     * @type {string}
     * @memberof ACHReturn
     */
    reasonCode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ACHReturn
     */
    directDeposit?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ACHReturn
     */
    achType?: string;
}

/**
 * 
 * @export
 * @interface ACHReversalRequest
 */
export interface ACHReversalRequest {
    /**
     * 
     * @type {string}
     * @memberof ACHReversalRequest
     */
    reasonCode?: string;
}

/**
 * 
 * @export
 * @interface ATCInformationModel
 */
export interface ATCInformationModel {
    /**
     * 
     * @type {number}
     * @memberof ATCInformationModel
     */
    atcValue?: number;
    /**
     * 
     * @type {number}
     * @memberof ATCInformationModel
     */
    atcDiscrepancyValue?: number;
    /**
     * 
     * @type {string}
     * @memberof ATCInformationModel
     */
    atcDiscrepancyIndicator?: string;
}

/**
 * 
 * @export
 * @interface AcceptedCountriesListResponse
 */
export interface AcceptedCountriesListResponse {
    /**
     * 
     * @type {number}
     * @memberof AcceptedCountriesListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof AcceptedCountriesListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof AcceptedCountriesListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AcceptedCountriesListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<AcceptedCountriesModel>}
     * @memberof AcceptedCountriesListResponse
     */
    data?: Array<AcceptedCountriesModel>;
}

/**
 * 
 * @export
 * @interface AcceptedCountriesModel
 */
export interface AcceptedCountriesModel {
    /**
     * 
     * @type {string}
     * @memberof AcceptedCountriesModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof AcceptedCountriesModel
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof AcceptedCountriesModel
     */
    isWhitelist: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AcceptedCountriesModel
     */
    countryCodes: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof AcceptedCountriesModel
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AcceptedCountriesModel
     */
    lastModifiedTime?: Date;
}

/**
 * 
 * @export
 * @interface AcceptedCountriesUpdateModel
 */
export interface AcceptedCountriesUpdateModel {
    /**
     * 
     * @type {string}
     * @memberof AcceptedCountriesUpdateModel
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AcceptedCountriesUpdateModel
     */
    isWhitelist?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AcceptedCountriesUpdateModel
     */
    countryCodes?: Array<string>;
}

/**
 * 
 * @export
 * @interface AccessTokenResponse
 */
export interface AccessTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    token?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof AccessTokenResponse
     */
    expires: Date;
    /**
     * 
     * @type {Application}
     * @memberof AccessTokenResponse
     */
    application?: Application;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    userToken?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AccessTokenResponse
     */
    masterRoles?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    tokenType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccessTokenResponse
     */
    oneTime?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    accesstokenId?: string;
}

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    emailAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    score?: string;
}

/**
 * 
 * @export
 * @interface AccountFunding
 */
export interface AccountFunding {
    /**
     * 
     * @type {string}
     * @memberof AccountFunding
     */
    transactionType?: AccountFunding.TransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountFunding
     */
    fundingSource?: AccountFunding.FundingSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountFunding
     */
    receiverAccountType?: AccountFunding.ReceiverAccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountFunding
     */
    receiverName?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountFunding
     */
    screeningScore?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountFunding
     */
    transactionPurpose?: string;
}

/**
 * @export
 * @namespace AccountFunding
 */
export namespace AccountFunding {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionTypeEnum {
        ACCOUNTTOACCOUNT = <any> 'ACCOUNT_TO_ACCOUNT',
        PERSONTOPERSON = <any> 'PERSON_TO_PERSON',
        WALLETTRANSFER = <any> 'WALLET_TRANSFER',
        MONEYTRANSFERBYBANK = <any> 'MONEY_TRANSFER_BY_BANK',
        BUSINESSTOBUSINESS = <any> 'BUSINESS_TO_BUSINESS',
        DISBURSEMENT = <any> 'DISBURSEMENT',
        GOVERNMENTDISBURSEMENT = <any> 'GOVERNMENT_DISBURSEMENT',
        GAMBLINGPAYOUT = <any> 'GAMBLING_PAYOUT',
        LOYALTY = <any> 'LOYALTY',
        MERCHANTDISBURSEMENT = <any> 'MERCHANT_DISBURSEMENT',
        ONLINEGAMBLINGPAYOUT = <any> 'ONLINE_GAMBLING_PAYOUT',
        PENSIONDISBURSEMENT = <any> 'PENSION_DISBURSEMENT',
        PREPAIDLOADS = <any> 'PREPAID_LOADS',
        CARDBILLPAYMENT = <any> 'CARD_BILL_PAYMENT',
        BILLPAYMENT = <any> 'BILL_PAYMENT',
        CASHCLAIM = <any> 'CASH_CLAIM',
        CASHIN = <any> 'CASH_IN',
        CASHOUT = <any> 'CASH_OUT',
        MOBILEAIRTIMEPAYMENT = <any> 'MOBILE_AIR_TIME_PAYMENT',
        MONEYTRANSFERBYMERCHANT = <any> 'MONEY_TRANSFER_BY_MERCHANT',
        FACETOFACEMERCHANTPAYMENT = <any> 'FACE_TO_FACE_MERCHANT_PAYMENT',
        GOVERNMENTPAYMENT = <any> 'GOVERNMENT_PAYMENT',
        PAYMENTSGOODSSERVICES = <any> 'PAYMENTS_GOODS_SERVICES',
        FUNDSTRANSFER = <any> 'FUNDS_TRANSFER',
        GENERALBUSINESSTOBUSINESSTRANSFER = <any> 'GENERAL_BUSINESS_TO_BUSINESS_TRANSFER',
        BUSINESSTOBUSINESSTRANSFER = <any> 'BUSINESS_TO_BUSINESS_TRANSFER',
        CASHDEPOSIT = <any> 'CASH_DEPOSIT',
        PURCHASEREPAYMENT = <any> 'PURCHASE_REPAYMENT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FundingSourceEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT',
        PREPAID = <any> 'PREPAID',
        DEPOSITACCOUNT = <any> 'DEPOSIT_ACCOUNT',
        CASH = <any> 'CASH',
        MOBILEMONEYACCOUNT = <any> 'MOBILE_MONEY_ACCOUNT',
        NONVISACREDIT = <any> 'NON_VISA_CREDIT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReceiverAccountTypeEnum {
        OTHER = <any> 'OTHER',
        RTNBANKACCOUNT = <any> 'RTN_BANK_ACCOUNT',
        IBAN = <any> 'IBAN',
        CARDACCOUNT = <any> 'CARD_ACCOUNT',
        EMAIL = <any> 'EMAIL',
        PHONENUMBER = <any> 'PHONE_NUMBER',
        BANKACCOUNTNUMBERANDBANKIDENTIFICATIONCODE = <any> 'BANK_ACCOUNT_NUMBER_AND_BANK_IDENTIFICATION_CODE',
        WALLETID = <any> 'WALLET_ID',
        SOCIALNETWORKID = <any> 'SOCIAL_NETWORK_ID'
    }
}

/**
 * 
 * @export
 * @interface AccountFundingReceiverData
 */
export interface AccountFundingReceiverData {
    /**
     * 
     * @type {string}
     * @memberof AccountFundingReceiverData
     */
    fundingSource: AccountFundingReceiverData.FundingSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountFundingReceiverData
     */
    receiverAccountType: AccountFundingReceiverData.ReceiverAccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountFundingReceiverData
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof AccountFundingReceiverData
     */
    lastName?: string;
}

/**
 * @export
 * @namespace AccountFundingReceiverData
 */
export namespace AccountFundingReceiverData {
    /**
     * @export
     * @enum {string}
     */
    export enum FundingSourceEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT',
        PREPAID = <any> 'PREPAID',
        DEPOSITACCOUNT = <any> 'DEPOSIT_ACCOUNT',
        CASH = <any> 'CASH',
        MOBILEMONEYACCOUNT = <any> 'MOBILE_MONEY_ACCOUNT',
        NONVISACREDIT = <any> 'NON_VISA_CREDIT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReceiverAccountTypeEnum {
        OTHER = <any> 'OTHER',
        RTNBANKACCOUNT = <any> 'RTN_BANK_ACCOUNT',
        IBAN = <any> 'IBAN',
        CARDACCOUNT = <any> 'CARD_ACCOUNT',
        EMAIL = <any> 'EMAIL',
        PHONENUMBER = <any> 'PHONE_NUMBER',
        BANKACCOUNTNUMBERANDBANKIDENTIFICATIONCODE = <any> 'BANK_ACCOUNT_NUMBER_AND_BANK_IDENTIFICATION_CODE',
        WALLETID = <any> 'WALLET_ID',
        SOCIALNETWORKID = <any> 'SOCIAL_NETWORK_ID'
    }
}

/**
 * 
 * @export
 * @interface AccountFundingRequest
 */
export interface AccountFundingRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountFundingRequest
     */
    screeningScore?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountFundingRequest
     */
    transactionType: AccountFundingRequest.TransactionTypeEnum;
    /**
     * 
     * @type {AccountFundingReceiverData}
     * @memberof AccountFundingRequest
     */
    receiverData: AccountFundingReceiverData;
    /**
     * 
     * @type {string}
     * @memberof AccountFundingRequest
     */
    transactionPurpose?: string;
}

/**
 * @export
 * @namespace AccountFundingRequest
 */
export namespace AccountFundingRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionTypeEnum {
        ACCOUNTTOACCOUNT = <any> 'ACCOUNT_TO_ACCOUNT',
        PERSONTOPERSON = <any> 'PERSON_TO_PERSON',
        WALLETTRANSFER = <any> 'WALLET_TRANSFER',
        MONEYTRANSFERBYBANK = <any> 'MONEY_TRANSFER_BY_BANK',
        BUSINESSTOBUSINESS = <any> 'BUSINESS_TO_BUSINESS',
        DISBURSEMENT = <any> 'DISBURSEMENT',
        GOVERNMENTDISBURSEMENT = <any> 'GOVERNMENT_DISBURSEMENT',
        GAMBLINGPAYOUT = <any> 'GAMBLING_PAYOUT',
        LOYALTY = <any> 'LOYALTY',
        MERCHANTDISBURSEMENT = <any> 'MERCHANT_DISBURSEMENT',
        ONLINEGAMBLINGPAYOUT = <any> 'ONLINE_GAMBLING_PAYOUT',
        PENSIONDISBURSEMENT = <any> 'PENSION_DISBURSEMENT',
        PREPAIDLOADS = <any> 'PREPAID_LOADS',
        CARDBILLPAYMENT = <any> 'CARD_BILL_PAYMENT',
        BILLPAYMENT = <any> 'BILL_PAYMENT',
        CASHCLAIM = <any> 'CASH_CLAIM',
        CASHIN = <any> 'CASH_IN',
        CASHOUT = <any> 'CASH_OUT',
        MOBILEAIRTIMEPAYMENT = <any> 'MOBILE_AIR_TIME_PAYMENT',
        MONEYTRANSFERBYMERCHANT = <any> 'MONEY_TRANSFER_BY_MERCHANT',
        FACETOFACEMERCHANTPAYMENT = <any> 'FACE_TO_FACE_MERCHANT_PAYMENT',
        GOVERNMENTPAYMENT = <any> 'GOVERNMENT_PAYMENT',
        PAYMENTSGOODSSERVICES = <any> 'PAYMENTS_GOODS_SERVICES',
        FUNDSTRANSFER = <any> 'FUNDS_TRANSFER',
        GENERALBUSINESSTOBUSINESSTRANSFER = <any> 'GENERAL_BUSINESS_TO_BUSINESS_TRANSFER',
        BUSINESSTOBUSINESSTRANSFER = <any> 'BUSINESS_TO_BUSINESS_TRANSFER',
        CASHDEPOSIT = <any> 'CASH_DEPOSIT',
        PURCHASEREPAYMENT = <any> 'PURCHASE_REPAYMENT'
    }
}

/**
 * 
 * @export
 * @interface AccountHolderGroupConfig
 */
export interface AccountHolderGroupConfig {
    /**
     * 
     * @type {string}
     * @memberof AccountHolderGroupConfig
     */
    kycRequired?: AccountHolderGroupConfig.KycRequiredEnum;
    /**
     * 
     * @type {boolean}
     * @memberof AccountHolderGroupConfig
     */
    isReloadable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AccountHolderGroupConfig
     */
    realTimeFeeGroupToken?: string;
    /**
     * 
     * @type {PreKycControls}
     * @memberof AccountHolderGroupConfig
     */
    preKycControls?: PreKycControls;
}

/**
 * @export
 * @namespace AccountHolderGroupConfig
 */
export namespace AccountHolderGroupConfig {
    /**
     * @export
     * @enum {string}
     */
    export enum KycRequiredEnum {
        ALWAYS = <any> 'ALWAYS',
        CONDITIONAL = <any> 'CONDITIONAL',
        NEVER = <any> 'NEVER'
    }
}

/**
 * 
 * @export
 * @interface AccountHolderGroupListResponse
 */
export interface AccountHolderGroupListResponse {
    /**
     * 
     * @type {number}
     * @memberof AccountHolderGroupListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountHolderGroupListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof AccountHolderGroupListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AccountHolderGroupListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<AccountHolderGroupResponse>}
     * @memberof AccountHolderGroupListResponse
     */
    data?: Array<AccountHolderGroupResponse>;
}

/**
 * 
 * @export
 * @interface AccountHolderGroupRequest
 */
export interface AccountHolderGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountHolderGroupRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountHolderGroupRequest
     */
    name?: string;
    /**
     * 
     * @type {AccountHolderGroupConfig}
     * @memberof AccountHolderGroupRequest
     */
    config?: AccountHolderGroupConfig;
}

/**
 * 
 * @export
 * @interface AccountHolderGroupResponse
 */
export interface AccountHolderGroupResponse {
    /**
     * 36 char max
     * @type {string}
     * @memberof AccountHolderGroupResponse
     */
    token?: string;
    /**
     * 40 char max
     * @type {string}
     * @memberof AccountHolderGroupResponse
     */
    name?: string;
    /**
     * 
     * @type {AccountHolderGroupConfig}
     * @memberof AccountHolderGroupResponse
     */
    config?: AccountHolderGroupConfig;
}

/**
 * 
 * @export
 * @interface AccountHolderGroupUpdateRequest
 */
export interface AccountHolderGroupUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountHolderGroupUpdateRequest
     */
    name?: string;
    /**
     * 
     * @type {AccountHolderGroupConfig}
     * @memberof AccountHolderGroupUpdateRequest
     */
    config?: AccountHolderGroupConfig;
}

/**
 * 
 * @export
 * @interface AchModel
 */
export interface AchModel {
    /**
     * 
     * @type {string}
     * @memberof AchModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof AchModel
     */
    accountNumber: string;
    /**
     * 
     * @type {string}
     * @memberof AchModel
     */
    routingNumber: string;
    /**
     * 
     * @type {string}
     * @memberof AchModel
     */
    nameOnAccount: string;
    /**
     * 
     * @type {string}
     * @memberof AchModel
     */
    accountType: AchModel.AccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AchModel
     */
    bankName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AchModel
     */
    verificationOverride?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AchModel
     */
    verificationNotes?: string;
    /**
     * Required if 'business_token' is null
     * @type {string}
     * @memberof AchModel
     */
    userToken?: string;
    /**
     * Required if 'user_token' is null
     * @type {string}
     * @memberof AchModel
     */
    businessToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AchModel
     */
    isDefaultAccount?: boolean;
}

/**
 * @export
 * @namespace AchModel
 */
export namespace AchModel {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountTypeEnum {
        Checking = <any> 'checking',
        Savings = <any> 'savings',
        Corporate = <any> 'corporate',
        Loan = <any> 'loan'
    }
}

/**
 * 
 * @export
 * @interface AchPartnerRequestModel
 */
export interface AchPartnerRequestModel {
    /**
     * 
     * @type {string}
     * @memberof AchPartnerRequestModel
     */
    idempotentHash?: string;
    /**
     * 
     * @type {string}
     * @memberof AchPartnerRequestModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof AchPartnerRequestModel
     */
    partnerAccountLinkReferenceToken: string;
    /**
     * 
     * @type {string}
     * @memberof AchPartnerRequestModel
     */
    partner: AchPartnerRequestModel.PartnerEnum;
    /**
     * Required if 'business_token' is null
     * @type {string}
     * @memberof AchPartnerRequestModel
     */
    userToken?: string;
    /**
     * Required if 'user_token' is null
     * @type {string}
     * @memberof AchPartnerRequestModel
     */
    businessToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AchPartnerRequestModel
     */
    isDefaultAccount?: boolean;
}

/**
 * @export
 * @namespace AchPartnerRequestModel
 */
export namespace AchPartnerRequestModel {
    /**
     * @export
     * @enum {string}
     */
    export enum PartnerEnum {
        PLAID = <any> 'PLAID'
    }
}

/**
 * 
 * @export
 * @interface AchResponseModel
 */
export interface AchResponseModel {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof AchResponseModel
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof AchResponseModel
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof AchResponseModel
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof AchResponseModel
     */
    accountSuffix: string;
    /**
     * 
     * @type {string}
     * @memberof AchResponseModel
     */
    verificationStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof AchResponseModel
     */
    accountType: string;
    /**
     * 
     * @type {string}
     * @memberof AchResponseModel
     */
    nameOnAccount: string;
    /**
     * 
     * @type {string}
     * @memberof AchResponseModel
     */
    bankName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AchResponseModel
     */
    active: boolean;
    /**
     * 
     * @type {Date}
     * @memberof AchResponseModel
     */
    dateSentForVerification?: Date;
    /**
     * 
     * @type {string}
     * @memberof AchResponseModel
     */
    partner?: string;
    /**
     * 
     * @type {string}
     * @memberof AchResponseModel
     */
    partnerAccountLinkReferenceToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AchResponseModel
     */
    isDefaultAccount?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof AchResponseModel
     */
    dateVerified?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof AchResponseModel
     */
    verificationOverride?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AchResponseModel
     */
    verificationNotes?: string;
    /**
     * 
     * @type {string}
     * @memberof AchResponseModel
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof AchResponseModel
     */
    businessToken?: string;
}

/**
 * 
 * @export
 * @interface AchVerificationModel
 */
export interface AchVerificationModel {
    /**
     * 
     * @type {number}
     * @memberof AchVerificationModel
     */
    verifyAmount1?: number;
    /**
     * 
     * @type {number}
     * @memberof AchVerificationModel
     */
    verifyAmount2?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AchVerificationModel
     */
    active?: boolean;
}

/**
 * 
 * @export
 * @interface Acquirer
 */
export interface Acquirer {
    /**
     * 
     * @type {string}
     * @memberof Acquirer
     */
    institutionCountry?: string;
    /**
     * 
     * @type {string}
     * @memberof Acquirer
     */
    networkInternationalId?: string;
    /**
     * 
     * @type {string}
     * @memberof Acquirer
     */
    institutionIdCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Acquirer
     */
    retrievalReferenceNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Acquirer
     */
    systemTraceAuditNumber?: string;
}

/**
 * 
 * @export
 * @interface ActivationActions
 */
export interface ActivationActions {
    /**
     * 
     * @type {boolean}
     * @memberof ActivationActions
     */
    terminateReissuedSourceCard?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ActivationActions
     */
    swapDigitalWalletTokensFromCardToken?: string;
}

/**
 * 
 * @export
 * @interface AddressRequestModel
 */
export interface AddressRequestModel {
    /**
     * 
     * @type {string}
     * @memberof AddressRequestModel
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRequestModel
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRequestModel
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRequestModel
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRequestModel
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRequestModel
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRequestModel
     */
    postalCode?: string;
}

/**
 * 
 * @export
 * @interface AddressResponseModel
 */
export interface AddressResponseModel {
    /**
     * 
     * @type {string}
     * @memberof AddressResponseModel
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponseModel
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponseModel
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponseModel
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponseModel
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponseModel
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponseModel
     */
    country?: string;
}

/**
 * 
 * @export
 * @interface AddressVerification
 */
export interface AddressVerification {
    /**
     * 
     * @type {string}
     * @memberof AddressVerification
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressVerification
     */
    streetAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressVerification
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressVerification
     */
    postalCode?: string;
}

/**
 * 
 * @export
 * @interface AddressVerificationModel
 */
export interface AddressVerificationModel {
    /**
     * 
     * @type {AvsInformation}
     * @memberof AddressVerificationModel
     */
    request?: AvsInformation;
    /**
     * 
     * @type {AvsInformation}
     * @memberof AddressVerificationModel
     */
    onFile?: AvsInformation;
    /**
     * 
     * @type {Response}
     * @memberof AddressVerificationModel
     */
    response?: Response;
}

/**
 * 
 * @export
 * @interface AddressVerificationSource
 */
export interface AddressVerificationSource {
    /**
     * 
     * @type {AvsInformation}
     * @memberof AddressVerificationSource
     */
    onFile?: AvsInformation;
    /**
     * 
     * @type {Response}
     * @memberof AddressVerificationSource
     */
    response?: Response;
}

/**
 * 
 * @export
 * @interface AdvAuthRequestModel
 */
export interface AdvAuthRequestModel {
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    extendedStipReasonCode?: string;
    /**
     * Default is 0100
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    mti?: AdvAuthRequestModel.MtiEnum;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    network: AdvAuthRequestModel.NetworkEnum;
    /**
     * Defaults to VISANET if network is VISA
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    subNetwork?: AdvAuthRequestModel.SubNetworkEnum;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    networkReferenceId?: string;
    /**
     * yyyy-MM-dd, yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof AdvAuthRequestModel
     */
    localTransactionDate?: Date;
    /**
     * yyyy-MM-dd, yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof AdvAuthRequestModel
     */
    transactionDate?: Date;
    /**
     * yyyy-MM-dd, yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof AdvAuthRequestModel
     */
    settlementDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    stan?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    rrn?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    processingCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    functionCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    reasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    rejectionCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    acquirerReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    forwardingInstitutionId?: string;
    /**
     * 
     * @type {number}
     * @memberof AdvAuthRequestModel
     */
    localTransactionAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    localCurrencyCode?: string;
    /**
     * 
     * @type {number}
     * @memberof AdvAuthRequestModel
     */
    settlementAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof AdvAuthRequestModel
     */
    cardholderBillingAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof AdvAuthRequestModel
     */
    cardholderBillingConversionRate?: number;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    cardholderBillingCurrency?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    settlementCurrencyCode?: string;
    /**
     * 
     * @type {number}
     * @memberof AdvAuthRequestModel
     */
    cardholderSettlementConversionRate?: number;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    approvalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    networkResponse?: string;
    /**
     * 
     * @type {number}
     * @memberof AdvAuthRequestModel
     */
    stanPaddingLength?: number;
    /**
     * 
     * @type {Acquirer}
     * @memberof AdvAuthRequestModel
     */
    acquirer?: Acquirer;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    paymentAccountReference?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    cardToken: string;
    /**
     * 
     * @type {number}
     * @memberof AdvAuthRequestModel
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof AdvAuthRequestModel
     */
    cashBackAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    mid?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    pin?: string;
    /**
     * Default is MAG_STRIPE
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    posPanEntryMode?: AdvAuthRequestModel.PosPanEntryModeEnum;
    /**
     * 
     * @type {number}
     * @memberof AdvAuthRequestModel
     */
    acquirerFeeAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    stipReasonCode?: string;
    /**
     * Default is false
     * @type {boolean}
     * @memberof AdvAuthRequestModel
     */
    isRecurring?: boolean;
    /**
     * Default is false
     * @type {boolean}
     * @memberof AdvAuthRequestModel
     */
    isInstallment?: boolean;
    /**
     * 
     * @type {Array<NetworkFeeModel>}
     * @memberof AdvAuthRequestModel
     */
    networkFees?: Array<NetworkFeeModel>;
    /**
     * 
     * @type {AdvancedAuthCardAcceptorModel}
     * @memberof AdvAuthRequestModel
     */
    cardAcceptor?: AdvancedAuthCardAcceptorModel;
    /**
     * 
     * @type {TransactionOptions}
     * @memberof AdvAuthRequestModel
     */
    transactionOptions?: TransactionOptions;
    /**
     * 
     * @type {OriginalDataElements}
     * @memberof AdvAuthRequestModel
     */
    originalDataElements?: OriginalDataElements;
    /**
     * 
     * @type {ReplacementAmount}
     * @memberof AdvAuthRequestModel
     */
    replacementAmount?: ReplacementAmount;
    /**
     * 
     * @type {Webhook}
     * @memberof AdvAuthRequestModel
     */
    webhook?: Webhook;
    /**
     * 
     * @type {Iso8583DigitalWalletToken}
     * @memberof AdvAuthRequestModel
     */
    digitalWalletToken?: Iso8583DigitalWalletToken;
    /**
     * 
     * @type {DigitalWalletTokenDevice}
     * @memberof AdvAuthRequestModel
     */
    digitalWalletTokenDeviceInfo?: DigitalWalletTokenDevice;
    /**
     * 
     * @type {DigitalWalletTokenWalletProvider}
     * @memberof AdvAuthRequestModel
     */
    digitalWalletTokenWalletProviderInfo?: DigitalWalletTokenWalletProvider;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AdvAuthRequestModel
     */
    rawIsoFields?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    cavvResultCode?: AdvAuthRequestModel.CavvResultCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    acceptanceEnvironmentAuthenticationOutageIndicator?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    threedsAuthenticationValue?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    threedsAcquirerExemptionValue?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    securityLevelIndicator?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    securePaymentApplicationV2Value?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    fromAccount?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    issuerReceivedTime?: string;
    /**
     * 
     * @type {NetworkMetadata}
     * @memberof AdvAuthRequestModel
     */
    networkMetadata?: NetworkMetadata;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    isaIndicator?: AdvAuthRequestModel.IsaIndicatorEnum;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    paymentFacilitatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    independentSalesOrganizationId?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    subMerchantId?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    countryOfOrigin?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    foreignRetailerIndicator?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    currencyConversionAssessment?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    transferServiceProviderName?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    paymentFacilitatorName?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    networkAssignedId?: string;
    /**
     * 
     * @type {AccountFundingRequest}
     * @memberof AdvAuthRequestModel
     */
    accountFunding?: AccountFundingRequest;
    /**
     * 
     * @type {number}
     * @memberof AdvAuthRequestModel
     */
    atcValue?: number;
    /**
     * 
     * @type {number}
     * @memberof AdvAuthRequestModel
     */
    atcDiscrepancyValue?: number;
    /**
     * 
     * @type {string}
     * @memberof AdvAuthRequestModel
     */
    atcDiscrepancyIndicator?: string;
    /**
     * 
     * @type {AdvancedAuthPOI}
     * @memberof AdvAuthRequestModel
     */
    poi?: AdvancedAuthPOI;
    /**
     * 
     * @type {AdvancedAuthCardOptions}
     * @memberof AdvAuthRequestModel
     */
    cardOptions: AdvancedAuthCardOptions;
    /**
     * 
     * @type {boolean}
     * @memberof AdvAuthRequestModel
     */
    isStipApproval?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdvAuthRequestModel
     */
    stipAdviceDetailCodeOverride?: boolean;
}

/**
 * @export
 * @namespace AdvAuthRequestModel
 */
export namespace AdvAuthRequestModel {
    /**
     * @export
     * @enum {string}
     */
    export enum MtiEnum {
        _0100 = <any> '0100',
        _0120 = <any> '0120',
        _0190 = <any> '0190',
        _0200 = <any> '0200',
        _0220 = <any> '0220',
        _0400 = <any> '0400',
        _0420 = <any> '0420',
        _0620 = <any> '0620',
        _0110 = <any> '0110',
        _0130 = <any> '0130',
        _0210 = <any> '0210',
        _0410 = <any> '0410',
        _0430 = <any> '0430',
        _0230 = <any> '0230'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NetworkEnum {
        MASTERCARD = <any> 'MASTERCARD',
        DISCOVER = <any> 'DISCOVER',
        PULSE = <any> 'PULSE',
        VISA = <any> 'VISA'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SubNetworkEnum {
        VISANET = <any> 'VISANET',
        VISANETDEBIT = <any> 'VISANETDEBIT',
        VISAINTERLINK = <any> 'VISAINTERLINK',
        VISAPLUS = <any> 'VISAPLUS',
        MAESTRO = <any> 'MAESTRO'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PosPanEntryModeEnum {
        MANUAL = <any> 'MANUAL',
        MAGSTRIPE = <any> 'MAG_STRIPE',
        MAGSTRIPECONTACTLESS = <any> 'MAG_STRIPE_CONTACTLESS',
        CHIP = <any> 'CHIP',
        CHIPCONTACTLESS = <any> 'CHIP_CONTACTLESS',
        BARCODE = <any> 'BAR_CODE',
        OCR = <any> 'OCR',
        MICR = <any> 'MICR',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CavvResultCodeEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _6 = <any> '6',
        _7 = <any> '7',
        _8 = <any> '8',
        _9 = <any> '9',
        A = <any> 'A',
        B = <any> 'B',
        C = <any> 'C',
        D = <any> 'D'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum IsaIndicatorEnum {
        S = <any> 'S',
        C = <any> 'C',
        R = <any> 'R',
        M = <any> 'M',
        P = <any> 'P',
        BLANKSPACE = <any> 'BLANK_SPACE'
    }
}

/**
 * 
 * @export
 * @interface AdvancedAuthCardAcceptorModel
 */
export interface AdvancedAuthCardAcceptorModel {
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardAcceptorModel
     */
    mcc: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardAcceptorModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardAcceptorModel
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardAcceptorModel
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardAcceptorModel
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardAcceptorModel
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardAcceptorModel
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardAcceptorModel
     */
    tid?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardAcceptorModel
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardAcceptorModel
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardAcceptorModel
     */
    customerServicePhone?: string;
}

/**
 * 
 * @export
 * @interface AdvancedAuthCardOptions
 */
export interface AdvancedAuthCardOptions {
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardOptions
     */
    cvv?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthCardOptions
     */
    expiration?: string;
    /**
     * 
     * @type {BillingAddress}
     * @memberof AdvancedAuthCardOptions
     */
    billingAddress?: BillingAddress;
    /**
     * 
     * @type {Track1Data}
     * @memberof AdvancedAuthCardOptions
     */
    track1Data?: Track1Data;
    /**
     * 
     * @type {Track1Data}
     * @memberof AdvancedAuthCardOptions
     */
    track2Data?: Track1Data;
    /**
     * 
     * @type {OriginalCredit}
     * @memberof AdvancedAuthCardOptions
     */
    originalCredit?: OriginalCredit;
}

/**
 * 
 * @export
 * @interface AdvancedAuthOtherPOI
 */
export interface AdvancedAuthOtherPOI {
    /**
     * 
     * @type {boolean}
     * @memberof AdvancedAuthOtherPOI
     */
    cardPresence?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdvancedAuthOtherPOI
     */
    cardholderPresence?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdvancedAuthOtherPOI
     */
    partialApprovalCapable?: boolean;
}

/**
 * 
 * @export
 * @interface AdvancedAuthPOI
 */
export interface AdvancedAuthPOI {
    /**
     * 
     * @type {AdvancedAuthOtherPOI}
     * @memberof AdvancedAuthPOI
     */
    other?: AdvancedAuthOtherPOI;
    /**
     * 
     * @type {boolean}
     * @memberof AdvancedAuthPOI
     */
    ecommerce?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdvancedAuthPOI
     */
    atm?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdvancedAuthPOI
     */
    moto?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AdvancedAuthPOI
     */
    motoIndicator?: AdvancedAuthPOI.MotoIndicatorEnum;
}

/**
 * @export
 * @namespace AdvancedAuthPOI
 */
export namespace AdvancedAuthPOI {
    /**
     * @export
     * @enum {string}
     */
    export enum MotoIndicatorEnum {
        UNKNOWN = <any> 'UNKNOWN',
        MANUAL = <any> 'MANUAL',
        RECURRING = <any> 'RECURRING',
        INSTALLMENT = <any> 'INSTALLMENT',
        OTHERS = <any> 'OTHERS',
        EMPTY = <any> 'EMPTY',
        AUTHSUCCESS = <any> 'AUTH_SUCCESS',
        NONAUTH3DSECURE = <any> 'NON_AUTH_3D_SECURE',
        NONAUTHSECURESUBMISSION = <any> 'NON_AUTH_SECURE_SUBMISSION'
    }
}

/**
 * 
 * @export
 * @interface AdvancedClearingRequestModel
 */
export interface AdvancedClearingRequestModel {
    /**
     * 
     * @type {Array<NetworkFeeModel>}
     * @memberof AdvancedClearingRequestModel
     */
    networkFees?: Array<NetworkFeeModel>;
    /**
     * 
     * @type {Webhook}
     * @memberof AdvancedClearingRequestModel
     */
    webhook?: Webhook;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    mid?: string;
    /**
     * 
     * @type {number}
     * @memberof AdvancedClearingRequestModel
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof AdvancedClearingRequestModel
     */
    sourceAmount: number;
    /**
     * 
     * @type {number}
     * @memberof AdvancedClearingRequestModel
     */
    reconciliationAmount: number;
    /**
     * 
     * @type {number}
     * @memberof AdvancedClearingRequestModel
     */
    replacementAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof AdvancedClearingRequestModel
     */
    cardholderBillingAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof AdvancedClearingRequestModel
     */
    cashback?: number;
    /**
     * 
     * @type {number}
     * @memberof AdvancedClearingRequestModel
     */
    localTransactionAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    localCurrencyCode?: string;
    /**
     * 
     * @type {number}
     * @memberof AdvancedClearingRequestModel
     */
    settlementAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    settlementCurrencyCode?: string;
    /**
     * 
     * @type {number}
     * @memberof AdvancedClearingRequestModel
     */
    settlementConversionRate?: number;
    /**
     * 
     * @type {number}
     * @memberof AdvancedClearingRequestModel
     */
    cardholderBillingConversionRate?: number;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    cardholderBillingCurrency?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    cardToken: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    cardHash: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    acquirerReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    rrn?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    stan?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    processingCode?: string;
    /**
     * 
     * @type {MoneyModel}
     * @memberof AdvancedClearingRequestModel
     */
    acquirerFee?: MoneyModel;
    /**
     * 
     * @type {MoneyModel}
     * @memberof AdvancedClearingRequestModel
     */
    issuerFee?: MoneyModel;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    functionCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    reasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    approvalCode?: string;
    /**
     * yyyy-MM-dd, yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof AdvancedClearingRequestModel
     */
    transactionDate?: Date;
    /**
     * yyyy-MM-dd, yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof AdvancedClearingRequestModel
     */
    localTransactionDate?: Date;
    /**
     * yyyy-MM-dd, yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof AdvancedClearingRequestModel
     */
    settlementDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    networkReferenceId?: string;
    /**
     * 
     * @type {number}
     * @memberof AdvancedClearingRequestModel
     */
    findOriginalWindowDays?: number;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    batchNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    batchFileName?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    sequenceNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    multiClearingCount?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    network?: AdvancedClearingRequestModel.NetworkEnum;
    /**
     * Defaults to VISANET if network is VISA
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    subNetwork?: AdvancedClearingRequestModel.SubNetworkEnum;
    /**
     * 
     * @type {CardAcceptorModel}
     * @memberof AdvancedClearingRequestModel
     */
    cardAcceptor?: CardAcceptorModel;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    currencyCode: string;
    /**
     * 
     * @type {OriginalDataElements}
     * @memberof AdvancedClearingRequestModel
     */
    originalDataElements?: OriginalDataElements;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    precedingRelatedTransactionToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AdvancedClearingRequestModel
     */
    sendExpirationDate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdvancedClearingRequestModel
     */
    simulateBatchForClearingRecordHash?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    isaIndicator?: AdvancedClearingRequestModel.IsaIndicatorEnum;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    tokenPan?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    paymentChannelIndicator?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AdvancedClearingRequestModel
     */
    isInstallment?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AdvancedClearingRequestModel
     */
    isRecurring?: boolean;
    /**
     * 
     * @type {NetworkMetadata}
     * @memberof AdvancedClearingRequestModel
     */
    networkMetadata?: NetworkMetadata;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    authorizationSourceCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    interchangeRateDescriptor?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    acquirerInstitutionIdCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    terminalId?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    specialConditionIndicator?: string;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    mti?: AdvancedClearingRequestModel.MtiEnum;
    /**
     * 
     * @type {string}
     * @memberof AdvancedClearingRequestModel
     */
    clearingFileName?: string;
}

/**
 * @export
 * @namespace AdvancedClearingRequestModel
 */
export namespace AdvancedClearingRequestModel {
    /**
     * @export
     * @enum {string}
     */
    export enum NetworkEnum {
        DISCOVER = <any> 'DISCOVER',
        MASTERCARD = <any> 'MASTERCARD',
        PULSE = <any> 'PULSE',
        VISA = <any> 'VISA'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SubNetworkEnum {
        VISANET = <any> 'VISANET',
        VISANETDEBIT = <any> 'VISANETDEBIT',
        VISAINTERLINK = <any> 'VISAINTERLINK',
        VISAPLUS = <any> 'VISAPLUS'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum IsaIndicatorEnum {
        SINGLECURRENCY = <any> 'SINGLE_CURRENCY',
        MULTICURRENCY = <any> 'MULTI_CURRENCY',
        REBATECANCELLED = <any> 'REBATE_CANCELLED',
        MULTICURRENCYNONUSCOUNTRIES = <any> 'MULTI_CURRENCY_NON_US_COUNTRIES',
        SINGLECURRENCYPAIDBYISSUER = <any> 'SINGLE_CURRENCY_PAID_BY_ISSUER',
        NOCHARGEASSESSED = <any> 'NO_CHARGE_ASSESSED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MtiEnum {
        _0220 = <any> '0220',
        _0420 = <any> '0420'
    }
}

/**
 * 
 * @export
 * @interface AdvancedSimulationResponseModel
 */
export interface AdvancedSimulationResponseModel {
    /**
     * 
     * @type {TransactionModel}
     * @memberof AdvancedSimulationResponseModel
     */
    transaction?: TransactionModel;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AdvancedSimulationResponseModel
     */
    rawIso8583?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface AdviceRequestModel
 */
export interface AdviceRequestModel {
    /**
     * 
     * @type {string}
     * @memberof AdviceRequestModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof AdviceRequestModel
     */
    encryptionKeyId?: string;
    /**
     * 
     * @type {string}
     * @memberof AdviceRequestModel
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof AdviceRequestModel
     */
    network: string;
    /**
     * 
     * @type {boolean}
     * @memberof AdviceRequestModel
     */
    debit?: boolean;
}

/**
 * 
 * @export
 * @interface Airline
 */
export interface Airline {
    /**
     * 
     * @type {string}
     * @memberof Airline
     */
    passengerName?: string;
    /**
     * 
     * @type {Date}
     * @memberof Airline
     */
    departDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof Airline
     */
    originationCity?: string;
}

/**
 * 
 * @export
 * @interface AndroidPushTokenRequestAddress
 */
export interface AndroidPushTokenRequestAddress {
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenRequestAddress
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenRequestAddress
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenRequestAddress
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenRequestAddress
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenRequestAddress
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenRequestAddress
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenRequestAddress
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenRequestAddress
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenRequestAddress
     */
    phone?: string;
}

/**
 * 
 * @export
 * @interface AndroidPushTokenizeRequestData
 */
export interface AndroidPushTokenizeRequestData {
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenizeRequestData
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenizeRequestData
     */
    lastDigits?: string;
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenizeRequestData
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenizeRequestData
     */
    tokenServiceProvider?: string;
    /**
     * 
     * @type {string}
     * @memberof AndroidPushTokenizeRequestData
     */
    opaquePaymentCard?: string;
    /**
     * 
     * @type {AndroidPushTokenRequestAddress}
     * @memberof AndroidPushTokenizeRequestData
     */
    userAddress?: AndroidPushTokenRequestAddress;
}

/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    program?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    environment?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    programShortCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    clientApiBaseUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    assetsUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    accessCode?: string;
}

/**
 * 
 * @export
 * @interface AuthControlExemptMidsListResponse
 */
export interface AuthControlExemptMidsListResponse {
    /**
     * 
     * @type {number}
     * @memberof AuthControlExemptMidsListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthControlExemptMidsListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthControlExemptMidsListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AuthControlExemptMidsListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<AuthControlExemptMidsResponse>}
     * @memberof AuthControlExemptMidsListResponse
     */
    data?: Array<AuthControlExemptMidsResponse>;
}

/**
 * 
 * @export
 * @interface AuthControlExemptMidsRequest
 */
export interface AuthControlExemptMidsRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthControlExemptMidsRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControlExemptMidsRequest
     */
    name: string;
    /**
     * 
     * @type {SpendControlAssociation}
     * @memberof AuthControlExemptMidsRequest
     */
    association?: SpendControlAssociation;
    /**
     * 
     * @type {string}
     * @memberof AuthControlExemptMidsRequest
     */
    mid?: string;
    /**
     * 36 char max
     * @type {string}
     * @memberof AuthControlExemptMidsRequest
     */
    merchantGroupToken?: string;
    /**
     * 
     * @type {Date}
     * @memberof AuthControlExemptMidsRequest
     */
    startTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AuthControlExemptMidsRequest
     */
    endTime?: Date;
}

/**
 * 
 * @export
 * @interface AuthControlExemptMidsResponse
 */
export interface AuthControlExemptMidsResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthControlExemptMidsResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControlExemptMidsResponse
     */
    name: string;
    /**
     * 
     * @type {SpendControlAssociation}
     * @memberof AuthControlExemptMidsResponse
     */
    association?: SpendControlAssociation;
    /**
     * 
     * @type {string}
     * @memberof AuthControlExemptMidsResponse
     */
    mid?: string;
    /**
     * 36 char max
     * @type {string}
     * @memberof AuthControlExemptMidsResponse
     */
    merchantGroupToken?: string;
    /**
     * 
     * @type {Date}
     * @memberof AuthControlExemptMidsResponse
     */
    startTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AuthControlExemptMidsResponse
     */
    endTime?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof AuthControlExemptMidsResponse
     */
    active?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof AuthControlExemptMidsResponse
     */
    created?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AuthControlExemptMidsResponse
     */
    lastUpdated?: Date;
}

/**
 * 
 * @export
 * @interface AuthControlExemptMidsUpdateRequest
 */
export interface AuthControlExemptMidsUpdateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof AuthControlExemptMidsUpdateRequest
     */
    active?: boolean;
}

/**
 * 
 * @export
 * @interface AuthControlListResponse
 */
export interface AuthControlListResponse {
    /**
     * 
     * @type {number}
     * @memberof AuthControlListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthControlListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthControlListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AuthControlListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<AuthControlResponse>}
     * @memberof AuthControlListResponse
     */
    data?: Array<AuthControlResponse>;
}

/**
 * 
 * @export
 * @interface AuthControlMerchantScope
 */
export interface AuthControlMerchantScope {
    /**
     * 36 char max
     * @type {string}
     * @memberof AuthControlMerchantScope
     */
    mid?: string;
    /**
     * 4 char max
     * @type {string}
     * @memberof AuthControlMerchantScope
     */
    mcc?: string;
    /**
     * 36 char max
     * @type {string}
     * @memberof AuthControlMerchantScope
     */
    mccGroup?: string;
    /**
     * 36 char max
     * @type {string}
     * @memberof AuthControlMerchantScope
     */
    merchantGroupToken?: string;
}

/**
 * 
 * @export
 * @interface AuthControlRequest
 */
export interface AuthControlRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthControlRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControlRequest
     */
    name: string;
    /**
     * 
     * @type {SpendControlAssociation}
     * @memberof AuthControlRequest
     */
    association?: SpendControlAssociation;
    /**
     * 
     * @type {AuthControlMerchantScope}
     * @memberof AuthControlRequest
     */
    merchantScope?: AuthControlMerchantScope;
    /**
     * 
     * @type {Date}
     * @memberof AuthControlRequest
     */
    startTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AuthControlRequest
     */
    endTime?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof AuthControlRequest
     */
    active?: boolean;
}

/**
 * 
 * @export
 * @interface AuthControlResponse
 */
export interface AuthControlResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthControlResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControlResponse
     */
    name: string;
    /**
     * 
     * @type {SpendControlAssociation}
     * @memberof AuthControlResponse
     */
    association?: SpendControlAssociation;
    /**
     * 
     * @type {AuthControlMerchantScope}
     * @memberof AuthControlResponse
     */
    merchantScope?: AuthControlMerchantScope;
    /**
     * 
     * @type {Date}
     * @memberof AuthControlResponse
     */
    startTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AuthControlResponse
     */
    endTime?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof AuthControlResponse
     */
    active?: boolean;
}

/**
 * 
 * @export
 * @interface AuthControlUpdateRequest
 */
export interface AuthControlUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthControlUpdateRequest
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof AuthControlUpdateRequest
     */
    name?: string;
    /**
     * 
     * @type {SpendControlAssociation}
     * @memberof AuthControlUpdateRequest
     */
    association?: SpendControlAssociation;
    /**
     * 
     * @type {MerchantScope}
     * @memberof AuthControlUpdateRequest
     */
    merchantScope?: MerchantScope;
    /**
     * 
     * @type {Date}
     * @memberof AuthControlUpdateRequest
     */
    startTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AuthControlUpdateRequest
     */
    endTime?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof AuthControlUpdateRequest
     */
    active?: boolean;
}

/**
 * 
 * @export
 * @interface AuthControls
 */
export interface AuthControls {
    /**
     * 
     * @type {HoldIncrease}
     * @memberof AuthControls
     */
    holdIncrease?: HoldIncrease;
    /**
     * 
     * @type {number}
     * @memberof AuthControls
     */
    holdExpirationDays?: number;
}

/**
 * 
 * @export
 * @interface AuthRequestModel
 */
export interface AuthRequestModel {
    /**
     * 
     * @type {Array<NetworkFeeModel>}
     * @memberof AuthRequestModel
     */
    networkFees?: Array<NetworkFeeModel>;
    /**
     * 
     * @type {Webhook}
     * @memberof AuthRequestModel
     */
    webhook?: Webhook;
    /**
     * 
     * @type {string}
     * @memberof AuthRequestModel
     */
    cardToken: string;
    /**
     * 
     * @type {number}
     * @memberof AuthRequestModel
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof AuthRequestModel
     */
    cashBackAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthRequestModel
     */
    mid: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthRequestModel
     */
    isPreAuth?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthRequestModel
     */
    pin?: string;
    /**
     * 
     * @type {CardOptions}
     * @memberof AuthRequestModel
     */
    cardOptions?: CardOptions;
    /**
     * 
     * @type {CardAcceptorModel}
     * @memberof AuthRequestModel
     */
    cardAcceptor?: CardAcceptorModel;
    /**
     * 
     * @type {TransactionOptions}
     * @memberof AuthRequestModel
     */
    transactionOptions?: TransactionOptions;
    /**
     * 
     * @type {NetworkMetadata}
     * @memberof AuthRequestModel
     */
    networkMetadata?: NetworkMetadata;
}

/**
 * 
 * @export
 * @interface AuthUser
 */
export interface AuthUser {
    /**
     * 36 char max
     * @type {string}
     * @memberof AuthUser
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof AuthUser
     */
    username: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthUser
     */
    active: boolean;
    /**
     * An array of roles
     * @type {Array<string>}
     * @memberof AuthUser
     */
    roles: Array<string>;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof AuthUser
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof AuthUser
     */
    lastModifiedTime: Date;
}

/**
 * 
 * @export
 * @interface AuthUserRequest
 */
export interface AuthUserRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthUserRequest
     */
    password: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthUserRequest
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthUserRequest
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AuthUserRequest
     */
    token?: string;
    /**
     * An array of roles
     * @type {Array<string>}
     * @memberof AuthUserRequest
     */
    roles: Array<string>;
}

/**
 * 
 * @export
 * @interface AuthUserUpdateRequest
 */
export interface AuthUserUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthUserUpdateRequest
     */
    password?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthUserUpdateRequest
     */
    active?: boolean;
    /**
     * An array of roles
     * @type {Array<string>}
     * @memberof AuthUserUpdateRequest
     */
    roles?: Array<string>;
}

/**
 * 
 * @export
 * @interface Authentication
 */
export interface Authentication {
    /**
     * 
     * @type {string}
     * @memberof Authentication
     */
    lastPasswordUpdateChannel?: Authentication.LastPasswordUpdateChannelEnum;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof Authentication
     */
    lastPasswordUpdateTime?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Authentication
     */
    emailVerified?: boolean;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof Authentication
     */
    emailVerifiedTime?: Date;
}

/**
 * @export
 * @namespace Authentication
 */
export namespace Authentication {
    /**
     * @export
     * @enum {string}
     */
    export enum LastPasswordUpdateChannelEnum {
        CHANGE = <any> 'USER_CHANGE',
        RESET = <any> 'USER_RESET'
    }
}

/**
 * 
 * @export
 * @interface AuthorizationAdviceModel
 */
export interface AuthorizationAdviceModel {
    /**
     * 
     * @type {number}
     * @memberof AuthorizationAdviceModel
     */
    amount: number;
    /**
     * 
     * @type {Array<NetworkFeeModel>}
     * @memberof AuthorizationAdviceModel
     */
    networkFees?: Array<NetworkFeeModel>;
    /**
     * 
     * @type {Webhook}
     * @memberof AuthorizationAdviceModel
     */
    webhook?: Webhook;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationAdviceModel
     */
    originalTransactionToken: string;
    /**
     * 
     * @type {TransactionOptions}
     * @memberof AuthorizationAdviceModel
     */
    transactionOptions?: TransactionOptions;
}

/**
 * 
 * @export
 * @interface AutoCommandoModeProgramFundingSourceResponse
 */
export interface AutoCommandoModeProgramFundingSourceResponse {
    /**
     * 
     * @type {string}
     * @memberof AutoCommandoModeProgramFundingSourceResponse
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof AutoCommandoModeProgramFundingSourceResponse
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AutoCommandoModeProgramFundingSourceResponse
     */
    token: string;
    /**
     * 
     * @type {Date}
     * @memberof AutoCommandoModeProgramFundingSourceResponse
     */
    createdTime: Date;
    /**
     * 
     * @type {Date}
     * @memberof AutoCommandoModeProgramFundingSourceResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof AutoCommandoModeProgramFundingSourceResponse
     */
    account: string;
}

/**
 * 
 * @export
 * @interface AutoCommandoModeRequest
 */
export interface AutoCommandoModeRequest {
    /**
     * 
     * @type {InternalFundingSource}
     * @memberof AutoCommandoModeRequest
     */
    programGatewayFundingSource: InternalFundingSource;
    /**
     * 
     * @type {InternalGatewayResponse}
     * @memberof AutoCommandoModeRequest
     */
    gatewayResponse: InternalGatewayResponse;
    /**
     * 
     * @type {VelocityControlCheckRequest}
     * @memberof AutoCommandoModeRequest
     */
    velocityControlRequest: VelocityControlCheckRequest;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutoCommandoModeRequest
     */
    mccGroups?: Array<string>;
}

/**
 * 
 * @export
 * @interface AutoCommandoModeResponse
 */
export interface AutoCommandoModeResponse {
    /**
     * 
     * @type {Response}
     * @memberof AutoCommandoModeResponse
     */
    response?: Response;
    /**
     * 
     * @type {CommandoModeResponse}
     * @memberof AutoCommandoModeResponse
     */
    commandoModeResponse?: CommandoModeResponse;
    /**
     * 
     * @type {VelocityControlCheckResponse}
     * @memberof AutoCommandoModeResponse
     */
    velocityControlResponse?: VelocityControlCheckResponse;
    /**
     * 
     * @type {AutoCommandoModeProgramFundingSourceResponse}
     * @memberof AutoCommandoModeResponse
     */
    programFundingSourceResponse?: AutoCommandoModeProgramFundingSourceResponse;
}

/**
 * 
 * @export
 * @interface AutoReloadAssociation
 */
export interface AutoReloadAssociation {
    /**
     * 
     * @type {string}
     * @memberof AutoReloadAssociation
     */
    cardProductToken?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoReloadAssociation
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoReloadAssociation
     */
    businessToken?: string;
}

/**
 * 
 * @export
 * @interface AutoReloadListResponse
 */
export interface AutoReloadListResponse {
    /**
     * 
     * @type {number}
     * @memberof AutoReloadListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof AutoReloadListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof AutoReloadListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AutoReloadListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<AutoReloadResponseModel>}
     * @memberof AutoReloadListResponse
     */
    data?: Array<AutoReloadResponseModel>;
}

/**
 * 
 * @export
 * @interface AutoReloadModel
 */
export interface AutoReloadModel {
    /**
     * 
     * @type {string}
     * @memberof AutoReloadModel
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AutoReloadModel
     */
    active?: boolean;
    /**
     * Required when order scope is GPA
     * @type {string}
     * @memberof AutoReloadModel
     */
    fundingSourceToken?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoReloadModel
     */
    fundingSourceAddressToken?: string;
    /**
     * 
     * @type {AutoReloadAssociation}
     * @memberof AutoReloadModel
     */
    association?: AutoReloadAssociation;
    /**
     * either GPA or MSA is required
     * @type {OrderScope}
     * @memberof AutoReloadModel
     */
    orderScope: OrderScope;
    /**
     * 
     * @type {string}
     * @memberof AutoReloadModel
     */
    currencyCode: string;
}

/**
 * 
 * @export
 * @interface AutoReloadResponseModel
 */
export interface AutoReloadResponseModel {
    /**
     * 
     * @type {string}
     * @memberof AutoReloadResponseModel
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AutoReloadResponseModel
     */
    active?: boolean;
    /**
     * Required when order scope is GPA
     * @type {string}
     * @memberof AutoReloadResponseModel
     */
    fundingSourceToken?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoReloadResponseModel
     */
    fundingSourceAddressToken?: string;
    /**
     * 
     * @type {AutoReloadAssociation}
     * @memberof AutoReloadResponseModel
     */
    association?: AutoReloadAssociation;
    /**
     * either GPA or MSA is required
     * @type {OrderScope}
     * @memberof AutoReloadResponseModel
     */
    orderScope: OrderScope;
    /**
     * 
     * @type {string}
     * @memberof AutoReloadResponseModel
     */
    currencyCode: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof AutoReloadResponseModel
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof AutoReloadResponseModel
     */
    lastModifiedTime: Date;
}

/**
 * 
 * @export
 * @interface AutoReloadUpdateModel
 */
export interface AutoReloadUpdateModel {
    /**
     * 
     * @type {string}
     * @memberof AutoReloadUpdateModel
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AutoReloadUpdateModel
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AutoReloadUpdateModel
     */
    fundingSourceToken?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoReloadUpdateModel
     */
    fundingSourceAddressToken?: string;
    /**
     * 
     * @type {AutoReloadAssociation}
     * @memberof AutoReloadUpdateModel
     */
    association?: AutoReloadAssociation;
    /**
     * 
     * @type {OrderScope}
     * @memberof AutoReloadUpdateModel
     */
    orderScope?: OrderScope;
    /**
     * 
     * @type {string}
     * @memberof AutoReloadUpdateModel
     */
    currencyCode?: string;
}

/**
 * 
 * @export
 * @interface Available
 */
export interface Available {
    /**
     * Uses available
     * @type {number}
     * @memberof Available
     */
    uses: number;
    /**
     * 
     * @type {number}
     * @memberof Available
     */
    amount: number;
    /**
     * Days remaining
     * @type {number}
     * @memberof Available
     */
    daysRemaining?: number;
}

/**
 * 
 * @export
 * @interface AvsControlOptions
 */
export interface AvsControlOptions {
    /**
     * 
     * @type {boolean}
     * @memberof AvsControlOptions
     */
    validate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AvsControlOptions
     */
    declineOnAddressNumberMismatch?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AvsControlOptions
     */
    declineOnPostalCodeMismatch?: boolean;
}

/**
 * 
 * @export
 * @interface AvsControls
 */
export interface AvsControls {
    /**
     * 
     * @type {AvsControlOptions}
     * @memberof AvsControls
     */
    avMessages?: AvsControlOptions;
    /**
     * 
     * @type {AvsControlOptions}
     * @memberof AvsControls
     */
    authMessages?: AvsControlOptions;
}

/**
 * 
 * @export
 * @interface AvsInformation
 */
export interface AvsInformation {
    /**
     * 
     * @type {string}
     * @memberof AvsInformation
     */
    streetAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof AvsInformation
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof AvsInformation
     */
    postalCode?: string;
}

/**
 * 
 * @export
 * @interface BalanceInquiryRequestModel
 */
export interface BalanceInquiryRequestModel {
    /**
     * 
     * @type {Array<NetworkFeeModel>}
     * @memberof BalanceInquiryRequestModel
     */
    networkFees?: Array<NetworkFeeModel>;
    /**
     * 
     * @type {Webhook}
     * @memberof BalanceInquiryRequestModel
     */
    webhook?: Webhook;
    /**
     * 
     * @type {string}
     * @memberof BalanceInquiryRequestModel
     */
    accountType: BalanceInquiryRequestModel.AccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BalanceInquiryRequestModel
     */
    cardToken: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceInquiryRequestModel
     */
    pin?: string;
    /**
     * 
     * @type {string}
     * @memberof BalanceInquiryRequestModel
     */
    mid: string;
    /**
     * 
     * @type {CardAcceptorModel}
     * @memberof BalanceInquiryRequestModel
     */
    cardAcceptor: CardAcceptorModel;
}

/**
 * @export
 * @namespace BalanceInquiryRequestModel
 */
export namespace BalanceInquiryRequestModel {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountTypeEnum {
        Checking = <any> 'checking',
        Savings = <any> 'savings',
        Credit = <any> 'credit'
    }
}

/**
 * 
 * @export
 * @interface BankAccountFundingSourceModel
 */
export interface BankAccountFundingSourceModel extends FundingSourceModel {
    /**
     * Required if 'business_token' is null
     * @type {string}
     * @memberof BankAccountFundingSourceModel
     */
    userToken?: string;
    /**
     * Required if 'user_token' is null
     * @type {string}
     * @memberof BankAccountFundingSourceModel
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountFundingSourceModel
     */
    accountSuffix: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountFundingSourceModel
     */
    accountType: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountFundingSourceModel
     */
    nameOnAccount: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountFundingSourceModel
     */
    routingNumber: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountFundingSourceModel
     */
    verificationStatus: string;
}

/**
 * 
 * @export
 * @interface BankTransferClearingRequestModel
 */
export interface BankTransferClearingRequestModel {
    /**
     * 
     * @type {number}
     * @memberof BankTransferClearingRequestModel
     */
    maxClears: number;
}

/**
 * 
 * @export
 * @interface BankTransferListResponse
 */
export interface BankTransferListResponse {
    /**
     * 
     * @type {number}
     * @memberof BankTransferListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof BankTransferListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof BankTransferListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BankTransferListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<BankTransferResponseModel>}
     * @memberof BankTransferListResponse
     */
    data?: Array<BankTransferResponseModel>;
}

/**
 * 
 * @export
 * @interface BankTransferRequestModel
 */
export interface BankTransferRequestModel {
    /**
     * 
     * @type {string}
     * @memberof BankTransferRequestModel
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof BankTransferRequestModel
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof BankTransferRequestModel
     */
    memo?: string;
    /**
     * default = API
     * @type {string}
     * @memberof BankTransferRequestModel
     */
    channel?: BankTransferRequestModel.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransferRequestModel
     */
    fundingSourceToken: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferRequestModel
     */
    type: BankTransferRequestModel.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransferRequestModel
     */
    statementDescriptor?: string;
    /**
     * default = USD
     * @type {string}
     * @memberof BankTransferRequestModel
     */
    currencyCode?: string;
    /**
     * default = STANDARD
     * @type {string}
     * @memberof BankTransferRequestModel
     */
    transferSpeed?: BankTransferRequestModel.TransferSpeedEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransferRequestModel
     */
    standardEntryClassCode?: BankTransferRequestModel.StandardEntryClassCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransferRequestModel
     */
    createdBy?: string;
}

/**
 * @export
 * @namespace BankTransferRequestModel
 */
export namespace BankTransferRequestModel {
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        SYSTEM = <any> 'SYSTEM',
        ADMIN = <any> 'ADMIN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        PUSH = <any> 'PUSH',
        PULL = <any> 'PULL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TransferSpeedEnum {
        STANDARD = <any> 'STANDARD',
        SAMEDAY = <any> 'SAME_DAY'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StandardEntryClassCodeEnum {
        WEB = <any> 'WEB',
        PPD = <any> 'PPD',
        CCD = <any> 'CCD'
    }
}

/**
 * 
 * @export
 * @interface BankTransferResponseModel
 */
export interface BankTransferResponseModel {
    /**
     * 
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof BankTransferResponseModel
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    memo?: string;
    /**
     * default = API
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    channel?: BankTransferResponseModel.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    fundingSourceToken: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    type: BankTransferResponseModel.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    statementDescriptor?: string;
    /**
     * default = USD
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    currencyCode?: string;
    /**
     * default = STANDARD
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    transferSpeed?: BankTransferResponseModel.TransferSpeedEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    standardEntryClassCode?: BankTransferResponseModel.StandardEntryClassCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    status?: BankTransferResponseModel.StatusEnum;
    /**
     * 
     * @type {Array<BankTransferTransitionResponseModel>}
     * @memberof BankTransferResponseModel
     */
    transitions?: Array<BankTransferTransitionResponseModel>;
    /**
     * 
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    batchNumber?: string;
    /**
     * 
     * @type {Date}
     * @memberof BankTransferResponseModel
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof BankTransferResponseModel
     */
    lastModifiedTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    returnCode?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferResponseModel
     */
    returnReason?: string;
}

/**
 * @export
 * @namespace BankTransferResponseModel
 */
export namespace BankTransferResponseModel {
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        SYSTEM = <any> 'SYSTEM',
        ADMIN = <any> 'ADMIN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        PUSH = <any> 'PUSH',
        PULL = <any> 'PULL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TransferSpeedEnum {
        STANDARD = <any> 'STANDARD',
        SAMEDAY = <any> 'SAME_DAY'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StandardEntryClassCodeEnum {
        WEB = <any> 'WEB',
        PPD = <any> 'PPD',
        CCD = <any> 'CCD'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        INITIATED = <any> 'INITIATED',
        PENDING = <any> 'PENDING',
        PROCESSING = <any> 'PROCESSING',
        SUBMITTED = <any> 'SUBMITTED',
        RETURNED = <any> 'RETURNED',
        COMPLETED = <any> 'COMPLETED',
        ERROR = <any> 'ERROR',
        CANCELLED = <any> 'CANCELLED',
        REVERSALPEND = <any> 'REVERSAL_PEND',
        REVERSALCOMP = <any> 'REVERSAL_COMP',
        REVERSALDECL = <any> 'REVERSAL_DECL'
    }
}

/**
 * 
 * @export
 * @interface BankTransferTransitionListResponse
 */
export interface BankTransferTransitionListResponse {
    /**
     * 
     * @type {number}
     * @memberof BankTransferTransitionListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof BankTransferTransitionListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof BankTransferTransitionListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BankTransferTransitionListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<BankTransferTransitionResponseModel>}
     * @memberof BankTransferTransitionListResponse
     */
    data?: Array<BankTransferTransitionResponseModel>;
}

/**
 * 
 * @export
 * @interface BankTransferTransitionRequestModel
 */
export interface BankTransferTransitionRequestModel {
    /**
     * 
     * @type {number}
     * @memberof BankTransferTransitionRequestModel
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionRequestModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionRequestModel
     */
    bankTransferToken: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionRequestModel
     */
    status: BankTransferTransitionRequestModel.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionRequestModel
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionRequestModel
     */
    channel: BankTransferTransitionRequestModel.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionRequestModel
     */
    batchNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionRequestModel
     */
    programReserveToken?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionRequestModel
     */
    returnCode?: string;
    /**
     * 
     * @type {Date}
     * @memberof BankTransferTransitionRequestModel
     */
    effectiveDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof BankTransferTransitionRequestModel
     */
    reversalAfter45Days?: boolean;
}

/**
 * @export
 * @namespace BankTransferTransitionRequestModel
 */
export namespace BankTransferTransitionRequestModel {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PENDING = <any> 'PENDING',
        PROCESSING = <any> 'PROCESSING',
        SUBMITTED = <any> 'SUBMITTED',
        RETURNED = <any> 'RETURNED',
        COMPLETED = <any> 'COMPLETED',
        CANCELLED = <any> 'CANCELLED',
        REVERSALPEND = <any> 'REVERSAL_PEND',
        REVERSALCOMP = <any> 'REVERSAL_COMP'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        SYSTEM = <any> 'SYSTEM',
        ADMIN = <any> 'ADMIN'
    }
}

/**
 * 
 * @export
 * @interface BankTransferTransitionResponseModel
 */
export interface BankTransferTransitionResponseModel {
    /**
     * 
     * @type {number}
     * @memberof BankTransferTransitionResponseModel
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionResponseModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionResponseModel
     */
    bankTransferToken: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionResponseModel
     */
    status: BankTransferTransitionResponseModel.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionResponseModel
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionResponseModel
     */
    channel: BankTransferTransitionResponseModel.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionResponseModel
     */
    batchNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionResponseModel
     */
    programReserveToken?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionResponseModel
     */
    returnCode?: string;
    /**
     * 
     * @type {Date}
     * @memberof BankTransferTransitionResponseModel
     */
    effectiveDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof BankTransferTransitionResponseModel
     */
    reversalAfter45Days?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionResponseModel
     */
    transactionToken?: string;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionResponseModel
     */
    transactionJitToken?: string;
    /**
     * 
     * @type {Date}
     * @memberof BankTransferTransitionResponseModel
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof BankTransferTransitionResponseModel
     */
    lastModifiedTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof BankTransferTransitionResponseModel
     */
    returnReason?: string;
}

/**
 * @export
 * @namespace BankTransferTransitionResponseModel
 */
export namespace BankTransferTransitionResponseModel {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PENDING = <any> 'PENDING',
        PROCESSING = <any> 'PROCESSING',
        SUBMITTED = <any> 'SUBMITTED',
        RETURNED = <any> 'RETURNED',
        COMPLETED = <any> 'COMPLETED',
        CANCELLED = <any> 'CANCELLED',
        REVERSALPEND = <any> 'REVERSAL_PEND',
        REVERSALCOMP = <any> 'REVERSAL_COMP'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        SYSTEM = <any> 'SYSTEM',
        ADMIN = <any> 'ADMIN'
    }
}

/**
 * 
 * @export
 * @interface BaseAchExtendedResponseModel
 */
export interface BaseAchExtendedResponseModel {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof BaseAchExtendedResponseModel
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof BaseAchExtendedResponseModel
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof BaseAchExtendedResponseModel
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchExtendedResponseModel
     */
    accountSuffix: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchExtendedResponseModel
     */
    verificationStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchExtendedResponseModel
     */
    accountType: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchExtendedResponseModel
     */
    nameOnAccount: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchExtendedResponseModel
     */
    bankName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAchExtendedResponseModel
     */
    active: boolean;
    /**
     * 
     * @type {Date}
     * @memberof BaseAchExtendedResponseModel
     */
    dateSentForVerification?: Date;
    /**
     * 
     * @type {string}
     * @memberof BaseAchExtendedResponseModel
     */
    partner?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchExtendedResponseModel
     */
    partnerAccountLinkReferenceToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAchExtendedResponseModel
     */
    isDefaultAccount?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof BaseAchExtendedResponseModel
     */
    dateVerified?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAchExtendedResponseModel
     */
    verificationOverride?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseAchExtendedResponseModel
     */
    verificationNotes?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchExtendedResponseModel
     */
    routingNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchExtendedResponseModel
     */
    accountNumber?: string;
}

/**
 * 
 * @export
 * @interface BaseAchRequestModel
 */
export interface BaseAchRequestModel {
    /**
     * 
     * @type {string}
     * @memberof BaseAchRequestModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchRequestModel
     */
    accountNumber: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchRequestModel
     */
    routingNumber: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchRequestModel
     */
    nameOnAccount: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchRequestModel
     */
    accountType: BaseAchRequestModel.AccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BaseAchRequestModel
     */
    bankName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAchRequestModel
     */
    verificationOverride?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseAchRequestModel
     */
    verificationNotes?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAchRequestModel
     */
    isDefaultAccount?: boolean;
}

/**
 * @export
 * @namespace BaseAchRequestModel
 */
export namespace BaseAchRequestModel {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountTypeEnum {
        Checking = <any> 'checking',
        Savings = <any> 'savings',
        Corporate = <any> 'corporate',
        Loan = <any> 'loan'
    }
}

/**
 * 
 * @export
 * @interface BaseAchResponseModel
 */
export interface BaseAchResponseModel {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof BaseAchResponseModel
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof BaseAchResponseModel
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof BaseAchResponseModel
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchResponseModel
     */
    accountSuffix: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchResponseModel
     */
    verificationStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchResponseModel
     */
    accountType: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchResponseModel
     */
    nameOnAccount: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchResponseModel
     */
    bankName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAchResponseModel
     */
    active: boolean;
    /**
     * 
     * @type {Date}
     * @memberof BaseAchResponseModel
     */
    dateSentForVerification?: Date;
    /**
     * 
     * @type {string}
     * @memberof BaseAchResponseModel
     */
    partner?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAchResponseModel
     */
    partnerAccountLinkReferenceToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAchResponseModel
     */
    isDefaultAccount?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof BaseAchResponseModel
     */
    dateVerified?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAchResponseModel
     */
    verificationOverride?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseAchResponseModel
     */
    verificationNotes?: string;
}

/**
 * 
 * @export
 * @interface BeneficialOwnerRequest
 */
export interface BeneficialOwnerRequest {
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnerRequest
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnerRequest
     */
    middleName?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnerRequest
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnerRequest
     */
    title?: string;
    /**
     * 
     * @type {AddressRequestModel}
     * @memberof BeneficialOwnerRequest
     */
    home?: AddressRequestModel;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnerRequest
     */
    ssn?: string;
    /**
     * 
     * @type {Date}
     * @memberof BeneficialOwnerRequest
     */
    dob?: Date;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnerRequest
     */
    phone?: string;
}

/**
 * 
 * @export
 * @interface BeneficialOwnerResponse
 */
export interface BeneficialOwnerResponse {
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnerResponse
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnerResponse
     */
    middleName?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnerResponse
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnerResponse
     */
    title?: string;
    /**
     * 
     * @type {AddressResponseModel}
     * @memberof BeneficialOwnerResponse
     */
    home?: AddressResponseModel;
    /**
     * 
     * @type {Date}
     * @memberof BeneficialOwnerResponse
     */
    getdob?: Date;
    /**
     * 
     * @type {string}
     * @memberof BeneficialOwnerResponse
     */
    phone?: string;
}

/**
 * 
 * @export
 * @interface BillPaymentCompletionRequest
 */
export interface BillPaymentCompletionRequest {
    /**
     * 
     * @type {string}
     * @memberof BillPaymentCompletionRequest
     */
    networkReferenceId: string;
    /**
     * 
     * @type {string}
     * @memberof BillPaymentCompletionRequest
     */
    originalTransactionToken: string;
}

/**
 * 
 * @export
 * @interface BillPaymentTransactionRequest
 */
export interface BillPaymentTransactionRequest {
    /**
     * 
     * @type {number}
     * @memberof BillPaymentTransactionRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof BillPaymentTransactionRequest
     */
    currency: string;
    /**
     * 
     * @type {string}
     * @memberof BillPaymentTransactionRequest
     */
    networkReferenceId: string;
    /**
     * 
     * @type {string}
     * @memberof BillPaymentTransactionRequest
     */
    userToken: string;
}

/**
 * 
 * @export
 * @interface BillingAddress
 */
export interface BillingAddress {
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    compressedZip?: string;
}

/**
 * 
 * @export
 * @interface BinPanIssuedCountResponse
 */
export interface BinPanIssuedCountResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof BinPanIssuedCountResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof BinPanIssuedCountResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof BinPanIssuedCountResponse
     */
    binHash: string;
    /**
     * 
     * @type {number}
     * @memberof BinPanIssuedCountResponse
     */
    count: number;
    /**
     * 
     * @type {number}
     * @memberof BinPanIssuedCountResponse
     */
    maxCards?: number;
}

/**
 * 
 * @export
 * @interface BulkCardOrderListResponse
 */
export interface BulkCardOrderListResponse {
    /**
     * 
     * @type {number}
     * @memberof BulkCardOrderListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof BulkCardOrderListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof BulkCardOrderListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BulkCardOrderListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<BulkIssuanceResponse>}
     * @memberof BulkCardOrderListResponse
     */
    data?: Array<BulkIssuanceResponse>;
}

/**
 * 
 * @export
 * @interface BulkIssuanceRequest
 */
export interface BulkIssuanceRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkIssuanceRequest
     */
    token: string;
    /**
     * 
     * @type {FulfillmentRequest}
     * @memberof BulkIssuanceRequest
     */
    fulfillment: FulfillmentRequest;
    /**
     * 
     * @type {boolean}
     * @memberof BulkIssuanceRequest
     */
    expedite?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BulkIssuanceRequest
     */
    cardProductToken: string;
    /**
     * 
     * @type {number}
     * @memberof BulkIssuanceRequest
     */
    cardAllocation: number;
    /**
     * 
     * @type {UserAssociation}
     * @memberof BulkIssuanceRequest
     */
    userAssociation?: UserAssociation;
    /**
     * 
     * @type {boolean}
     * @memberof BulkIssuanceRequest
     */
    nameLine1NumericPostfix?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BulkIssuanceRequest
     */
    nameLine1RandomPostfix?: boolean;
    /**
     * 
     * @type {ExpirationOffset}
     * @memberof BulkIssuanceRequest
     */
    expirationOffset?: ExpirationOffset;
}

/**
 * 
 * @export
 * @interface BulkIssuanceResponse
 */
export interface BulkIssuanceResponse {
    /**
     * 
     * @type {string}
     * @memberof BulkIssuanceResponse
     */
    token: string;
    /**
     * 
     * @type {FulfillmentResponse}
     * @memberof BulkIssuanceResponse
     */
    fulfillment: FulfillmentResponse;
    /**
     * 
     * @type {boolean}
     * @memberof BulkIssuanceResponse
     */
    expedite?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BulkIssuanceResponse
     */
    cardProductToken: string;
    /**
     * 
     * @type {number}
     * @memberof BulkIssuanceResponse
     */
    cardAllocation: number;
    /**
     * 
     * @type {UserAssociation}
     * @memberof BulkIssuanceResponse
     */
    userAssociation?: UserAssociation;
    /**
     * 
     * @type {boolean}
     * @memberof BulkIssuanceResponse
     */
    nameLine1NumericPostfix?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BulkIssuanceResponse
     */
    nameLine1RandomPostfix?: boolean;
    /**
     * 
     * @type {ExpirationOffset}
     * @memberof BulkIssuanceResponse
     */
    expirationOffset?: ExpirationOffset;
    /**
     * 
     * @type {number}
     * @memberof BulkIssuanceResponse
     */
    cardsProcessed?: number;
    /**
     * 
     * @type {Date}
     * @memberof BulkIssuanceResponse
     */
    createdTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof BulkIssuanceResponse
     */
    nameLine1StartIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof BulkIssuanceResponse
     */
    nameLine1EndIndex?: number;
    /**
     * 
     * @type {Date}
     * @memberof BulkIssuanceResponse
     */
    cardFulfillmentTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof BulkIssuanceResponse
     */
    providerShipDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof BulkIssuanceResponse
     */
    providerShippingMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkIssuanceResponse
     */
    providerTrackingNumber?: string;
}

/**
 * 
 * @export
 * @interface BulkRequestModel
 */
export interface BulkRequestModel {
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkRequestModel
     */
    userTokens?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkRequestModel
     */
    businessTokens?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkRequestModel
     */
    cardTokens?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkRequestModel
     */
    kycTokens?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkRequestModel
     */
    ddaTokens?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkRequestModel
     */
    depositAccounts?: Array<string>;
}

/**
 * 
 * @export
 * @interface BusinessCardHolderListResponse
 */
export interface BusinessCardHolderListResponse {
    /**
     * 
     * @type {number}
     * @memberof BusinessCardHolderListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof BusinessCardHolderListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof BusinessCardHolderListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessCardHolderListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<BusinessCardholder>}
     * @memberof BusinessCardHolderListResponse
     */
    data?: Array<BusinessCardholder>;
}

/**
 * 
 * @export
 * @interface BusinessCardHolderResponse
 */
export interface BusinessCardHolderResponse {
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    token?: string;
    /**
     * default = true
     * @type {boolean}
     * @memberof BusinessCardHolderResponse
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    notes?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    ipAddress?: string;
    /**
     * Strong password required
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    phone?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BusinessCardHolderResponse
     */
    metadata?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    accountHolderGroupToken?: string;
    /**
     * 
     * @type {Authentication}
     * @memberof BusinessCardHolderResponse
     */
    authentication?: Authentication;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof BusinessCardHolderResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof BusinessCardHolderResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    status?: BusinessCardHolderResponse.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    businessNameLegal?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    businessNameDba?: string;
    /**
     * 
     * @type {AddressResponseModel}
     * @memberof BusinessCardHolderResponse
     */
    officeLocation?: AddressResponseModel;
    /**
     * 
     * @type {Date}
     * @memberof BusinessCardHolderResponse
     */
    inCurrentLocationSince?: Date;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    website?: string;
    /**
     * 
     * @type {Date}
     * @memberof BusinessCardHolderResponse
     */
    dateEstablished?: Date;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    generalBusinessDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    history?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    businessType?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    internationalOfficeLocations?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    taxpayerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    dunsNumber?: string;
    /**
     * 
     * @type {PrimaryContactInfoModel}
     * @memberof BusinessCardHolderResponse
     */
    primaryContact?: PrimaryContactInfoModel;
    /**
     * 
     * @type {BusinessIncorporationResponse}
     * @memberof BusinessCardHolderResponse
     */
    incorporation?: BusinessIncorporationResponse;
    /**
     * 
     * @type {BusinessProprietorResponse}
     * @memberof BusinessCardHolderResponse
     */
    proprietorOrOfficer?: BusinessProprietorResponse;
    /**
     * 
     * @type {Array<IdentificationResponseModel>}
     * @memberof BusinessCardHolderResponse
     */
    identifications?: Array<IdentificationResponseModel>;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    attesterName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessCardHolderResponse
     */
    attestationConsent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderResponse
     */
    attesterTitle?: string;
    /**
     * 
     * @type {Date}
     * @memberof BusinessCardHolderResponse
     */
    attestationDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessCardHolderResponse
     */
    proprietorIsBeneficialOwner?: boolean;
    /**
     * 
     * @type {BeneficialOwnerResponse}
     * @memberof BusinessCardHolderResponse
     */
    beneficialOwner1?: BeneficialOwnerResponse;
    /**
     * 
     * @type {BeneficialOwnerResponse}
     * @memberof BusinessCardHolderResponse
     */
    beneficialOwner2?: BeneficialOwnerResponse;
    /**
     * 
     * @type {BeneficialOwnerResponse}
     * @memberof BusinessCardHolderResponse
     */
    beneficialOwner3?: BeneficialOwnerResponse;
    /**
     * 
     * @type {BeneficialOwnerResponse}
     * @memberof BusinessCardHolderResponse
     */
    beneficialOwner4?: BeneficialOwnerResponse;
}

/**
 * @export
 * @namespace BusinessCardHolderResponse
 */
export namespace BusinessCardHolderResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        UNVERIFIED = <any> 'UNVERIFIED',
        LIMITED = <any> 'LIMITED',
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        CLOSED = <any> 'CLOSED'
    }
}

/**
 * 
 * @export
 * @interface BusinessCardHolderUpdate
 */
export interface BusinessCardHolderUpdate {
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessCardHolderUpdate
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    notes?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    ipAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    phone?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BusinessCardHolderUpdate
     */
    metadata?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    accountHolderGroupToken?: string;
    /**
     * 
     * @type {Array<IdentificationRequestModel>}
     * @memberof BusinessCardHolderUpdate
     */
    identifications?: Array<IdentificationRequestModel>;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    businessNameLegal?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    businessNameDba?: string;
    /**
     * 
     * @type {AddressRequestModel}
     * @memberof BusinessCardHolderUpdate
     */
    officeLocation?: AddressRequestModel;
    /**
     * 
     * @type {Date}
     * @memberof BusinessCardHolderUpdate
     */
    inCurrentLocationSince?: Date;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    website?: string;
    /**
     * 
     * @type {Date}
     * @memberof BusinessCardHolderUpdate
     */
    dateEstablished?: Date;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    generalBusinessDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    history?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    businessType?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    internationalOfficeLocations?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    taxpayerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    dunsNumber?: string;
    /**
     * 
     * @type {PrimaryContactInfoModel}
     * @memberof BusinessCardHolderUpdate
     */
    primaryContact?: PrimaryContactInfoModel;
    /**
     * 
     * @type {BusinessIncorporation}
     * @memberof BusinessCardHolderUpdate
     */
    incorporation?: BusinessIncorporation;
    /**
     * 
     * @type {BusinessProprietor}
     * @memberof BusinessCardHolderUpdate
     */
    proprietorOrOfficer?: BusinessProprietor;
    /**
     * 
     * @type {BeneficialOwnerRequest}
     * @memberof BusinessCardHolderUpdate
     */
    beneficialOwner1?: BeneficialOwnerRequest;
    /**
     * 
     * @type {BeneficialOwnerRequest}
     * @memberof BusinessCardHolderUpdate
     */
    beneficialOwner2?: BeneficialOwnerRequest;
    /**
     * 
     * @type {BeneficialOwnerRequest}
     * @memberof BusinessCardHolderUpdate
     */
    beneficialOwner3?: BeneficialOwnerRequest;
    /**
     * 
     * @type {BeneficialOwnerRequest}
     * @memberof BusinessCardHolderUpdate
     */
    beneficialOwner4?: BeneficialOwnerRequest;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    attesterName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessCardHolderUpdate
     */
    attestationConsent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardHolderUpdate
     */
    attesterTitle?: string;
    /**
     * 
     * @type {Date}
     * @memberof BusinessCardHolderUpdate
     */
    attestationDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessCardHolderUpdate
     */
    proprietorIsBeneficialOwner?: boolean;
}

/**
 * 
 * @export
 * @interface BusinessCardholder
 */
export interface BusinessCardholder {
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessCardholder
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    notes?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    ipAddress?: string;
    /**
     * Strong password required
     * @type {string}
     * @memberof BusinessCardholder
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    phone?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BusinessCardholder
     */
    metadata?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    accountHolderGroupToken?: string;
    /**
     * 
     * @type {Array<IdentificationRequestModel>}
     * @memberof BusinessCardholder
     */
    identifications?: Array<IdentificationRequestModel>;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    businessNameLegal?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    businessNameDba?: string;
    /**
     * 
     * @type {AddressRequestModel}
     * @memberof BusinessCardholder
     */
    officeLocation?: AddressRequestModel;
    /**
     * 
     * @type {Date}
     * @memberof BusinessCardholder
     */
    inCurrentLocationSince?: Date;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    website?: string;
    /**
     * 
     * @type {Date}
     * @memberof BusinessCardholder
     */
    dateEstablished?: Date;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    generalBusinessDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    history?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    businessType?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    internationalOfficeLocations?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    taxpayerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    dunsNumber?: string;
    /**
     * 
     * @type {PrimaryContactInfoModel}
     * @memberof BusinessCardholder
     */
    primaryContact?: PrimaryContactInfoModel;
    /**
     * 
     * @type {BusinessIncorporation}
     * @memberof BusinessCardholder
     */
    incorporation?: BusinessIncorporation;
    /**
     * 
     * @type {BusinessProprietor}
     * @memberof BusinessCardholder
     */
    proprietorOrOfficer?: BusinessProprietor;
    /**
     * 
     * @type {BeneficialOwnerRequest}
     * @memberof BusinessCardholder
     */
    beneficialOwner1?: BeneficialOwnerRequest;
    /**
     * 
     * @type {BeneficialOwnerRequest}
     * @memberof BusinessCardholder
     */
    beneficialOwner2?: BeneficialOwnerRequest;
    /**
     * 
     * @type {BeneficialOwnerRequest}
     * @memberof BusinessCardholder
     */
    beneficialOwner3?: BeneficialOwnerRequest;
    /**
     * 
     * @type {BeneficialOwnerRequest}
     * @memberof BusinessCardholder
     */
    beneficialOwner4?: BeneficialOwnerRequest;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    attesterName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessCardholder
     */
    attestationConsent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BusinessCardholder
     */
    attesterTitle?: string;
    /**
     * YYYY-MM-DDThh:mm:ssZ
     * @type {Date}
     * @memberof BusinessCardholder
     */
    attestationDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessCardholder
     */
    proprietorIsBeneficialOwner?: boolean;
}

/**
 * 
 * @export
 * @interface BusinessIncorporation
 */
export interface BusinessIncorporation {
    /**
     * 
     * @type {boolean}
     * @memberof BusinessIncorporation
     */
    isPublic?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BusinessIncorporation
     */
    stockSymbol?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessIncorporation
     */
    stateOfIncorporation?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessIncorporation
     */
    nameRegisteredUnder?: string;
    /**
     * 
     * @type {AddressRequestModel}
     * @memberof BusinessIncorporation
     */
    addressRegisteredUnder?: AddressRequestModel;
    /**
     * 
     * @type {string}
     * @memberof BusinessIncorporation
     */
    incorporationType?: BusinessIncorporation.IncorporationTypeEnum;
}

/**
 * @export
 * @namespace BusinessIncorporation
 */
export namespace BusinessIncorporation {
    /**
     * @export
     * @enum {string}
     */
    export enum IncorporationTypeEnum {
        LLC = <any> 'LLC',
        CORPORATION = <any> 'CORPORATION',
        SOLEPROPRIETORSHIP = <any> 'SOLE_PROPRIETORSHIP',
        PARTNERSHIP = <any> 'PARTNERSHIP',
        COOPERATIVE = <any> 'COOPERATIVE',
        OTHER = <any> 'OTHER'
    }
}

/**
 * 
 * @export
 * @interface BusinessIncorporationResponse
 */
export interface BusinessIncorporationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BusinessIncorporationResponse
     */
    isPublic?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BusinessIncorporationResponse
     */
    stockSymbol?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessIncorporationResponse
     */
    stateOfIncorporation?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessIncorporationResponse
     */
    nameRegisteredUnder?: string;
    /**
     * 
     * @type {AddressResponseModel}
     * @memberof BusinessIncorporationResponse
     */
    addressRegisteredUnder?: AddressResponseModel;
    /**
     * 
     * @type {string}
     * @memberof BusinessIncorporationResponse
     */
    incorporationType?: BusinessIncorporationResponse.IncorporationTypeEnum;
}

/**
 * @export
 * @namespace BusinessIncorporationResponse
 */
export namespace BusinessIncorporationResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum IncorporationTypeEnum {
        LLC = <any> 'LLC',
        CORPORATION = <any> 'CORPORATION',
        SOLEPROPRIETORSHIP = <any> 'SOLE_PROPRIETORSHIP',
        PARTNERSHIP = <any> 'PARTNERSHIP',
        OTHER = <any> 'OTHER'
    }
}

/**
 * 
 * @export
 * @interface BusinessMetadata
 */
export interface BusinessMetadata {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BusinessMetadata
     */
    metadata?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface BusinessProprietor
 */
export interface BusinessProprietor {
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietor
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietor
     */
    middleName?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietor
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietor
     */
    alternativeNames?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietor
     */
    title?: string;
    /**
     * 
     * @type {AddressRequestModel}
     * @memberof BusinessProprietor
     */
    home?: AddressRequestModel;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietor
     */
    ssn?: string;
    /**
     * 
     * @type {Date}
     * @memberof BusinessProprietor
     */
    dob?: Date;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietor
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietor
     */
    email?: string;
    /**
     * 
     * @type {Array<IdentificationRequestModel>}
     * @memberof BusinessProprietor
     */
    identifications?: Array<IdentificationRequestModel>;
}

/**
 * 
 * @export
 * @interface BusinessProprietorResponse
 */
export interface BusinessProprietorResponse {
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietorResponse
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietorResponse
     */
    middleName?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietorResponse
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietorResponse
     */
    alternativeNames?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietorResponse
     */
    title?: string;
    /**
     * 
     * @type {AddressResponseModel}
     * @memberof BusinessProprietorResponse
     */
    home?: AddressResponseModel;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietorResponse
     */
    ssn?: string;
    /**
     * 
     * @type {Date}
     * @memberof BusinessProprietorResponse
     */
    dob?: Date;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietorResponse
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessProprietorResponse
     */
    email?: string;
    /**
     * 
     * @type {Array<IdentificationResponseModel>}
     * @memberof BusinessProprietorResponse
     */
    identifications?: Array<IdentificationResponseModel>;
}

/**
 * 
 * @export
 * @interface BusinessTransitionListResponse
 */
export interface BusinessTransitionListResponse {
    /**
     * 
     * @type {number}
     * @memberof BusinessTransitionListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof BusinessTransitionListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof BusinessTransitionListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessTransitionListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<BusinessTransitionResponse>}
     * @memberof BusinessTransitionListResponse
     */
    data?: Array<BusinessTransitionResponse>;
}

/**
 * 
 * @export
 * @interface BusinessTransitionRequest
 */
export interface BusinessTransitionRequest {
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionRequest
     */
    idempotentHash?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionRequest
     */
    status: BusinessTransitionRequest.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionRequest
     */
    reasonCode: BusinessTransitionRequest.ReasonCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionRequest
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionRequest
     */
    channel: BusinessTransitionRequest.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionRequest
     */
    businessToken: string;
}

/**
 * @export
 * @namespace BusinessTransitionRequest
 */
export namespace BusinessTransitionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        UNVERIFIED = <any> 'UNVERIFIED',
        LIMITED = <any> 'LIMITED',
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        CLOSED = <any> 'CLOSED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonCodeEnum {
        _00 = <any> '00',
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _06 = <any> '06',
        _07 = <any> '07',
        _08 = <any> '08',
        _09 = <any> '09',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _13 = <any> '13',
        _14 = <any> '14',
        _15 = <any> '15',
        _16 = <any> '16',
        _17 = <any> '17',
        _18 = <any> '18',
        _19 = <any> '19',
        _20 = <any> '20',
        _21 = <any> '21',
        _22 = <any> '22',
        _23 = <any> '23',
        _24 = <any> '24',
        _25 = <any> '25',
        _26 = <any> '26',
        _27 = <any> '27',
        _28 = <any> '28',
        _29 = <any> '29',
        _30 = <any> '30',
        _31 = <any> '31'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        IVR = <any> 'IVR',
        FRAUD = <any> 'FRAUD',
        ADMIN = <any> 'ADMIN',
        SYSTEM = <any> 'SYSTEM'
    }
}

/**
 * 
 * @export
 * @interface BusinessTransitionResponse
 */
export interface BusinessTransitionResponse {
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionResponse
     */
    status: BusinessTransitionResponse.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionResponse
     */
    reasonCode: BusinessTransitionResponse.ReasonCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionResponse
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionResponse
     */
    channel: BusinessTransitionResponse.ChannelEnum;
    /**
     * 
     * @type {Date}
     * @memberof BusinessTransitionResponse
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof BusinessTransitionResponse
     */
    lastModifiedTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof BusinessTransitionResponse
     */
    businessToken?: string;
}

/**
 * @export
 * @namespace BusinessTransitionResponse
 */
export namespace BusinessTransitionResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        UNVERIFIED = <any> 'UNVERIFIED',
        LIMITED = <any> 'LIMITED',
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        CLOSED = <any> 'CLOSED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonCodeEnum {
        _00 = <any> '00',
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _06 = <any> '06',
        _07 = <any> '07',
        _08 = <any> '08',
        _09 = <any> '09',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _13 = <any> '13',
        _14 = <any> '14',
        _15 = <any> '15',
        _16 = <any> '16',
        _17 = <any> '17',
        _18 = <any> '18',
        _19 = <any> '19',
        _20 = <any> '20',
        _21 = <any> '21',
        _22 = <any> '22',
        _23 = <any> '23',
        _24 = <any> '24',
        _25 = <any> '25',
        _26 = <any> '26',
        _27 = <any> '27',
        _28 = <any> '28',
        _29 = <any> '29',
        _30 = <any> '30',
        _31 = <any> '31'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        IVR = <any> 'IVR',
        FRAUD = <any> 'FRAUD',
        ADMIN = <any> 'ADMIN',
        SYSTEM = <any> 'SYSTEM'
    }
}

/**
 * 
 * @export
 * @interface BusinessUserCardHolderListResponse
 */
export interface BusinessUserCardHolderListResponse {
    /**
     * 
     * @type {number}
     * @memberof BusinessUserCardHolderListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof BusinessUserCardHolderListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof BusinessUserCardHolderListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BusinessUserCardHolderListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<UserCardHolderResponse>}
     * @memberof BusinessUserCardHolderListResponse
     */
    data?: Array<UserCardHolderResponse>;
}

/**
 * 
 * @export
 * @interface CacheError
 */
export interface CacheError {
    /**
     * 
     * @type {string}
     * @memberof CacheError
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CacheError
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface Cacheable
 */
export interface Cacheable {
    /**
     * 
     * @type {string}
     * @memberof Cacheable
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface CalculationSchedule
 */
export interface CalculationSchedule {
    /**
     * 
     * @type {string}
     * @memberof CalculationSchedule
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof CalculationSchedule
     */
    valueType?: CalculationSchedule.ValueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CalculationSchedule
     */
    name: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CalculationSchedule
     */
    steps: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CalculationSchedule
     */
    stepValues: Array<number>;
}

/**
 * @export
 * @namespace CalculationSchedule
 */
export namespace CalculationSchedule {
    /**
     * @export
     * @enum {string}
     */
    export enum ValueTypeEnum {
        AMOUNT = <any> 'AMOUNT',
        PERCENT = <any> 'PERCENT'
    }
}

/**
 * 
 * @export
 * @interface CalculationScheduleListResponse
 */
export interface CalculationScheduleListResponse {
    /**
     * 
     * @type {number}
     * @memberof CalculationScheduleListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof CalculationScheduleListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof CalculationScheduleListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CalculationScheduleListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<CalculationSchedule>}
     * @memberof CalculationScheduleListResponse
     */
    data?: Array<CalculationSchedule>;
}

/**
 * 
 * @export
 * @interface CardAcceptorModel
 */
export interface CardAcceptorModel {
    /**
     * 
     * @type {string}
     * @memberof CardAcceptorModel
     */
    mcc?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardAcceptorModel
     */
    partialApprovalCapable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardAcceptorModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAcceptorModel
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAcceptorModel
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAcceptorModel
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAcceptorModel
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAcceptorModel
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAcceptorModel
     */
    ecommerceSecurityLevelIndicator?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAcceptorModel
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAcceptorModel
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof CardAcceptorModel
     */
    customerServicePhone?: string;
}

/**
 * 
 * @export
 * @interface CardFulfillmentRequest
 */
export interface CardFulfillmentRequest {
    /**
     * 
     * @type {Shipping}
     * @memberof CardFulfillmentRequest
     */
    shipping?: Shipping;
    /**
     * 
     * @type {CardPersonalization}
     * @memberof CardFulfillmentRequest
     */
    cardPersonalization: CardPersonalization;
    /**
     * 
     * @type {string}
     * @memberof CardFulfillmentRequest
     */
    cardFulfillmentReason?: CardFulfillmentRequest.CardFulfillmentReasonEnum;
}

/**
 * @export
 * @namespace CardFulfillmentRequest
 */
export namespace CardFulfillmentRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum CardFulfillmentReasonEnum {
        NEW = <any> 'NEW',
        LOSTSTOLEN = <any> 'LOST_STOLEN',
        EXPIRED = <any> 'EXPIRED'
    }
}

/**
 * 
 * @export
 * @interface CardFulfillmentResponse
 */
export interface CardFulfillmentResponse {
    /**
     * 
     * @type {ShippingInformationResponse}
     * @memberof CardFulfillmentResponse
     */
    shipping?: ShippingInformationResponse;
    /**
     * 
     * @type {CardPersonalization}
     * @memberof CardFulfillmentResponse
     */
    cardPersonalization: CardPersonalization;
    /**
     * 
     * @type {string}
     * @memberof CardFulfillmentResponse
     */
    cardFulfillmentReason?: CardFulfillmentResponse.CardFulfillmentReasonEnum;
}

/**
 * @export
 * @namespace CardFulfillmentResponse
 */
export namespace CardFulfillmentResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum CardFulfillmentReasonEnum {
        NEW = <any> 'NEW',
        LOSTSTOLEN = <any> 'LOST_STOLEN',
        EXPIRED = <any> 'EXPIRED'
    }
}

/**
 * 
 * @export
 * @interface CardHolderAddressModel
 */
export interface CardHolderAddressModel {
    /**
     * Required if 'business_token' is not specified
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    userToken?: string;
    /**
     * Required if 'user_token' is not specified
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    address1: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    state: string;
    /**
     * Required if 'postal_code' is not specified
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    country: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    phone?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardHolderAddressModel
     */
    isDefaultAddress?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CardHolderAddressModel
     */
    active?: boolean;
    /**
     * Required if 'zip' is not specified
     * @type {string}
     * @memberof CardHolderAddressModel
     */
    postalCode?: string;
}

/**
 * 
 * @export
 * @interface CardHolderAddressUpdateModel
 */
export interface CardHolderAddressUpdateModel {
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressUpdateModel
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressUpdateModel
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressUpdateModel
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressUpdateModel
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressUpdateModel
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressUpdateModel
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressUpdateModel
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressUpdateModel
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressUpdateModel
     */
    phone?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardHolderAddressUpdateModel
     */
    isDefaultAddress?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CardHolderAddressUpdateModel
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardHolderAddressUpdateModel
     */
    postalCode?: string;
}

/**
 * 
 * @export
 * @interface CardHolderModel
 */
export interface CardHolderModel {
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardHolderModel
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    notes?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    ipAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    phone?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CardHolderModel
     */
    metadata?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    accountHolderGroupToken?: string;
    /**
     * 
     * @type {Array<IdentificationRequestModel>}
     * @memberof CardHolderModel
     */
    identifications?: Array<IdentificationRequestModel>;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    honorific?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    gender?: CardHolderModel.GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    middleName?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    birthDate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardHolderModel
     */
    corporateCardHolder?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    ssn?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    passportNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    passportExpirationDate?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    idCardNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    idCardExpirationDate?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    nationality?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    company?: string;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    parentToken?: string;
    /**
     * Default is false
     * @type {boolean}
     * @memberof CardHolderModel
     */
    usesParentAccount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardHolderModel
     */
    postalCode?: string;
}

/**
 * @export
 * @namespace CardHolderModel
 */
export namespace CardHolderModel {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        F = <any> 'F',
        M = <any> 'M'
    }
}

/**
 * 
 * @export
 * @interface CardHolderNoteListResponse
 */
export interface CardHolderNoteListResponse {
    /**
     * 
     * @type {number}
     * @memberof CardHolderNoteListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof CardHolderNoteListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof CardHolderNoteListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CardHolderNoteListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<CardholderNoteResponseModel>}
     * @memberof CardHolderNoteListResponse
     */
    data?: Array<CardholderNoteResponseModel>;
}

/**
 * 
 * @export
 * @interface CardInventoryRequest
 */
export interface CardInventoryRequest {
    /**
     * 
     * @type {string}
     * @memberof CardInventoryRequest
     */
    token?: string;
    /**
     * Package ID assigned by card fulfillment
     * @type {string}
     * @memberof CardInventoryRequest
     */
    packageId: string;
    /**
     * 
     * @type {number}
     * @memberof CardInventoryRequest
     */
    startingInventory: number;
}

/**
 * 
 * @export
 * @interface CardInventoryResponse
 */
export interface CardInventoryResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof CardInventoryResponse
     */
    createdTime: Date;
    /**
     * 
     * @type {string}
     * @memberof CardInventoryResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CardInventoryResponse
     */
    packageId: string;
    /**
     * 
     * @type {number}
     * @memberof CardInventoryResponse
     */
    startingInventory: number;
}

/**
 * 
 * @export
 * @interface CardLifeCycle
 */
export interface CardLifeCycle {
    /**
     * 
     * @type {boolean}
     * @memberof CardLifeCycle
     */
    activateUponIssue?: boolean;
    /**
     * 
     * @type {ExpirationOffset}
     * @memberof CardLifeCycle
     */
    expirationOffset?: ExpirationOffset;
    /**
     * 
     * @type {number}
     * @memberof CardLifeCycle
     */
    cardServiceCode?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CardLifeCycle
     */
    updateExpirationUponActivation?: boolean;
}

/**
 * 
 * @export
 * @interface CardListResponse
 */
export interface CardListResponse {
    /**
     * 
     * @type {number}
     * @memberof CardListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof CardListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof CardListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CardListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<CardResponse>}
     * @memberof CardListResponse
     */
    data?: Array<CardResponse>;
}

/**
 * 
 * @export
 * @interface CardMetadata
 */
export interface CardMetadata {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CardMetadata
     */
    metadata?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface CardOptions
 */
export interface CardOptions {
    /**
     * 
     * @type {string}
     * @memberof CardOptions
     */
    cvv?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardOptions
     */
    cardPresent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardOptions
     */
    expiration?: string;
    /**
     * 
     * @type {BillingAddress}
     * @memberof CardOptions
     */
    billingAddress?: BillingAddress;
}

/**
 * 
 * @export
 * @interface CardPersonalization
 */
export interface CardPersonalization {
    /**
     * 
     * @type {Text}
     * @memberof CardPersonalization
     */
    text: Text;
    /**
     * 
     * @type {Images}
     * @memberof CardPersonalization
     */
    images?: Images;
    /**
     * 
     * @type {Carrier}
     * @memberof CardPersonalization
     */
    carrier?: Carrier;
    /**
     * 
     * @type {string}
     * @memberof CardPersonalization
     */
    persoType?: CardPersonalization.PersoTypeEnum;
}

/**
 * @export
 * @namespace CardPersonalization
 */
export namespace CardPersonalization {
    /**
     * @export
     * @enum {string}
     */
    export enum PersoTypeEnum {
        EMBOSS = <any> 'EMBOSS',
        LASER = <any> 'LASER',
        FLAT = <any> 'FLAT'
    }
}

/**
 * 
 * @export
 * @interface CardProductConfig
 */
export interface CardProductConfig {
    /**
     * 
     * @type {Poi}
     * @memberof CardProductConfig
     */
    poi?: Poi;
    /**
     * 
     * @type {TransactionControls}
     * @memberof CardProductConfig
     */
    transactionControls?: TransactionControls;
    /**
     * 
     * @type {SelectiveAuth}
     * @memberof CardProductConfig
     */
    selectiveAuth?: SelectiveAuth;
    /**
     * 
     * @type {Special}
     * @memberof CardProductConfig
     */
    special?: Special;
    /**
     * 
     * @type {CardLifeCycle}
     * @memberof CardProductConfig
     */
    cardLifeCycle?: CardLifeCycle;
    /**
     * 
     * @type {ClearingAndSettlement}
     * @memberof CardProductConfig
     */
    clearingAndSettlement?: ClearingAndSettlement;
    /**
     * 
     * @type {JitFunding}
     * @memberof CardProductConfig
     */
    jitFunding?: JitFunding;
    /**
     * 
     * @type {DigitalWalletTokenization}
     * @memberof CardProductConfig
     */
    digitalWalletTokenization?: DigitalWalletTokenization;
    /**
     * 
     * @type {CardProductFulfillment}
     * @memberof CardProductConfig
     */
    fulfillment?: CardProductFulfillment;
}

/**
 * 
 * @export
 * @interface CardProductFulfillment
 */
export interface CardProductFulfillment {
    /**
     * 
     * @type {Shipping}
     * @memberof CardProductFulfillment
     */
    shipping?: Shipping;
    /**
     * 
     * @type {CardPersonalization}
     * @memberof CardProductFulfillment
     */
    cardPersonalization: CardPersonalization;
    /**
     * 
     * @type {string}
     * @memberof CardProductFulfillment
     */
    paymentInstrument?: CardProductFulfillment.PaymentInstrumentEnum;
    /**
     * 
     * @type {string}
     * @memberof CardProductFulfillment
     */
    packageId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductFulfillment
     */
    allZeroCardSecurityCode?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardProductFulfillment
     */
    binPrefix?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductFulfillment
     */
    bulkShip?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardProductFulfillment
     */
    panLength?: string;
    /**
     * 
     * @type {string}
     * @memberof CardProductFulfillment
     */
    fulfillmentProvider?: CardProductFulfillment.FulfillmentProviderEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductFulfillment
     */
    allowCardCreation?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductFulfillment
     */
    uppercaseNameLines?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductFulfillment
     */
    enableOfflinePin?: boolean;
}

/**
 * @export
 * @namespace CardProductFulfillment
 */
export namespace CardProductFulfillment {
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentInstrumentEnum {
        PHYSICALMSR = <any> 'PHYSICAL_MSR',
        PHYSICALICC = <any> 'PHYSICAL_ICC',
        PHYSICALCONTACTLESS = <any> 'PHYSICAL_CONTACTLESS',
        PHYSICALCOMBO = <any> 'PHYSICAL_COMBO',
        VIRTUALPAN = <any> 'VIRTUAL_PAN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FulfillmentProviderEnum {
        PERFECTPLASTIC = <any> 'PERFECTPLASTIC',
        ARROWEYE = <any> 'ARROWEYE',
        IDEMIA = <any> 'IDEMIA',
        IDEMIAUK = <any> 'IDEMIA_UK',
        IDEMIAFR = <any> 'IDEMIA_FR',
        IDEMIACZ = <any> 'IDEMIA_CZ',
        IDEMIAAPAC = <any> 'IDEMIA_APAC',
        IDEMIAPL = <any> 'IDEMIA_PL',
        IDEMIAAU = <any> 'IDEMIA_AU',
        IDEMIALA = <any> 'IDEMIA_LA',
        GEMALTO = <any> 'GEMALTO',
        NITECREST = <any> 'NITECREST',
        OBERTHUR = <any> 'OBERTHUR',
        ALLPAY = <any> 'ALLPAY'
    }
}

/**
 * 
 * @export
 * @interface CardProductFulfillmentResponse
 */
export interface CardProductFulfillmentResponse {
    /**
     * 
     * @type {ShippingInformationResponse}
     * @memberof CardProductFulfillmentResponse
     */
    shipping?: ShippingInformationResponse;
    /**
     * 
     * @type {CardPersonalization}
     * @memberof CardProductFulfillmentResponse
     */
    cardPersonalization: CardPersonalization;
    /**
     * 
     * @type {string}
     * @memberof CardProductFulfillmentResponse
     */
    paymentInstrument?: CardProductFulfillmentResponse.PaymentInstrumentEnum;
    /**
     * 
     * @type {string}
     * @memberof CardProductFulfillmentResponse
     */
    packageId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductFulfillmentResponse
     */
    allZeroCardSecurityCode?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardProductFulfillmentResponse
     */
    binPrefix?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductFulfillmentResponse
     */
    bulkShip?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardProductFulfillmentResponse
     */
    panLength?: string;
    /**
     * 
     * @type {string}
     * @memberof CardProductFulfillmentResponse
     */
    fulfillmentProvider?: CardProductFulfillmentResponse.FulfillmentProviderEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductFulfillmentResponse
     */
    allowCardCreation?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductFulfillmentResponse
     */
    uppercaseNameLines?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductFulfillmentResponse
     */
    enableOfflinePin?: boolean;
}

/**
 * @export
 * @namespace CardProductFulfillmentResponse
 */
export namespace CardProductFulfillmentResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentInstrumentEnum {
        PHYSICALMSR = <any> 'PHYSICAL_MSR',
        PHYSICALICC = <any> 'PHYSICAL_ICC',
        PHYSICALCONTACTLESS = <any> 'PHYSICAL_CONTACTLESS',
        PHYSICALCOMBO = <any> 'PHYSICAL_COMBO',
        VIRTUALPAN = <any> 'VIRTUAL_PAN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FulfillmentProviderEnum {
        PERFECTPLASTIC = <any> 'PERFECTPLASTIC',
        ARROWEYE = <any> 'ARROWEYE',
        IDEMIA = <any> 'IDEMIA',
        IDEMIAUK = <any> 'IDEMIA_UK',
        IDEMIAFR = <any> 'IDEMIA_FR',
        IDEMIACZ = <any> 'IDEMIA_CZ',
        IDEMIAAPAC = <any> 'IDEMIA_APAC',
        IDEMIAPL = <any> 'IDEMIA_PL',
        IDEMIAAU = <any> 'IDEMIA_AU',
        IDEMIALA = <any> 'IDEMIA_LA',
        GEMALTO = <any> 'GEMALTO',
        NITECREST = <any> 'NITECREST',
        OBERTHUR = <any> 'OBERTHUR',
        ALLPAY = <any> 'ALLPAY'
    }
}

/**
 * 
 * @export
 * @interface CardProductListResponse
 */
export interface CardProductListResponse {
    /**
     * 
     * @type {number}
     * @memberof CardProductListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof CardProductListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof CardProductListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<CardProductResponse>}
     * @memberof CardProductListResponse
     */
    data?: Array<CardProductResponse>;
}

/**
 * 
 * @export
 * @interface CardProductRequest
 */
export interface CardProductRequest {
    /**
     * 
     * @type {string}
     * @memberof CardProductRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CardProductRequest
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductRequest
     */
    active?: boolean;
    /**
     * yyyy-MM-dd
     * @type {string}
     * @memberof CardProductRequest
     */
    startDate: string;
    /**
     * yyyy-MM-dd
     * @type {string}
     * @memberof CardProductRequest
     */
    endDate?: string;
    /**
     * 
     * @type {CardProductConfig}
     * @memberof CardProductRequest
     */
    config?: CardProductConfig;
}

/**
 * 
 * @export
 * @interface CardProductResponse
 */
export interface CardProductResponse {
    /**
     * 
     * @type {string}
     * @memberof CardProductResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CardProductResponse
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductResponse
     */
    active?: boolean;
    /**
     * yyyy-MM-dd
     * @type {string}
     * @memberof CardProductResponse
     */
    startDate: string;
    /**
     * yyyy-MM-dd
     * @type {string}
     * @memberof CardProductResponse
     */
    endDate?: string;
    /**
     * 
     * @type {CardProductConfig}
     * @memberof CardProductResponse
     */
    config?: CardProductConfig;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof CardProductResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof CardProductResponse
     */
    lastModifiedTime: Date;
}

/**
 * 
 * @export
 * @interface CardProductUpdateModel
 */
export interface CardProductUpdateModel {
    /**
     * 
     * @type {string}
     * @memberof CardProductUpdateModel
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardProductUpdateModel
     */
    active?: boolean;
    /**
     * yyyy-MM-dd
     * @type {string}
     * @memberof CardProductUpdateModel
     */
    startDate?: string;
    /**
     * yyyy-MM-dd
     * @type {string}
     * @memberof CardProductUpdateModel
     */
    endDate?: string;
    /**
     * 
     * @type {CardProductConfig}
     * @memberof CardProductUpdateModel
     */
    config?: CardProductConfig;
}

/**
 * 
 * @export
 * @interface CardReorderRequest
 */
export interface CardReorderRequest {
    /**
     * May only contain alphanumeric, hyphens, and underscore characters
     * @type {string}
     * @memberof CardReorderRequest
     */
    cardBatchLabel?: string;
}

/**
 * 
 * @export
 * @interface CardRequest
 */
export interface CardRequest {
    /**
     * 
     * @type {string}
     * @memberof CardRequest
     */
    cardProductToken: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardRequest
     */
    expedite?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CardRequest
     */
    metadata?: { [key: string]: string; };
    /**
     * 
     * @type {ExpirationOffset}
     * @memberof CardRequest
     */
    expirationOffset?: ExpirationOffset;
    /**
     * 
     * @type {string}
     * @memberof CardRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CardRequest
     */
    userToken: string;
    /**
     * 
     * @type {CardFulfillmentRequest}
     * @memberof CardRequest
     */
    fulfillment?: CardFulfillmentRequest;
    /**
     * 
     * @type {string}
     * @memberof CardRequest
     */
    reissuePanFromCardToken?: string;
    /**
     * 
     * @type {string}
     * @memberof CardRequest
     */
    newPanFromCardToken?: string;
    /**
     * 
     * @type {string}
     * @memberof CardRequest
     */
    translatePinFromCardToken?: string;
    /**
     * 
     * @type {ActivationActions}
     * @memberof CardRequest
     */
    activationActions?: ActivationActions;
    /**
     * 
     * @type {string}
     * @memberof CardRequest
     */
    bulkIssuanceToken?: string;
}

/**
 * 
 * @export
 * @interface CardResponse
 */
export interface CardResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof CardResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof CardResponse
     */
    lastModifiedTime: Date;
    /**
     * 36 char max
     * @type {string}
     * @memberof CardResponse
     */
    token: string;
    /**
     * 36 char max
     * @type {string}
     * @memberof CardResponse
     */
    userToken: string;
    /**
     * 36 char max
     * @type {string}
     * @memberof CardResponse
     */
    cardProductToken: string;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    lastFour: string;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    pan: string;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    expiration: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof CardResponse
     */
    expirationTime: Date;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    cvvNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    chipCvvNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    barcode: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardResponse
     */
    pinIsSet: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    state: CardResponse.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    stateReason: string;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    fulfillmentStatus: CardResponse.FulfillmentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    reissuePanFromCardToken?: string;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    newPanFromCardToken?: string;
    /**
     * 
     * @type {CardFulfillmentResponse}
     * @memberof CardResponse
     */
    fulfillment?: CardFulfillmentResponse;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    bulkIssuanceToken?: string;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    translatePinFromCardToken?: string;
    /**
     * 
     * @type {ActivationActions}
     * @memberof CardResponse
     */
    activationActions?: ActivationActions;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    instrumentType?: CardResponse.InstrumentTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CardResponse
     */
    expedite?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CardResponse
     */
    metadata?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    contactlessExemptionCounter?: number;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    contactlessExemptionTotalAmount?: number;
}

/**
 * @export
 * @namespace CardResponse
 */
export namespace CardResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        TERMINATED = <any> 'TERMINATED',
        UNSUPPORTED = <any> 'UNSUPPORTED',
        UNACTIVATED = <any> 'UNACTIVATED',
        LIMITED = <any> 'LIMITED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FulfillmentStatusEnum {
        ISSUED = <any> 'ISSUED',
        ORDERED = <any> 'ORDERED',
        REORDERED = <any> 'REORDERED',
        REJECTED = <any> 'REJECTED',
        SHIPPED = <any> 'SHIPPED',
        DELIVERED = <any> 'DELIVERED',
        DIGITALLYPRESENTED = <any> 'DIGITALLY_PRESENTED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum InstrumentTypeEnum {
        PHYSICALMSR = <any> 'PHYSICAL_MSR',
        PHYSICALICC = <any> 'PHYSICAL_ICC',
        PHYSICALCONTACTLESS = <any> 'PHYSICAL_CONTACTLESS',
        PHYSICALCOMBO = <any> 'PHYSICAL_COMBO',
        VIRTUALPAN = <any> 'VIRTUAL_PAN'
    }
}

/**
 * 
 * @export
 * @interface CardSecurityCodeVerification
 */
export interface CardSecurityCodeVerification {
    /**
     * 
     * @type {string}
     * @memberof CardSecurityCodeVerification
     */
    type: CardSecurityCodeVerification.TypeEnum;
    /**
     * 
     * @type {Response}
     * @memberof CardSecurityCodeVerification
     */
    response: Response;
}

/**
 * @export
 * @namespace CardSecurityCodeVerification
 */
export namespace CardSecurityCodeVerification {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CVV1 = <any> 'CVV1',
        CVV2 = <any> 'CVV2',
        ICVV = <any> 'ICVV',
        DCVV = <any> 'DCVV'
    }
}

/**
 * 
 * @export
 * @interface CardSwapHash
 */
export interface CardSwapHash {
    /**
     * 
     * @type {string}
     * @memberof CardSwapHash
     */
    previousCardToken: string;
    /**
     * 
     * @type {string}
     * @memberof CardSwapHash
     */
    newCardToken: string;
}

/**
 * 
 * @export
 * @interface CardTransitionListResponse
 */
export interface CardTransitionListResponse {
    /**
     * 
     * @type {number}
     * @memberof CardTransitionListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof CardTransitionListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof CardTransitionListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CardTransitionListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<CardTransitionResponse>}
     * @memberof CardTransitionListResponse
     */
    data?: Array<CardTransitionResponse>;
}

/**
 * 
 * @export
 * @interface CardTransitionRequest
 */
export interface CardTransitionRequest {
    /**
     * 
     * @type {string}
     * @memberof CardTransitionRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionRequest
     */
    cardToken: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionRequest
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionRequest
     */
    reasonCode?: CardTransitionRequest.ReasonCodeEnum;
    /**
     * 
     * @type {ValidationsRequest}
     * @memberof CardTransitionRequest
     */
    validations?: ValidationsRequest;
    /**
     * 
     * @type {boolean}
     * @memberof CardTransitionRequest
     */
    syncStateWithDwts?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionRequest
     */
    channel: CardTransitionRequest.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionRequest
     */
    state: CardTransitionRequest.StateEnum;
}

/**
 * @export
 * @namespace CardTransitionRequest
 */
export namespace CardTransitionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonCodeEnum {
        _00 = <any> '00',
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _06 = <any> '06',
        _07 = <any> '07',
        _08 = <any> '08',
        _09 = <any> '09',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _13 = <any> '13',
        _14 = <any> '14',
        _15 = <any> '15',
        _16 = <any> '16',
        _17 = <any> '17',
        _18 = <any> '18',
        _19 = <any> '19',
        _20 = <any> '20',
        _21 = <any> '21',
        _22 = <any> '22',
        _23 = <any> '23',
        _24 = <any> '24',
        _25 = <any> '25',
        _26 = <any> '26',
        _27 = <any> '27',
        _28 = <any> '28',
        _29 = <any> '29',
        _30 = <any> '30',
        _31 = <any> '31'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        IVR = <any> 'IVR',
        FRAUD = <any> 'FRAUD',
        ADMIN = <any> 'ADMIN',
        SYSTEM = <any> 'SYSTEM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        TERMINATED = <any> 'TERMINATED'
    }
}

/**
 * 
 * @export
 * @interface CardTransitionResponse
 */
export interface CardTransitionResponse {
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    cardToken: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    userToken: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    state: CardTransitionResponse.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    reasonCode?: CardTransitionResponse.ReasonCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    channel: CardTransitionResponse.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    fulfillmentStatus: CardTransitionResponse.FulfillmentStatusEnum;
    /**
     * 
     * @type {ValidationsResponse}
     * @memberof CardTransitionResponse
     */
    validations?: ValidationsResponse;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    type: CardTransitionResponse.TypeEnum;
    /**
     * 
     * @type {Date}
     * @memberof CardTransitionResponse
     */
    createdTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    cardProductToken: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    lastFour: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    pan: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    expiration: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    expirationTime: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    barcode: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardTransitionResponse
     */
    pinIsSet: boolean;
    /**
     * 
     * @type {CardFulfillmentRequest}
     * @memberof CardTransitionResponse
     */
    fulfillment?: CardFulfillmentRequest;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    bulkIssuanceToken?: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    reissuePanFromCardToken?: string;
    /**
     * 
     * @type {string}
     * @memberof CardTransitionResponse
     */
    newPanFromCardToken?: string;
    /**
     * 
     * @type {CardholderMetadata}
     * @memberof CardTransitionResponse
     */
    user?: CardholderMetadata;
    /**
     * 
     * @type {CardMetadata}
     * @memberof CardTransitionResponse
     */
    card?: CardMetadata;
    /**
     * 
     * @type {boolean}
     * @memberof CardTransitionResponse
     */
    expedite?: boolean;
}

/**
 * @export
 * @namespace CardTransitionResponse
 */
export namespace CardTransitionResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        TERMINATED = <any> 'TERMINATED',
        UNACTIVATED = <any> 'UNACTIVATED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonCodeEnum {
        _00 = <any> '00',
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _06 = <any> '06',
        _07 = <any> '07',
        _08 = <any> '08',
        _09 = <any> '09',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _13 = <any> '13',
        _14 = <any> '14',
        _15 = <any> '15',
        _16 = <any> '16',
        _17 = <any> '17',
        _18 = <any> '18',
        _19 = <any> '19',
        _20 = <any> '20',
        _21 = <any> '21',
        _22 = <any> '22',
        _23 = <any> '23',
        _24 = <any> '24',
        _25 = <any> '25',
        _26 = <any> '26',
        _27 = <any> '27',
        _28 = <any> '28',
        _29 = <any> '29',
        _30 = <any> '30',
        _31 = <any> '31'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        IVR = <any> 'IVR',
        FRAUD = <any> 'FRAUD',
        ADMIN = <any> 'ADMIN',
        SYSTEM = <any> 'SYSTEM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FulfillmentStatusEnum {
        ISSUED = <any> 'ISSUED',
        ORDERED = <any> 'ORDERED',
        REJECTED = <any> 'REJECTED',
        SHIPPED = <any> 'SHIPPED',
        DELIVERED = <any> 'DELIVERED',
        DIGITALLYPRESENTED = <any> 'DIGITALLY_PRESENTED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        FulfillmentIssued = <any> 'fulfillment.issued',
        StateActivated = <any> 'state.activated',
        StateSuspended = <any> 'state.suspended',
        StateReinstated = <any> 'state.reinstated',
        StateTerminated = <any> 'state.terminated',
        StateLimited = <any> 'state.limited',
        FulfillmentOrdered = <any> 'fulfillment.ordered',
        FulfillmentRejected = <any> 'fulfillment.rejected',
        FulfillmentShipped = <any> 'fulfillment.shipped',
        FulfillmentDelivered = <any> 'fulfillment.delivered',
        FulfillmentDigitallyPresented = <any> 'fulfillment.digitally_presented'
    }
}

/**
 * 
 * @export
 * @interface CardUpdateRequest
 */
export interface CardUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CardUpdateRequest
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof CardUpdateRequest
     */
    userToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardUpdateRequest
     */
    expedite?: boolean;
    /**
     * 
     * @type {CardFulfillmentRequest}
     * @memberof CardUpdateRequest
     */
    fulfillment?: CardFulfillmentRequest;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CardUpdateRequest
     */
    metadata?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface CardValidationRequest
 */
export interface CardValidationRequest {
    /**
     * 
     * @type {string}
     * @memberof CardValidationRequest
     */
    hash: string;
    /**
     * 
     * @type {string}
     * @memberof CardValidationRequest
     */
    expirationDate?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CardValidationRequest
     */
    config?: { [key: string]: string; };
    /**
     * 
     * @type {InternalDigitalWalletToken}
     * @memberof CardValidationRequest
     */
    digitalWallet?: InternalDigitalWalletToken;
    /**
     * 
     * @type {InternalTransactionDataModel}
     * @memberof CardValidationRequest
     */
    transaction?: InternalTransactionDataModel;
}

/**
 * 
 * @export
 * @interface CardValidationResponse
 */
export interface CardValidationResponse {
    /**
     * 
     * @type {InternalCard}
     * @memberof CardValidationResponse
     */
    card?: InternalCard;
    /**
     * 
     * @type {Response}
     * @memberof CardValidationResponse
     */
    response?: Response;
}

/**
 * 
 * @export
 * @interface CardholderAddressListResponse
 */
export interface CardholderAddressListResponse {
    /**
     * 
     * @type {number}
     * @memberof CardholderAddressListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof CardholderAddressListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof CardholderAddressListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CardholderAddressListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<CardholderAddressResponse>}
     * @memberof CardholderAddressListResponse
     */
    data?: Array<CardholderAddressResponse>;
}

/**
 * 
 * @export
 * @interface CardholderAddressResponse
 */
export interface CardholderAddressResponse {
    /**
     * Required if 'business_token' is not specified
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    userToken?: string;
    /**
     * Required if 'user_token' is not specified
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    address1: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    zip: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    postalCode: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    country: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAddressResponse
     */
    phone?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardholderAddressResponse
     */
    isDefaultAddress?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CardholderAddressResponse
     */
    active?: boolean;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof CardholderAddressResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof CardholderAddressResponse
     */
    lastModifiedTime: Date;
}

/**
 * 
 * @export
 * @interface CardholderAuthenticationData
 */
export interface CardholderAuthenticationData {
    /**
     * 
     * @type {string}
     * @memberof CardholderAuthenticationData
     */
    electronicCommerceIndicator?: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAuthenticationData
     */
    verificationResult?: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAuthenticationData
     */
    verificationValueCreatedBy?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CardholderAuthenticationData
     */
    acquirerExemption?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CardholderAuthenticationData
     */
    threeDsMessageVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAuthenticationData
     */
    authenticationMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAuthenticationData
     */
    authenticationStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderAuthenticationData
     */
    issuerExemption?: string;
}

/**
 * 
 * @export
 * @interface CardholderBalance
 */
export interface CardholderBalance {
    /**
     * 
     * @type {string}
     * @memberof CardholderBalance
     */
    currencyCode: string;
    /**
     * 
     * @type {number}
     * @memberof CardholderBalance
     */
    ledgerBalance: number;
    /**
     * 
     * @type {number}
     * @memberof CardholderBalance
     */
    availableBalance: number;
    /**
     * 
     * @type {number}
     * @memberof CardholderBalance
     */
    creditBalance: number;
    /**
     * 
     * @type {number}
     * @memberof CardholderBalance
     */
    cachedBalance: number;
    /**
     * 
     * @type {number}
     * @memberof CardholderBalance
     */
    pendingCredits: number;
    /**
     * 
     * @type {number}
     * @memberof CardholderBalance
     */
    impactedAmount?: number;
    /**
     * 
     * @type {{ [key: string]: CardholderBalance; }}
     * @memberof CardholderBalance
     */
    balances: { [key: string]: CardholderBalance; };
    /**
     * 
     * @type {Date}
     * @memberof CardholderBalance
     */
    lastUpdatedTime: Date;
}

/**
 * 
 * @export
 * @interface CardholderBalances
 */
export interface CardholderBalances {
    /**
     * 
     * @type {CardholderBalance}
     * @memberof CardholderBalances
     */
    gpa: CardholderBalance;
    /**
     * 
     * @type {Array<Link>}
     * @memberof CardholderBalances
     */
    links: Array<Link>;
}

/**
 * 
 * @export
 * @interface CardholderMetadata
 */
export interface CardholderMetadata {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CardholderMetadata
     */
    metadata?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface CardholderMsaBalance
 */
export interface CardholderMsaBalance {
    /**
     * 
     * @type {string}
     * @memberof CardholderMsaBalance
     */
    currencyCode: string;
    /**
     * 
     * @type {number}
     * @memberof CardholderMsaBalance
     */
    ledgerBalance: number;
    /**
     * 
     * @type {number}
     * @memberof CardholderMsaBalance
     */
    availableBalance: number;
    /**
     * 
     * @type {number}
     * @memberof CardholderMsaBalance
     */
    creditBalance: number;
    /**
     * 
     * @type {number}
     * @memberof CardholderMsaBalance
     */
    cachedBalance: number;
    /**
     * 
     * @type {number}
     * @memberof CardholderMsaBalance
     */
    pendingCredits: number;
    /**
     * 
     * @type {number}
     * @memberof CardholderMsaBalance
     */
    impactedAmount?: number;
    /**
     * 
     * @type {{ [key: string]: CardholderBalance; }}
     * @memberof CardholderMsaBalance
     */
    balances: { [key: string]: CardholderBalance; };
    /**
     * 
     * @type {string}
     * @memberof CardholderMsaBalance
     */
    name: string;
    /**
     * 
     * @type {Date}
     * @memberof CardholderMsaBalance
     */
    lastUpdatedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof CardholderMsaBalance
     */
    campaignToken?: string;
}

/**
 * 
 * @export
 * @interface CardholderNoteRequestModel
 */
export interface CardholderNoteRequestModel {
    /**
     * 
     * @type {string}
     * @memberof CardholderNoteRequestModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderNoteRequestModel
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderNoteRequestModel
     */
    createdBy: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderNoteRequestModel
     */
    createdByUserRole?: CardholderNoteRequestModel.CreatedByUserRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CardholderNoteRequestModel
     */
    _private?: boolean;
}

/**
 * @export
 * @namespace CardholderNoteRequestModel
 */
export namespace CardholderNoteRequestModel {
    /**
     * @export
     * @enum {string}
     */
    export enum CreatedByUserRoleEnum {
        USER = <any> 'USER',
        ADMIN = <any> 'ADMIN',
        BANKUSER = <any> 'BANK_USER',
        BANKADMIN = <any> 'BANK_ADMIN',
        MARQETAPD = <any> 'MARQETA_PD',
        MARQETAADMIN = <any> 'MARQETA_ADMIN'
    }
}

/**
 * 
 * @export
 * @interface CardholderNoteResponseModel
 */
export interface CardholderNoteResponseModel {
    /**
     * 
     * @type {string}
     * @memberof CardholderNoteResponseModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderNoteResponseModel
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderNoteResponseModel
     */
    createdBy: string;
    /**
     * 
     * @type {string}
     * @memberof CardholderNoteResponseModel
     */
    createdByUserRole?: CardholderNoteResponseModel.CreatedByUserRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CardholderNoteResponseModel
     */
    _private?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof CardholderNoteResponseModel
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CardholderNoteResponseModel
     */
    lastModifiedTime?: Date;
}

/**
 * @export
 * @namespace CardholderNoteResponseModel
 */
export namespace CardholderNoteResponseModel {
    /**
     * @export
     * @enum {string}
     */
    export enum CreatedByUserRoleEnum {
        USER = <any> 'USER',
        ADMIN = <any> 'ADMIN',
        BANKUSER = <any> 'BANK_USER',
        BANKADMIN = <any> 'BANK_ADMIN',
        MARQETAPD = <any> 'MARQETA_PD',
        MARQETAADMIN = <any> 'MARQETA_ADMIN'
    }
}

/**
 * 
 * @export
 * @interface CardholderNoteUpdateRequestModel
 */
export interface CardholderNoteUpdateRequestModel {
    /**
     * 
     * @type {string}
     * @memberof CardholderNoteUpdateRequestModel
     */
    description: string;
}

/**
 * 
 * @export
 * @interface Carrier
 */
export interface Carrier {
    /**
     * 
     * @type {string}
     * @memberof Carrier
     */
    templateId?: string;
    /**
     * 
     * @type {string}
     * @memberof Carrier
     */
    logoFile?: string;
    /**
     * 
     * @type {string}
     * @memberof Carrier
     */
    logoThumbnailFile?: string;
    /**
     * 
     * @type {string}
     * @memberof Carrier
     */
    messageFile?: string;
    /**
     * 
     * @type {string}
     * @memberof Carrier
     */
    messageLine?: string;
}

/**
 * 
 * @export
 * @interface ChargebackAllocationAckRequest
 */
export interface ChargebackAllocationAckRequest {
    /**
     * 
     * @type {string}
     * @memberof ChargebackAllocationAckRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackAllocationAckRequest
     */
    chargebackToken: string;
}

/**
 * 
 * @export
 * @interface ChargebackFundingSourceModel
 */
export interface ChargebackFundingSourceModel extends FundingSourceModel {
    /**
     * 
     * @type {string}
     * @memberof ChargebackFundingSourceModel
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChargebackFundingSourceModel
     */
    credit: boolean;
}

/**
 * 
 * @export
 * @interface ChargebackListResponse
 */
export interface ChargebackListResponse {
    /**
     * 
     * @type {number}
     * @memberof ChargebackListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof ChargebackListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof ChargebackListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ChargebackListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<ChargebackResponse>}
     * @memberof ChargebackListResponse
     */
    data?: Array<ChargebackResponse>;
}

/**
 * 
 * @export
 * @interface ChargebackRequest
 */
export interface ChargebackRequest {
    /**
     * Either 'reason_description' or 'reason_code' is required
     * @type {string}
     * @memberof ChargebackRequest
     */
    reasonDescription?: ChargebackRequest.ReasonDescriptionEnum;
    /**
     * Either 'reason_code' or 'reason_description' is required
     * @type {string}
     * @memberof ChargebackRequest
     */
    reasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackRequest
     */
    status?: ChargebackRequest.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ChargebackRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackRequest
     */
    transactionToken: string;
    /**
     * 
     * @type {number}
     * @memberof ChargebackRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ChargebackRequest
     */
    memo?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChargebackRequest
     */
    creditUser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChargebackRequest
     */
    channel: ChargebackRequest.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof ChargebackRequest
     */
    regulationType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChargebackRequest
     */
    preInitiated?: boolean;
}

/**
 * @export
 * @namespace ChargebackRequest
 */
export namespace ChargebackRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonDescriptionEnum {
        SERVICENOTPROVIDEDMERCHANDISENOTRECEIVED = <any> 'SERVICE_NOT_PROVIDED_MERCHANDISE_NOT_RECEIVED',
        CANCELLEDRECURRINGTRANSACTION = <any> 'CANCELLED_RECURRING_TRANSACTION',
        NOTASDESCRIBEDORDEFECTIVEMERCHANDISE = <any> 'NOT_AS_DESCRIBED_OR_DEFECTIVE_MERCHANDISE',
        FRAUDMULTIPLETRANSACTIONS = <any> 'FRAUD_MULTIPLE_TRANSACTIONS',
        FRAUDTRANSACTION = <any> 'FRAUD_TRANSACTION',
        NOAUTHORIZATION = <any> 'NO_AUTHORIZATION',
        LATEPRESENTMENT = <any> 'LATE_PRESENTMENT',
        TRANSACTIONNOTRECOGNIZED = <any> 'TRANSACTION_NOT_RECOGNIZED',
        INCORRECTCURRENCY = <any> 'INCORRECT_CURRENCY',
        INCORRECTTRANSACTIONCODE = <any> 'INCORRECT_TRANSACTION_CODE',
        INCORRECTCURRENCYORTRANSACTIONCODE = <any> 'INCORRECT_CURRENCY_OR_TRANSACTION_CODE',
        INCORRECTTRANSACTIONAMOUNT = <any> 'INCORRECT_TRANSACTION_AMOUNT',
        INCORRECTACCOUNTNUMBER = <any> 'INCORRECT_ACCOUNT_NUMBER',
        INCORRECTTRANSACTIONAMOUNTORACCOUNTNUMBER = <any> 'INCORRECT_TRANSACTION_AMOUNT_OR_ACCOUNT_NUMBER',
        NOTAUTHORIZEDCARDPRESENT = <any> 'NOT_AUTHORIZED_CARD_PRESENT',
        NOTAUTHORIZEDCARDABSENT = <any> 'NOT_AUTHORIZED_CARD_ABSENT',
        CREDITNOTPROCESSED = <any> 'CREDIT_NOT_PROCESSED',
        NONRECEIPTOFCASHORLOADTRANSACTIONVALUEATATM = <any> 'NON_RECEIPT_OF_CASH_OR_LOAD_TRANSACTION_VALUE_AT_ATM',
        DUPLICATEPROCESSINGORPAIDBYOTHERMEANS = <any> 'DUPLICATE_PROCESSING_OR_PAID_BY_OTHER_MEANS'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ARBITRATION = <any> 'ARBITRATION',
        CASELOST = <any> 'CASE_LOST',
        CASEWON = <any> 'CASE_WON',
        INITIATED = <any> 'INITIATED',
        NETWORKREJECTED = <any> 'NETWORK_REJECTED',
        PREARBITRATION = <any> 'PREARBITRATION',
        PREINITIATED = <any> 'PRE_INITIATED',
        REPRESENTMENT = <any> 'REPRESENTMENT',
        WITHDRAWN = <any> 'WITHDRAWN',
        WRITTENOFFISSUER = <any> 'WRITTEN_OFF_ISSUER',
        WRITTENOFFPROGRAM = <any> 'WRITTEN_OFF_PROGRAM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        GATEWAY = <any> 'GATEWAY',
        GATEWAYAUTOMATED = <any> 'GATEWAY_AUTOMATED',
        ISSUER = <any> 'ISSUER',
        ISSUERAUTOMATED = <any> 'ISSUER_AUTOMATED'
    }
}

/**
 * 
 * @export
 * @interface ChargebackResponse
 */
export interface ChargebackResponse {
    /**
     * 
     * @type {string}
     * @memberof ChargebackResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackResponse
     */
    transactionToken: string;
    /**
     * 
     * @type {number}
     * @memberof ChargebackResponse
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ChargebackResponse
     */
    reasonDescription?: ChargebackResponse.ReasonDescriptionEnum;
    /**
     * 
     * @type {string}
     * @memberof ChargebackResponse
     */
    reasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackResponse
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackResponse
     */
    state: ChargebackResponse.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof ChargebackResponse
     */
    channel: ChargebackResponse.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof ChargebackResponse
     */
    network: ChargebackResponse.NetworkEnum;
    /**
     * 
     * @type {string}
     * @memberof ChargebackResponse
     */
    networkCaseId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChargebackResponse
     */
    creditUser: boolean;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof ChargebackResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof ChargebackResponse
     */
    lastModifiedTime: Date;
}

/**
 * @export
 * @namespace ChargebackResponse
 */
export namespace ChargebackResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonDescriptionEnum {
        SERVICENOTPROVIDEDMERCHANDISENOTRECEIVED = <any> 'SERVICE_NOT_PROVIDED_MERCHANDISE_NOT_RECEIVED',
        CANCELLEDRECURRINGTRANSACTION = <any> 'CANCELLED_RECURRING_TRANSACTION',
        NOTASDESCRIBEDORDEFECTIVEMERCHANDISE = <any> 'NOT_AS_DESCRIBED_OR_DEFECTIVE_MERCHANDISE',
        FRAUDMULTIPLETRANSACTIONS = <any> 'FRAUD_MULTIPLE_TRANSACTIONS',
        FRAUDTRANSACTION = <any> 'FRAUD_TRANSACTION',
        NOAUTHORIZATION = <any> 'NO_AUTHORIZATION',
        LATEPRESENTMENT = <any> 'LATE_PRESENTMENT',
        TRANSACTIONNOTRECOGNIZED = <any> 'TRANSACTION_NOT_RECOGNIZED',
        INCORRECTCURRENCYORTRANSACTIONCODE = <any> 'INCORRECT_CURRENCY_OR_TRANSACTION_CODE',
        INCORRECTTRANSACTIONAMOUNTORACCOUNTNUMBER = <any> 'INCORRECT_TRANSACTION_AMOUNT_OR_ACCOUNT_NUMBER',
        NOTAUTHORIZEDCARDPRESENT = <any> 'NOT_AUTHORIZED_CARD_PRESENT',
        NOTAUTHORIZEDCARDABSENT = <any> 'NOT_AUTHORIZED_CARD_ABSENT',
        CREDITNOTPROCESSED = <any> 'CREDIT_NOT_PROCESSED',
        NONRECEIPTOFCASHORLOADTRANSACTIONVALUEATATM = <any> 'NON_RECEIPT_OF_CASH_OR_LOAD_TRANSACTION_VALUE_AT_ATM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIATED = <any> 'INITIATED',
        REPRESENTMENT = <any> 'REPRESENTMENT',
        PREARBITRATION = <any> 'PREARBITRATION',
        ARBITRATION = <any> 'ARBITRATION',
        CASEWON = <any> 'CASE_WON',
        CASELOST = <any> 'CASE_LOST',
        NETWORKREJECTED = <any> 'NETWORK_REJECTED',
        WITHDRAWN = <any> 'WITHDRAWN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        GATEWAY = <any> 'GATEWAY',
        GATEWAYAUTOMATED = <any> 'GATEWAY_AUTOMATED',
        ISSUER = <any> 'ISSUER',
        ISSUERAUTOMATED = <any> 'ISSUER_AUTOMATED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NetworkEnum {
        MARQETA = <any> 'MARQETA',
        DISCOVER = <any> 'DISCOVER',
        MASTERCARD = <any> 'MASTERCARD',
        PULSE = <any> 'PULSE',
        VISA = <any> 'VISA'
    }
}

/**
 * 
 * @export
 * @interface ChargebackTransitionListResponse
 */
export interface ChargebackTransitionListResponse {
    /**
     * 
     * @type {number}
     * @memberof ChargebackTransitionListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof ChargebackTransitionListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof ChargebackTransitionListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ChargebackTransitionListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<ChargebackTransitionResponse>}
     * @memberof ChargebackTransitionListResponse
     */
    data?: Array<ChargebackTransitionResponse>;
}

/**
 * 
 * @export
 * @interface ChargebackTransitionRequest
 */
export interface ChargebackTransitionRequest {
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionRequest
     */
    state: ChargebackTransitionRequest.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionRequest
     */
    chargebackToken: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionRequest
     */
    reason?: string;
    /**
     * Representment or prearbitration amount; this is for transitioning to Representment or Prearbitration only
     * @type {number}
     * @memberof ChargebackTransitionRequest
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionRequest
     */
    regulationType?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionRequest
     */
    type?: string;
}

/**
 * @export
 * @namespace ChargebackTransitionRequest
 */
export namespace ChargebackTransitionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        REPRESENTMENT = <any> 'REPRESENTMENT',
        PREARBITRATION = <any> 'PREARBITRATION',
        PREARBRESPONDED = <any> 'PREARB_RESPONDED',
        ARBITRATION = <any> 'ARBITRATION',
        CASEWON = <any> 'CASE_WON',
        CASELOST = <any> 'CASE_LOST',
        WRITTENOFFISSUER = <any> 'WRITTEN_OFF_ISSUER',
        WRITTENOFFPROGRAM = <any> 'WRITTEN_OFF_PROGRAM'
    }
}

/**
 * 
 * @export
 * @interface ChargebackTransitionResponse
 */
export interface ChargebackTransitionResponse {
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionResponse
     */
    state: ChargebackTransitionResponse.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionResponse
     */
    previousState: ChargebackTransitionResponse.PreviousStateEnum;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionResponse
     */
    channel: ChargebackTransitionResponse.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionResponse
     */
    chargebackToken: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionResponse
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionResponse
     */
    transactionToken?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof ChargebackTransitionResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof ChargebackTransitionResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof ChargebackTransitionResponse
     */
    type: ChargebackTransitionResponse.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ChargebackTransitionResponse
     */
    amount?: number;
}

/**
 * @export
 * @namespace ChargebackTransitionResponse
 */
export namespace ChargebackTransitionResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        INITIATED = <any> 'INITIATED',
        REPRESENTMENT = <any> 'REPRESENTMENT',
        PREARBITRATION = <any> 'PREARBITRATION',
        ARBITRATION = <any> 'ARBITRATION',
        CASEWON = <any> 'CASE_WON',
        CASELOST = <any> 'CASE_LOST',
        NETWORKREJECTED = <any> 'NETWORK_REJECTED',
        WITHDRAWN = <any> 'WITHDRAWN',
        WRITTENOFFISSUER = <any> 'WRITTEN_OFF_ISSUER',
        WRITTENOFFPROGRAM = <any> 'WRITTEN_OFF_PROGRAM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PreviousStateEnum {
        INITIATED = <any> 'INITIATED',
        REPRESENTMENT = <any> 'REPRESENTMENT',
        PREARBITRATION = <any> 'PREARBITRATION',
        ARBITRATION = <any> 'ARBITRATION',
        CASEWON = <any> 'CASE_WON',
        CASELOST = <any> 'CASE_LOST',
        NETWORKREJECTED = <any> 'NETWORK_REJECTED',
        WITHDRAWN = <any> 'WITHDRAWN'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        GATEWAY = <any> 'GATEWAY',
        GATEWAYAUTOMATED = <any> 'GATEWAY_AUTOMATED',
        ISSUER = <any> 'ISSUER',
        ISSUERAUTOMATED = <any> 'ISSUER_AUTOMATED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Initiated = <any> 'initiated',
        Representment = <any> 'representment',
        Prearbitration = <any> 'prearbitration',
        Arbitration = <any> 'arbitration',
        CaseWon = <any> 'case.won',
        CaseLost = <any> 'case.lost',
        NetworkRejected = <any> 'network.rejected',
        WrittenOffIssuer = <any> 'written.off.issuer',
        WrittenOffProgram = <any> 'written.off.program'
    }
}

/**
 * 
 * @export
 * @interface ChargebackUpdateRequest
 */
export interface ChargebackUpdateRequest {
    /**
     * Either 'reason_description' or 'reason_code' is required
     * @type {string}
     * @memberof ChargebackUpdateRequest
     */
    reasonDescription?: ChargebackUpdateRequest.ReasonDescriptionEnum;
    /**
     * Either 'reason_code' or 'reason_description' is required
     * @type {string}
     * @memberof ChargebackUpdateRequest
     */
    reasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ChargebackUpdateRequest
     */
    status?: ChargebackUpdateRequest.StatusEnum;
}

/**
 * @export
 * @namespace ChargebackUpdateRequest
 */
export namespace ChargebackUpdateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonDescriptionEnum {
        SERVICENOTPROVIDEDMERCHANDISENOTRECEIVED = <any> 'SERVICE_NOT_PROVIDED_MERCHANDISE_NOT_RECEIVED',
        CANCELLEDRECURRINGTRANSACTION = <any> 'CANCELLED_RECURRING_TRANSACTION',
        NOTASDESCRIBEDORDEFECTIVEMERCHANDISE = <any> 'NOT_AS_DESCRIBED_OR_DEFECTIVE_MERCHANDISE',
        FRAUDMULTIPLETRANSACTIONS = <any> 'FRAUD_MULTIPLE_TRANSACTIONS',
        FRAUDTRANSACTION = <any> 'FRAUD_TRANSACTION',
        NOAUTHORIZATION = <any> 'NO_AUTHORIZATION',
        LATEPRESENTMENT = <any> 'LATE_PRESENTMENT',
        TRANSACTIONNOTRECOGNIZED = <any> 'TRANSACTION_NOT_RECOGNIZED',
        INCORRECTCURRENCY = <any> 'INCORRECT_CURRENCY',
        INCORRECTTRANSACTIONCODE = <any> 'INCORRECT_TRANSACTION_CODE',
        INCORRECTCURRENCYORTRANSACTIONCODE = <any> 'INCORRECT_CURRENCY_OR_TRANSACTION_CODE',
        INCORRECTTRANSACTIONAMOUNT = <any> 'INCORRECT_TRANSACTION_AMOUNT',
        INCORRECTACCOUNTNUMBER = <any> 'INCORRECT_ACCOUNT_NUMBER',
        INCORRECTTRANSACTIONAMOUNTORACCOUNTNUMBER = <any> 'INCORRECT_TRANSACTION_AMOUNT_OR_ACCOUNT_NUMBER',
        NOTAUTHORIZEDCARDPRESENT = <any> 'NOT_AUTHORIZED_CARD_PRESENT',
        NOTAUTHORIZEDCARDABSENT = <any> 'NOT_AUTHORIZED_CARD_ABSENT',
        CREDITNOTPROCESSED = <any> 'CREDIT_NOT_PROCESSED',
        NONRECEIPTOFCASHORLOADTRANSACTIONVALUEATATM = <any> 'NON_RECEIPT_OF_CASH_OR_LOAD_TRANSACTION_VALUE_AT_ATM',
        DUPLICATEPROCESSINGORPAIDBYOTHERMEANS = <any> 'DUPLICATE_PROCESSING_OR_PAID_BY_OTHER_MEANS'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        ARBITRATION = <any> 'ARBITRATION',
        CASELOST = <any> 'CASE_LOST',
        CASEWON = <any> 'CASE_WON',
        INITIATED = <any> 'INITIATED',
        NETWORKREJECTED = <any> 'NETWORK_REJECTED',
        PREARBITRATION = <any> 'PREARBITRATION',
        PREINITIATED = <any> 'PRE_INITIATED',
        REPRESENTMENT = <any> 'REPRESENTMENT',
        WITHDRAWN = <any> 'WITHDRAWN',
        WRITTENOFFISSUER = <any> 'WRITTEN_OFF_ISSUER',
        WRITTENOFFPROGRAM = <any> 'WRITTEN_OFF_PROGRAM'
    }
}

/**
 * 
 * @export
 * @interface ClearingAndSettlement
 */
export interface ClearingAndSettlement {
    /**
     * Default value of GPA does not apply when JIT funding is enabled
     * @type {string}
     * @memberof ClearingAndSettlement
     */
    overdraftDestination?: ClearingAndSettlement.OverdraftDestinationEnum;
}

/**
 * @export
 * @namespace ClearingAndSettlement
 */
export namespace ClearingAndSettlement {
    /**
     * @export
     * @enum {string}
     */
    export enum OverdraftDestinationEnum {
        GPA = <any> 'GPA',
        MSA = <any> 'MSA',
        MERCHANTCAMPAIGNACCOUNT = <any> 'MERCHANT_CAMPAIGN_ACCOUNT',
        GLOBALOVERDRAFTACCOUNT = <any> 'GLOBAL_OVERDRAFT_ACCOUNT'
    }
}

/**
 * 
 * @export
 * @interface ClearingFile
 */
export interface ClearingFile {
    /**
     * 
     * @type {string}
     * @memberof ClearingFile
     */
    network?: ClearingFile.NetworkEnum;
    /**
     * 
     * @type {string}
     * @memberof ClearingFile
     */
    file?: string;
}

/**
 * @export
 * @namespace ClearingFile
 */
export namespace ClearingFile {
    /**
     * @export
     * @enum {string}
     */
    export enum NetworkEnum {
        MARQETA = <any> 'MARQETA',
        DISCOVER = <any> 'DISCOVER',
        MASTERCARD = <any> 'MASTERCARD',
        PULSE = <any> 'PULSE',
        VISA = <any> 'VISA'
    }
}

/**
 * 
 * @export
 * @interface ClearingFileRequest
 */
export interface ClearingFileRequest {
    /**
     * A list of 'clearing_transaction_request' items
     * @type {Array<AdvancedClearingRequestModel>}
     * @memberof ClearingFileRequest
     */
    transactionTokens: Array<AdvancedClearingRequestModel>;
    /**
     * Timeout in seconds
     * @type {number}
     * @memberof ClearingFileRequest
     */
    waitTimeout?: number;
    /**
     * A string representing batch ID
     * @type {string}
     * @memberof ClearingFileRequest
     */
    batchId?: string;
    /**
     * 
     * @type {string}
     * @memberof ClearingFileRequest
     */
    clearingFolder?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClearingFileRequest
     */
    encryptFile?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClearingFileRequest
     */
    createCompletionFile?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClearingFileRequest
     */
    settlementDate?: string;
    /**
     * 
     * @type {string}
     * @memberof ClearingFileRequest
     */
    tokenPan?: string;
}

/**
 * 
 * @export
 * @interface ClearingFileResponse
 */
export interface ClearingFileResponse {
    /**
     * 
     * @type {Array<ClearingFile>}
     * @memberof ClearingFileResponse
     */
    clearingFiles?: Array<ClearingFile>;
}

/**
 * 
 * @export
 * @interface ClearingModel
 */
export interface ClearingModel {
    /**
     * 
     * @type {Array<NetworkFeeModel>}
     * @memberof ClearingModel
     */
    networkFees?: Array<NetworkFeeModel>;
    /**
     * 
     * @type {Webhook}
     * @memberof ClearingModel
     */
    webhook?: Webhook;
    /**
     * 
     * @type {boolean}
     * @memberof ClearingModel
     */
    isRefund?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClearingModel
     */
    forcePost?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClearingModel
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ClearingModel
     */
    originalTransactionToken: string;
    /**
     * 
     * @type {string}
     * @memberof ClearingModel
     */
    mid?: string;
    /**
     * 
     * @type {CardAcceptorModel}
     * @memberof ClearingModel
     */
    cardAcceptor?: CardAcceptorModel;
}

/**
 * 
 * @export
 * @interface ClearingRetryModel
 */
export interface ClearingRetryModel {
    /**
     * 
     * @type {string}
     * @memberof ClearingRetryModel
     */
    originalFailedTransactionToken: string;
    /**
     * 
     * @type {string}
     * @memberof ClearingRetryModel
     */
    newNetworkReference?: string;
    /**
     * 
     * @type {string}
     * @memberof ClearingRetryModel
     */
    newApprovalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ClearingRetryModel
     */
    newStan?: string;
    /**
     * 
     * @type {number}
     * @memberof ClearingRetryModel
     */
    findOriginalWindowDays?: number;
    /**
     * 
     * @type {string}
     * @memberof ClearingRetryModel
     */
    newProcessingCode?: string;
}

/**
 * 
 * @export
 * @interface ClientAccessTokenRequest
 */
export interface ClientAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientAccessTokenRequest
     */
    applicationToken?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientAccessTokenRequest
     */
    cardToken: string;
}

/**
 * 
 * @export
 * @interface ClientAccessTokenResponse
 */
export interface ClientAccessTokenResponse {
    /**
     * 
     * @type {Application}
     * @memberof ClientAccessTokenResponse
     */
    application?: Application;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof ClientAccessTokenResponse
     */
    created: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof ClientAccessTokenResponse
     */
    expires: Date;
    /**
     * 
     * @type {string}
     * @memberof ClientAccessTokenResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientAccessTokenResponse
     */
    cardToken?: string;
}

/**
 * 
 * @export
 * @interface CommandoModeEnables
 */
export interface CommandoModeEnables {
    /**
     * 
     * @type {string}
     * @memberof CommandoModeEnables
     */
    programFundingSource: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommandoModeEnables
     */
    velocityControls?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommandoModeEnables
     */
    authControls?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CommandoModeEnables
     */
    ignoreCardSuspendedState?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CommandoModeEnables
     */
    useCacheBalance?: boolean;
}

/**
 * 
 * @export
 * @interface CommandoModeListResponse
 */
export interface CommandoModeListResponse {
    /**
     * 
     * @type {number}
     * @memberof CommandoModeListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandoModeListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandoModeListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CommandoModeListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<CommandoModeResponse>}
     * @memberof CommandoModeListResponse
     */
    data?: Array<CommandoModeResponse>;
}

/**
 * 
 * @export
 * @interface CommandoModeNestedTransition
 */
export interface CommandoModeNestedTransition {
    /**
     * 
     * @type {boolean}
     * @memberof CommandoModeNestedTransition
     */
    commandoEnabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof CommandoModeNestedTransition
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandoModeNestedTransition
     */
    channel: CommandoModeNestedTransition.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof CommandoModeNestedTransition
     */
    username?: string;
}

/**
 * @export
 * @namespace CommandoModeNestedTransition
 */
export namespace CommandoModeNestedTransition {
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        SYSTEM = <any> 'SYSTEM',
        ADMIN = <any> 'ADMIN'
    }
}

/**
 * 
 * @export
 * @interface CommandoModeRequest
 */
export interface CommandoModeRequest {
    /**
     * 
     * @type {string}
     * @memberof CommandoModeRequest
     */
    programGatewayFundingSourceToken: string;
    /**
     * 
     * @type {RealTimeStandinCriteria}
     * @memberof CommandoModeRequest
     */
    realTimeStandinCriteria?: RealTimeStandinCriteria;
    /**
     * 
     * @type {CommandoModeEnables}
     * @memberof CommandoModeRequest
     */
    commandoModeEnables: CommandoModeEnables;
    /**
     * 
     * @type {string}
     * @memberof CommandoModeRequest
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface CommandoModeResponse
 */
export interface CommandoModeResponse {
    /**
     * 
     * @type {string}
     * @memberof CommandoModeResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandoModeResponse
     */
    programGatewayFundingSourceToken?: string;
    /**
     * 
     * @type {CommandoModeNestedTransition}
     * @memberof CommandoModeResponse
     */
    currentState?: CommandoModeNestedTransition;
    /**
     * 
     * @type {CommandoModeEnables}
     * @memberof CommandoModeResponse
     */
    commandoModeEnables?: CommandoModeEnables;
    /**
     * 
     * @type {RealTimeStandinCriteria}
     * @memberof CommandoModeResponse
     */
    realTimeStandinCriteria?: RealTimeStandinCriteria;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof CommandoModeResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof CommandoModeResponse
     */
    lastModifiedTime: Date;
}

/**
 * 
 * @export
 * @interface CommandoModeTransitionListResponse
 */
export interface CommandoModeTransitionListResponse {
    /**
     * 
     * @type {number}
     * @memberof CommandoModeTransitionListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandoModeTransitionListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandoModeTransitionListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CommandoModeTransitionListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<CommandoModeTransitionResponse>}
     * @memberof CommandoModeTransitionListResponse
     */
    data?: Array<CommandoModeTransitionResponse>;
}

/**
 * 
 * @export
 * @interface CommandoModeTransitionRequest
 */
export interface CommandoModeTransitionRequest {
    /**
     * 
     * @type {string}
     * @memberof CommandoModeTransitionRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandoModeTransitionRequest
     */
    commandoModeToken: string;
    /**
     * 
     * @type {CommandoModeNestedTransition}
     * @memberof CommandoModeTransitionRequest
     */
    transition: CommandoModeNestedTransition;
}

/**
 * 
 * @export
 * @interface CommandoModeTransitionResponse
 */
export interface CommandoModeTransitionResponse {
    /**
     * 
     * @type {string}
     * @memberof CommandoModeTransitionResponse
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandoModeTransitionResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandoModeTransitionResponse
     */
    commandoModeToken?: string;
    /**
     * 
     * @type {CommandoModeNestedTransition}
     * @memberof CommandoModeTransitionResponse
     */
    transition?: CommandoModeNestedTransition;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof CommandoModeTransitionResponse
     */
    createdTime: Date;
    /**
     * 
     * @type {string}
     * @memberof CommandoModeTransitionResponse
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface CommandoModeUpdateRequest
 */
export interface CommandoModeUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CommandoModeUpdateRequest
     */
    programGatewayFundingSourceToken: string;
    /**
     * 
     * @type {RealTimeStandinCriteria}
     * @memberof CommandoModeUpdateRequest
     */
    realTimeStandinCriteria?: RealTimeStandinCriteria;
    /**
     * 
     * @type {CommandoModeEnables}
     * @memberof CommandoModeUpdateRequest
     */
    commandoModeEnables: CommandoModeEnables;
}

/**
 * 
 * @export
 * @interface ControlTokenRequest
 */
export interface ControlTokenRequest {
    /**
     * Token associated with the card
     * @type {string}
     * @memberof ControlTokenRequest
     */
    cardToken: string;
    /**
     * Type of control token required
     * @type {string}
     * @memberof ControlTokenRequest
     */
    controltokenType?: ControlTokenRequest.ControltokenTypeEnum;
}

/**
 * @export
 * @namespace ControlTokenRequest
 */
export namespace ControlTokenRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ControltokenTypeEnum {
        SETPIN = <any> 'SET_PIN',
        SHOWPIN = <any> 'SHOW_PIN'
    }
}

/**
 * 
 * @export
 * @interface ControlTokenResponse
 */
export interface ControlTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof ControlTokenResponse
     */
    controlToken: string;
}

/**
 * 
 * @export
 * @interface CreateCacheRequestEntry
 */
export interface CreateCacheRequestEntry {
    /**
     * 
     * @type {string}
     * @memberof CreateCacheRequestEntry
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCacheRequestEntry
     */
    sendWebhook?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCacheRequestEntry
     */
    sendTms?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCacheRequestEntry
     */
    forceUpdate?: boolean;
}

/**
 * 
 * @export
 * @interface CreateCachesRequest
 */
export interface CreateCachesRequest {
    /**
     * 
     * @type {Array<CreateCacheRequestEntry>}
     * @memberof CreateCachesRequest
     */
    transactions: Array<CreateCacheRequestEntry>;
}

/**
 * 
 * @export
 * @interface CreateCachesResponse
 */
export interface CreateCachesResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCachesResponse
     */
    created?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCachesResponse
     */
    alreadyExists?: Array<string>;
    /**
     * 
     * @type {Array<CacheError>}
     * @memberof CreateCachesResponse
     */
    errors?: Array<CacheError>;
}

/**
 * 
 * @export
 * @interface CronJobInfo
 */
export interface CronJobInfo {
    /**
     * 
     * @type {string}
     * @memberof CronJobInfo
     */
    schedule?: string;
    /**
     * 
     * @type {string}
     * @memberof CronJobInfo
     */
    group?: string;
    /**
     * 
     * @type {string}
     * @memberof CronJobInfo
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CronJobInfo
     */
    _class?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CronJobInfo
     */
    isRunning?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CronJobInfo
     */
    lastRunDurationMillis?: number;
    /**
     * 
     * @type {Date}
     * @memberof CronJobInfo
     */
    nextRun?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CronJobInfo
     */
    lastRun?: Date;
    /**
     * 
     * @type {string}
     * @memberof CronJobInfo
     */
    timezone?: string;
    /**
     * 
     * @type {Date}
     * @memberof CronJobInfo
     */
    startTime?: Date;
}

/**
 * 
 * @export
 * @interface CurrencyConversion
 */
export interface CurrencyConversion {
    /**
     * 
     * @type {Network}
     * @memberof CurrencyConversion
     */
    network?: Network;
}

/**
 * 
 * @export
 * @interface CustomerDueDiligenceRequest
 */
export interface CustomerDueDiligenceRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomerDueDiligenceRequest
     */
    question: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerDueDiligenceRequest
     */
    answer: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerDueDiligenceRequest
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface CustomerDueDiligenceResponse
 */
export interface CustomerDueDiligenceResponse {
    /**
     * 
     * @type {string}
     * @memberof CustomerDueDiligenceResponse
     */
    question: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerDueDiligenceResponse
     */
    answer: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerDueDiligenceResponse
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerDueDiligenceResponse
     */
    bank: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerDueDiligenceResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerDueDiligenceResponse
     */
    accountToken: string;
}

/**
 * 
 * @export
 * @interface CustomerDueDiligenceUpdateRequest
 */
export interface CustomerDueDiligenceUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomerDueDiligenceUpdateRequest
     */
    answer?: string;
}

/**
 * 
 * @export
 * @interface DDARequest
 */
export interface DDARequest {
    /**
     * 
     * @type {string}
     * @memberof DDARequest
     */
    dda: string;
}

/**
 * 
 * @export
 * @interface DepositAccountInfo
 */
export interface DepositAccountInfo {
    /**
     * 
     * @type {string}
     * @memberof DepositAccountInfo
     */
    depositAccountToken: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountInfo
     */
    directDepositAccountToken: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountInfo
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountInfo
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountInfo
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountInfo
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface DepositAccountInfoResponse
 */
export interface DepositAccountInfoResponse {
    /**
     * 
     * @type {{ [key: string]: DepositAccountInfo; }}
     * @memberof DepositAccountInfoResponse
     */
    accounts?: { [key: string]: DepositAccountInfo; };
}

/**
 * 
 * @export
 * @interface DepositAccountResponse
 */
export interface DepositAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof DepositAccountResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountResponse
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountResponse
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountResponse
     */
    accountNumber: string;
    /**
     * 
     * @type {string}
     * @memberof DepositAccountResponse
     */
    routingNumber: string;
    /**
     * 
     * @type {boolean}
     * @memberof DepositAccountResponse
     */
    allowImmediateCredit?: boolean;
}

/**
 * 
 * @export
 * @interface DepositAccountUpdateRequest
 */
export interface DepositAccountUpdateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof DepositAccountUpdateRequest
     */
    allowImmediateCredit?: boolean;
}

/**
 * 
 * @export
 * @interface DepositDepositResponse
 */
export interface DepositDepositResponse {
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof DepositDepositResponse
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    type?: DepositDepositResponse.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    state?: DepositDepositResponse.StateEnum;
    /**
     * 
     * @type {Date}
     * @memberof DepositDepositResponse
     */
    settlementDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    stateReason?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    stateReasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    directDepositAccountToken?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    businessToken?: string;
    /**
     * 
     * @type {Date}
     * @memberof DepositDepositResponse
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DepositDepositResponse
     */
    lastModifiedTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    standardEntryClassCode?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    companyName?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    companyDiscretionaryData?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    companyIdentification?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    companyEntryDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    individualIdentificationNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof DepositDepositResponse
     */
    individualName?: string;
}

/**
 * @export
 * @namespace DepositDepositResponse
 */
export namespace DepositDepositResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        PENDING = <any> 'PENDING',
        APPLIED = <any> 'APPLIED',
        REVERSED = <any> 'REVERSED',
        REJECTED = <any> 'REJECTED'
    }
}

/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    languageCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    phoneNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    ipAddress?: string;
}

/**
 * 
 * @export
 * @interface DigitalWalletAndroidPayProvisionRequest
 */
export interface DigitalWalletAndroidPayProvisionRequest {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletAndroidPayProvisionRequest
     */
    cardToken: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletAndroidPayProvisionRequest
     */
    deviceType: DigitalWalletAndroidPayProvisionRequest.DeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletAndroidPayProvisionRequest
     */
    provisioningAppVersion: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletAndroidPayProvisionRequest
     */
    walletAccountId: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletAndroidPayProvisionRequest
     */
    deviceId: string;
}

/**
 * @export
 * @namespace DigitalWalletAndroidPayProvisionRequest
 */
export namespace DigitalWalletAndroidPayProvisionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum DeviceTypeEnum {
        MOBILEPHONE = <any> 'MOBILE_PHONE',
        WATCH = <any> 'WATCH',
        TABLET = <any> 'TABLET',
        WEARABLEDEVICE = <any> 'WEARABLE_DEVICE',
        HOUSEHOLDDEVICE = <any> 'HOUSEHOLD_DEVICE',
        AUTOMOBILEDEVICE = <any> 'AUTOMOBILE_DEVICE'
    }
}

/**
 * 
 * @export
 * @interface DigitalWalletAndroidPayProvisionResponse
 */
export interface DigitalWalletAndroidPayProvisionResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof DigitalWalletAndroidPayProvisionResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof DigitalWalletAndroidPayProvisionResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletAndroidPayProvisionResponse
     */
    cardToken: string;
    /**
     * 
     * @type {AndroidPushTokenizeRequestData}
     * @memberof DigitalWalletAndroidPayProvisionResponse
     */
    pushTokenizeRequestData: AndroidPushTokenizeRequestData;
}

/**
 * 
 * @export
 * @interface DigitalWalletApplePayProvisionRequest
 */
export interface DigitalWalletApplePayProvisionRequest {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletApplePayProvisionRequest
     */
    cardToken: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletApplePayProvisionRequest
     */
    deviceType: DigitalWalletApplePayProvisionRequest.DeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletApplePayProvisionRequest
     */
    provisioningAppVersion: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DigitalWalletApplePayProvisionRequest
     */
    certificates: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletApplePayProvisionRequest
     */
    nonce: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletApplePayProvisionRequest
     */
    nonceSignature: string;
}

/**
 * @export
 * @namespace DigitalWalletApplePayProvisionRequest
 */
export namespace DigitalWalletApplePayProvisionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum DeviceTypeEnum {
        MOBILEPHONE = <any> 'MOBILE_PHONE',
        WATCH = <any> 'WATCH',
        TABLET = <any> 'TABLET',
        WEARABLEDEVICE = <any> 'WEARABLE_DEVICE',
        HOUSEHOLDDEVICE = <any> 'HOUSEHOLD_DEVICE',
        AUTOMOBILEDEVICE = <any> 'AUTOMOBILE_DEVICE'
    }
}

/**
 * 
 * @export
 * @interface DigitalWalletApplePayProvisionResponse
 */
export interface DigitalWalletApplePayProvisionResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof DigitalWalletApplePayProvisionResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof DigitalWalletApplePayProvisionResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletApplePayProvisionResponse
     */
    cardToken: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletApplePayProvisionResponse
     */
    encryptedPassData: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletApplePayProvisionResponse
     */
    activationData: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletApplePayProvisionResponse
     */
    ephemeralPublicKey: string;
}

/**
 * 
 * @export
 * @interface DigitalWalletSamsungPayProvisionRequest
 */
export interface DigitalWalletSamsungPayProvisionRequest {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletSamsungPayProvisionRequest
     */
    cardToken: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletSamsungPayProvisionRequest
     */
    deviceType: DigitalWalletSamsungPayProvisionRequest.DeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletSamsungPayProvisionRequest
     */
    provisioningAppVersion: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletSamsungPayProvisionRequest
     */
    walletUserId: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletSamsungPayProvisionRequest
     */
    deviceId: string;
}

/**
 * @export
 * @namespace DigitalWalletSamsungPayProvisionRequest
 */
export namespace DigitalWalletSamsungPayProvisionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum DeviceTypeEnum {
        MOBILEPHONE = <any> 'MOBILE_PHONE',
        WATCH = <any> 'WATCH',
        TABLET = <any> 'TABLET',
        WEARABLEDEVICE = <any> 'WEARABLE_DEVICE',
        HOUSEHOLDDEVICE = <any> 'HOUSEHOLD_DEVICE',
        AUTOMOBILEDEVICE = <any> 'AUTOMOBILE_DEVICE'
    }
}

/**
 * 
 * @export
 * @interface DigitalWalletSamsungPayProvisionResponse
 */
export interface DigitalWalletSamsungPayProvisionResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof DigitalWalletSamsungPayProvisionResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof DigitalWalletSamsungPayProvisionResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletSamsungPayProvisionResponse
     */
    cardToken: string;
    /**
     * 
     * @type {SamsungPushTokenizeRequestData}
     * @memberof DigitalWalletSamsungPayProvisionResponse
     */
    pushTokenizeRequestData: SamsungPushTokenizeRequestData;
}

/**
 * 
 * @export
 * @interface DigitalWalletToken
 */
export interface DigitalWalletToken {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletToken
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletToken
     */
    cardToken?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletToken
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletToken
     */
    stateReason?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletToken
     */
    fulfillmentStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletToken
     */
    issuerEligibilityDecision?: string;
    /**
     * 
     * @type {Date}
     * @memberof DigitalWalletToken
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DigitalWalletToken
     */
    lastModifiedTime?: Date;
    /**
     * 
     * @type {TokenServiceProvider}
     * @memberof DigitalWalletToken
     */
    tokenServiceProvider?: TokenServiceProvider;
    /**
     * 
     * @type {Device}
     * @memberof DigitalWalletToken
     */
    device?: Device;
    /**
     * 
     * @type {WalletProviderProfile}
     * @memberof DigitalWalletToken
     */
    walletProviderProfile?: WalletProviderProfile;
    /**
     * 
     * @type {AddressVerification}
     * @memberof DigitalWalletToken
     */
    addressVerification?: AddressVerification;
    /**
     * 
     * @type {UserCardHolderResponse}
     * @memberof DigitalWalletToken
     */
    user?: UserCardHolderResponse;
    /**
     * 
     * @type {DigitalWalletTokenMetadata}
     * @memberof DigitalWalletToken
     */
    metadata?: DigitalWalletTokenMetadata;
}

/**
 * 
 * @export
 * @interface DigitalWalletTokenAddressVerification
 */
export interface DigitalWalletTokenAddressVerification {
    /**
     * 
     * @type {boolean}
     * @memberof DigitalWalletTokenAddressVerification
     */
    validate?: boolean;
}

/**
 * 
 * @export
 * @interface DigitalWalletTokenDevice
 */
export interface DigitalWalletTokenDevice {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenDevice
     */
    deviceType?: DigitalWalletTokenDevice.DeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenDevice
     */
    deviceLangCode?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenDevice
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenDevice
     */
    deviceNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenDevice
     */
    deviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenDevice
     */
    deviceLocation?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenDevice
     */
    deviceIpAddress?: string;
}

/**
 * @export
 * @namespace DigitalWalletTokenDevice
 */
export namespace DigitalWalletTokenDevice {
    /**
     * @export
     * @enum {string}
     */
    export enum DeviceTypeEnum {
        UNKNOWN = <any> 'UNKNOWN',
        MOBILEPHONE = <any> 'MOBILE_PHONE',
        WATCH = <any> 'WATCH',
        TABLET = <any> 'TABLET',
        MOBILEPHONEORTABLET = <any> 'MOBILE_PHONE_OR_TABLET',
        PERSONALCOMPUTER = <any> 'PERSONAL_COMPUTER'
    }
}

/**
 * 
 * @export
 * @interface DigitalWalletTokenHash
 */
export interface DigitalWalletTokenHash {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenHash
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenHash
     */
    cardToken?: string;
}

/**
 * 
 * @export
 * @interface DigitalWalletTokenListResponse
 */
export interface DigitalWalletTokenListResponse {
    /**
     * 
     * @type {number}
     * @memberof DigitalWalletTokenListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof DigitalWalletTokenListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof DigitalWalletTokenListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DigitalWalletTokenListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<DigitalWalletToken>}
     * @memberof DigitalWalletTokenListResponse
     */
    data?: Array<DigitalWalletToken>;
}

/**
 * 
 * @export
 * @interface DigitalWalletTokenMetadata
 */
export interface DigitalWalletTokenMetadata {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenMetadata
     */
    issuerProductConfigId?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenMetadata
     */
    cardproductPreferredNotificationLanguage?: string;
}

/**
 * 
 * @export
 * @interface DigitalWalletTokenRequestorMapModel
 */
export interface DigitalWalletTokenRequestorMapModel {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenRequestorMapModel
     */
    network: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenRequestorMapModel
     */
    digitalWalletTokenRequestorId: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenRequestorMapModel
     */
    digitalWalletTokenRequestorName: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenRequestorMapModel
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface DigitalWalletTokenRequestorMapUpdateModel
 */
export interface DigitalWalletTokenRequestorMapUpdateModel {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenRequestorMapUpdateModel
     */
    network: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenRequestorMapUpdateModel
     */
    digitalWalletTokenRequestorId: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenRequestorMapUpdateModel
     */
    digitalWalletTokenRequestorName: string;
}

/**
 * 
 * @export
 * @interface DigitalWalletTokenTransitionListResponse
 */
export interface DigitalWalletTokenTransitionListResponse {
    /**
     * 
     * @type {number}
     * @memberof DigitalWalletTokenTransitionListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof DigitalWalletTokenTransitionListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof DigitalWalletTokenTransitionListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DigitalWalletTokenTransitionListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<DigitalWalletTokenTransitionResponse>}
     * @memberof DigitalWalletTokenTransitionListResponse
     */
    data?: Array<DigitalWalletTokenTransitionResponse>;
}

/**
 * 
 * @export
 * @interface DigitalWalletTokenTransitionRequest
 */
export interface DigitalWalletTokenTransitionRequest {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionRequest
     */
    reasonCode?: DigitalWalletTokenTransitionRequest.ReasonCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionRequest
     */
    tokenReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionRequest
     */
    channel?: DigitalWalletTokenTransitionRequest.ChannelEnum;
    /**
     * 
     * @type {DigitalWalletTokenHash}
     * @memberof DigitalWalletTokenTransitionRequest
     */
    digitalWalletToken: DigitalWalletTokenHash;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionRequest
     */
    state: DigitalWalletTokenTransitionRequest.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionRequest
     */
    reason?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DigitalWalletTokenTransitionRequest
     */
    overrideTspError?: boolean;
}

/**
 * @export
 * @namespace DigitalWalletTokenTransitionRequest
 */
export namespace DigitalWalletTokenTransitionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonCodeEnum {
        _00 = <any> '00',
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _06 = <any> '06',
        _07 = <any> '07',
        _08 = <any> '08',
        _09 = <any> '09',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _13 = <any> '13',
        _14 = <any> '14',
        _15 = <any> '15',
        _16 = <any> '16',
        _17 = <any> '17',
        _18 = <any> '18',
        _19 = <any> '19',
        _20 = <any> '20',
        _21 = <any> '21',
        _22 = <any> '22',
        _23 = <any> '23',
        _24 = <any> '24',
        _25 = <any> '25',
        _26 = <any> '26',
        _27 = <any> '27',
        _28 = <any> '28',
        _29 = <any> '29',
        _30 = <any> '30',
        _31 = <any> '31'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        TOKENSERVICEPROVIDER = <any> 'TOKEN_SERVICE_PROVIDER',
        TOKENSERVICEPROVIDERAPI = <any> 'TOKEN_SERVICE_PROVIDER_API',
        DIGITALWALLET = <any> 'DIGITAL_WALLET',
        API = <any> 'API',
        IVR = <any> 'IVR',
        FRAUD = <any> 'FRAUD',
        ADMIN = <any> 'ADMIN',
        SYSTEM = <any> 'SYSTEM'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        TERMINATED = <any> 'TERMINATED'
    }
}

/**
 * 
 * @export
 * @interface DigitalWalletTokenTransitionResponse
 */
export interface DigitalWalletTokenTransitionResponse {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionResponse
     */
    token: string;
    /**
     * 
     * @type {DigitalWalletTokenHash}
     * @memberof DigitalWalletTokenTransitionResponse
     */
    digitalWalletToken: DigitalWalletTokenHash;
    /**
     * 
     * @type {CardSwapHash}
     * @memberof DigitalWalletTokenTransitionResponse
     */
    cardSwap?: CardSwapHash;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionResponse
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionResponse
     */
    channel: DigitalWalletTokenTransitionResponse.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionResponse
     */
    state: DigitalWalletTokenTransitionResponse.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionResponse
     */
    fulfillmentStatus: DigitalWalletTokenTransitionResponse.FulfillmentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionResponse
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenTransitionResponse
     */
    reasonCode?: DigitalWalletTokenTransitionResponse.ReasonCodeEnum;
    /**
     * 
     * @type {Date}
     * @memberof DigitalWalletTokenTransitionResponse
     */
    createdTime?: Date;
}

/**
 * @export
 * @namespace DigitalWalletTokenTransitionResponse
 */
export namespace DigitalWalletTokenTransitionResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        TOKENSERVICEPROVIDER = <any> 'TOKEN_SERVICE_PROVIDER',
        DIGITALWALLET = <any> 'DIGITAL_WALLET',
        API = <any> 'API',
        IVR = <any> 'IVR',
        FRAUD = <any> 'FRAUD',
        ADMIN = <any> 'ADMIN',
        SYSTEM = <any> 'SYSTEM',
        TOKENSERVICEPROVIDERAPI = <any> 'TOKEN_SERVICE_PROVIDER_API'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        REQUESTED = <any> 'REQUESTED',
        REQUESTDECLINED = <any> 'REQUEST_DECLINED',
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        TERMINATED = <any> 'TERMINATED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FulfillmentStatusEnum {
        DECISIONRED = <any> 'DECISION_RED',
        DECISIONYELLOW = <any> 'DECISION_YELLOW',
        DECISIONGREEN = <any> 'DECISION_GREEN',
        REJECTED = <any> 'REJECTED',
        PROVISIONED = <any> 'PROVISIONED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonCodeEnum {
        _00 = <any> '00',
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _06 = <any> '06',
        _07 = <any> '07',
        _08 = <any> '08',
        _09 = <any> '09',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _13 = <any> '13',
        _14 = <any> '14',
        _15 = <any> '15',
        _16 = <any> '16',
        _17 = <any> '17',
        _18 = <any> '18',
        _19 = <any> '19',
        _20 = <any> '20',
        _21 = <any> '21',
        _22 = <any> '22',
        _23 = <any> '23',
        _24 = <any> '24',
        _25 = <any> '25',
        _26 = <any> '26',
        _27 = <any> '27',
        _28 = <any> '28',
        _29 = <any> '29',
        _30 = <any> '30',
        _31 = <any> '31'
    }
}

/**
 * 
 * @export
 * @interface DigitalWalletTokenWalletProvider
 */
export interface DigitalWalletTokenWalletProvider {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenWalletProvider
     */
    walletProviderCardholderWalletAccountId?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenWalletProvider
     */
    walletProviderRiskAssessment?: DigitalWalletTokenWalletProvider.WalletProviderRiskAssessmentEnum;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenWalletProvider
     */
    walletProviderRiskAssessmentVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenWalletProvider
     */
    walletProviderDeviceScore?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenWalletProvider
     */
    walletProviderAccountScore?: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenWalletProvider
     */
    walletProviderPanSource?: DigitalWalletTokenWalletProvider.WalletProviderPanSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenWalletProvider
     */
    walletProviderReasonCode?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DigitalWalletTokenWalletProvider
     */
    recommendationReasons?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenWalletProvider
     */
    cardholderWalletAccountEmail?: string;
}

/**
 * @export
 * @namespace DigitalWalletTokenWalletProvider
 */
export namespace DigitalWalletTokenWalletProvider {
    /**
     * @export
     * @enum {string}
     */
    export enum WalletProviderRiskAssessmentEnum {
        GREEN = <any> 'DECISION_GREEN',
        YELLOW = <any> 'DECISION_YELLOW',
        RED = <any> 'DECISION_RED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum WalletProviderPanSourceEnum {
        ONFILE = <any> 'ON_FILE',
        KEYENTERED = <any> 'KEY_ENTERED',
        MOBILEBANKINGAPP = <any> 'MOBILE_BANKING_APP'
    }
}

/**
 * 
 * @export
 * @interface DigitalWalletTokenization
 */
export interface DigitalWalletTokenization {
    /**
     * 
     * @type {ProvisioningControls}
     * @memberof DigitalWalletTokenization
     */
    provisioningControls?: ProvisioningControls;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletTokenization
     */
    cardArtId?: string;
}

/**
 * 
 * @export
 * @interface DigitalWalletXPayProvisionRequest
 */
export interface DigitalWalletXPayProvisionRequest {
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletXPayProvisionRequest
     */
    cardToken: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletXPayProvisionRequest
     */
    deviceType: DigitalWalletXPayProvisionRequest.DeviceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletXPayProvisionRequest
     */
    provisioningAppVersion: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletXPayProvisionRequest
     */
    walletAccountId: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletXPayProvisionRequest
     */
    deviceId: string;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletXPayProvisionRequest
     */
    tokenRequestorId: string;
}

/**
 * @export
 * @namespace DigitalWalletXPayProvisionRequest
 */
export namespace DigitalWalletXPayProvisionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum DeviceTypeEnum {
        MOBILEPHONE = <any> 'MOBILE_PHONE',
        WATCH = <any> 'WATCH',
        TABLET = <any> 'TABLET',
        WEARABLEDEVICE = <any> 'WEARABLE_DEVICE',
        HOUSEHOLDDEVICE = <any> 'HOUSEHOLD_DEVICE',
        AUTOMOBILEDEVICE = <any> 'AUTOMOBILE_DEVICE'
    }
}

/**
 * 
 * @export
 * @interface DigitalWalletXPayProvisionResponse
 */
export interface DigitalWalletXPayProvisionResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof DigitalWalletXPayProvisionResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof DigitalWalletXPayProvisionResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof DigitalWalletXPayProvisionResponse
     */
    cardToken: string;
    /**
     * 
     * @type {XpayPushTokenizeRequestData}
     * @memberof DigitalWalletXPayProvisionResponse
     */
    pushTokenizeRequestData: XpayPushTokenizeRequestData;
}

/**
 * 
 * @export
 * @interface DirectDepositAccountListResponse
 */
export interface DirectDepositAccountListResponse {
    /**
     * 
     * @type {number}
     * @memberof DirectDepositAccountListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof DirectDepositAccountListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof DirectDepositAccountListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DirectDepositAccountListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<DirectDepositAccountResponse>}
     * @memberof DirectDepositAccountListResponse
     */
    data?: Array<DirectDepositAccountResponse>;
}

/**
 * 
 * @export
 * @interface DirectDepositAccountRequest
 */
export interface DirectDepositAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountRequest
     */
    token?: string;
    /**
     * Required if 'business_token' is null
     * @type {string}
     * @memberof DirectDepositAccountRequest
     */
    userToken?: string;
    /**
     * Required if 'user_token' is null
     * @type {string}
     * @memberof DirectDepositAccountRequest
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountRequest
     */
    type?: DirectDepositAccountRequest.TypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof DirectDepositAccountRequest
     */
    allowImmediateCredit?: boolean;
    /**
     * Required if account type = Checking
     * @type {Array<CustomerDueDiligenceRequest>}
     * @memberof DirectDepositAccountRequest
     */
    customerDueDiligence?: Array<CustomerDueDiligenceRequest>;
}

/**
 * @export
 * @namespace DirectDepositAccountRequest
 */
export namespace DirectDepositAccountRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        DEPOSITACCOUNT = <any> 'DEPOSIT_ACCOUNT',
        CHECKING = <any> 'CHECKING',
        SAVINGS = <any> 'SAVINGS',
        INTERESTBEARING = <any> 'INTEREST_BEARING'
    }
}

/**
 * 
 * @export
 * @interface DirectDepositAccountResponse
 */
export interface DirectDepositAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountResponse
     */
    accountNumber: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountResponse
     */
    routingNumber: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountResponse
     */
    userToken: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountResponse
     */
    businessToken: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountResponse
     */
    state: string;
    /**
     * 
     * @type {boolean}
     * @memberof DirectDepositAccountResponse
     */
    allowImmediateCredit: boolean;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountResponse
     */
    type?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof DirectDepositAccountResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof DirectDepositAccountResponse
     */
    lastModifiedTime: Date;
}

/**
 * 
 * @export
 * @interface DirectDepositAccountTransitionRequest
 */
export interface DirectDepositAccountTransitionRequest {
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountTransitionRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountTransitionRequest
     */
    accountToken: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountTransitionRequest
     */
    state?: DirectDepositAccountTransitionRequest.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountTransitionRequest
     */
    channel: DirectDepositAccountTransitionRequest.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountTransitionRequest
     */
    reason?: string;
}

/**
 * @export
 * @namespace DirectDepositAccountTransitionRequest
 */
export namespace DirectDepositAccountTransitionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        TERMINATED = <any> 'TERMINATED',
        UNSUPPORTED = <any> 'UNSUPPORTED',
        UNACTIVATED = <any> 'UNACTIVATED',
        LIMITED = <any> 'LIMITED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        IVR = <any> 'IVR',
        FRAUD = <any> 'FRAUD',
        ADMIN = <any> 'ADMIN',
        SYSTEM = <any> 'SYSTEM',
        NETWORK = <any> 'NETWORK',
        PRODSUPPORT = <any> 'PROD_SUPPORT',
        UNSUPPORTED = <any> 'UNSUPPORTED'
    }
}

/**
 * 
 * @export
 * @interface DirectDepositAccountTransitionResponse
 */
export interface DirectDepositAccountTransitionResponse {
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountTransitionResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountTransitionResponse
     */
    userToken: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountTransitionResponse
     */
    businessToken: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountTransitionResponse
     */
    accountToken: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountTransitionResponse
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountTransitionResponse
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositAccountTransitionResponse
     */
    reason: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof DirectDepositAccountTransitionResponse
     */
    createdTime: Date;
}

/**
 * 
 * @export
 * @interface DirectDepositFundingSourceModel
 */
export interface DirectDepositFundingSourceModel extends FundingSourceModel {
    /**
     * 
     * @type {string}
     * @memberof DirectDepositFundingSourceModel
     */
    name: string;
}

/**
 * 
 * @export
 * @interface DirectDepositListResponse
 */
export interface DirectDepositListResponse {
    /**
     * 
     * @type {number}
     * @memberof DirectDepositListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof DirectDepositListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof DirectDepositListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DirectDepositListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<DepositDepositResponse>}
     * @memberof DirectDepositListResponse
     */
    data?: Array<DepositDepositResponse>;
}

/**
 * 
 * @export
 * @interface DirectDepositRequest
 */
export interface DirectDepositRequest {
    /**
     * 
     * @type {string}
     * @memberof DirectDepositRequest
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof DirectDepositRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositRequest
     */
    type: DirectDepositRequest.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositRequest
     */
    accountNumber: string;
    /**
     * 
     * @type {Date}
     * @memberof DirectDepositRequest
     */
    settlementDate: Date;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositRequest
     */
    standardEntryClassCode?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositRequest
     */
    companyName?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositRequest
     */
    companyDiscretionaryData?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositRequest
     */
    companyIdentification?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositRequest
     */
    companyEntryDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositRequest
     */
    individualIdentificationNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositRequest
     */
    individualName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DirectDepositRequest
     */
    earlyPayEligible?: boolean;
}

/**
 * @export
 * @namespace DirectDepositRequest
 */
export namespace DirectDepositRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT'
    }
}

/**
 * 
 * @export
 * @interface DirectDepositTransitionListResponse
 */
export interface DirectDepositTransitionListResponse {
    /**
     * 
     * @type {number}
     * @memberof DirectDepositTransitionListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof DirectDepositTransitionListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof DirectDepositTransitionListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DirectDepositTransitionListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<DirectDepositTransitionResponse>}
     * @memberof DirectDepositTransitionListResponse
     */
    data?: Array<DirectDepositTransitionResponse>;
}

/**
 * 
 * @export
 * @interface DirectDepositTransitionRequest
 */
export interface DirectDepositTransitionRequest {
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionRequest
     */
    channel: DirectDepositTransitionRequest.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionRequest
     */
    idempotentHash?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionRequest
     */
    directDepositToken: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionRequest
     */
    state: DirectDepositTransitionRequest.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionRequest
     */
    reasonCode?: DirectDepositTransitionRequest.ReasonCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionRequest
     */
    reason: string;
}

/**
 * @export
 * @namespace DirectDepositTransitionRequest
 */
export namespace DirectDepositTransitionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        SYSTEM = <any> 'SYSTEM',
        PRODSUPPORT = <any> 'PROD_SUPPORT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        PENDING = <any> 'PENDING',
        APPLIED = <any> 'APPLIED',
        REVERSED = <any> 'REVERSED',
        REJECTED = <any> 'REJECTED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonCodeEnum {
        R01 = <any> 'R01',
        R02 = <any> 'R02',
        R03 = <any> 'R03',
        R04 = <any> 'R04',
        R06 = <any> 'R06',
        R08 = <any> 'R08',
        R09 = <any> 'R09',
        R10 = <any> 'R10',
        R11 = <any> 'R11',
        R14 = <any> 'R14',
        R15 = <any> 'R15',
        R16 = <any> 'R16',
        R17 = <any> 'R17',
        R18 = <any> 'R18',
        R20 = <any> 'R20',
        R23 = <any> 'R23',
        R24 = <any> 'R24',
        R29 = <any> 'R29'
    }
}

/**
 * 
 * @export
 * @interface DirectDepositTransitionResponse
 */
export interface DirectDepositTransitionResponse {
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionResponse
     */
    channel?: DirectDepositTransitionResponse.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionResponse
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionResponse
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionResponse
     */
    directDepositToken?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionResponse
     */
    transactionToken?: string;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionResponse
     */
    state?: DirectDepositTransitionResponse.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionResponse
     */
    reasonCode?: string;
    /**
     * 
     * @type {Date}
     * @memberof DirectDepositTransitionResponse
     */
    createdTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof DirectDepositTransitionResponse
     */
    directDepositAccountToken?: string;
}

/**
 * @export
 * @namespace DirectDepositTransitionResponse
 */
export namespace DirectDepositTransitionResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        IVR = <any> 'IVR',
        FRAUD = <any> 'FRAUD',
        ADMIN = <any> 'ADMIN',
        SYSTEM = <any> 'SYSTEM',
        NETWORK = <any> 'NETWORK',
        PRODSUPPORT = <any> 'PROD_SUPPORT',
        UNSUPPORTED = <any> 'UNSUPPORTED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        PENDING = <any> 'PENDING',
        APPLIED = <any> 'APPLIED',
        REVERSED = <any> 'REVERSED',
        REJECTED = <any> 'REJECTED'
    }
}

/**
 * 
 * @export
 * @interface DisputeModel
 */
export interface DisputeModel {
    /**
     * 
     * @type {string}
     * @memberof DisputeModel
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeModel
     */
    caseManagementIdentifier?: string;
}

/**
 * 
 * @export
 * @interface DisputeTransactionRequest
 */
export interface DisputeTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof DisputeTransactionRequest
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeTransactionRequest
     */
    pan: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeTransactionRequest
     */
    referenceTransactionToken: string;
    /**
     * 
     * @type {string}
     * @memberof DisputeTransactionRequest
     */
    reason: string;
    /**
     * 
     * @type {number}
     * @memberof DisputeTransactionRequest
     */
    cashAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof DisputeTransactionRequest
     */
    pendingAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DisputeTransactionRequest
     */
    includeAcquirerFees?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DisputeTransactionRequest
     */
    caseManagementIdentifier?: string;
}

/**
 * 
 * @export
 * @interface EarlyFundsRequestModel
 */
export interface EarlyFundsRequestModel {
    /**
     * 
     * @type {string}
     * @memberof EarlyFundsRequestModel
     */
    bankTransferToken?: string;
}

/**
 * 
 * @export
 * @interface EchoPingRequest
 */
export interface EchoPingRequest {
    /**
     * 
     * @type {string}
     * @memberof EchoPingRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof EchoPingRequest
     */
    payload?: string;
}

/**
 * 
 * @export
 * @interface EchoPingResponse
 */
export interface EchoPingResponse {
    /**
     * 
     * @type {string}
     * @memberof EchoPingResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof EchoPingResponse
     */
    payload?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EchoPingResponse
     */
    success?: boolean;
}

/**
 * 
 * @export
 * @interface ErrorMessageFromWebPushProvisioningRequest
 */
export interface ErrorMessageFromWebPushProvisioningRequest {
    /**
     * 
     * @type {string}
     * @memberof ErrorMessageFromWebPushProvisioningRequest
     */
    errorCode: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorMessageFromWebPushProvisioningRequest
     */
    errorMessage: string;
}

/**
 * 
 * @export
 * @interface ExpirationOffset
 */
export interface ExpirationOffset {
    /**
     * specify if a value is provided; default is YEARS
     * @type {string}
     * @memberof ExpirationOffset
     */
    unit?: ExpirationOffset.UnitEnum;
    /**
     * specify if unit is provided; default is 4
     * @type {number}
     * @memberof ExpirationOffset
     */
    value?: number;
    /**
     * 
     * @type {MinOffset}
     * @memberof ExpirationOffset
     */
    minOffset?: MinOffset;
}

/**
 * @export
 * @namespace ExpirationOffset
 */
export namespace ExpirationOffset {
    /**
     * @export
     * @enum {string}
     */
    export enum UnitEnum {
        YEARS = <any> 'YEARS',
        MONTHS = <any> 'MONTHS',
        DAYS = <any> 'DAYS',
        HOURS = <any> 'HOURS',
        MINUTES = <any> 'MINUTES',
        SECONDS = <any> 'SECONDS'
    }
}

/**
 * 
 * @export
 * @interface Fee
 */
export interface Fee {
    /**
     * 36 char max
     * @type {string}
     * @memberof Fee
     */
    token: string;
    /**
     * 50 char max
     * @type {string}
     * @memberof Fee
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Fee
     */
    amount: number;
    /**
     * 255 char max
     * @type {string}
     * @memberof Fee
     */
    tags?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof Fee
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof Fee
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Fee
     */
    active: boolean;
    /**
     * 
     * @type {string}
     * @memberof Fee
     */
    currencyCode: string;
    /**
     * 
     * @type {RealTimeFeeAssessment}
     * @memberof Fee
     */
    realTimeAssessment?: RealTimeFeeAssessment;
}

/**
 * 
 * @export
 * @interface FeeDetail
 */
export interface FeeDetail {
    /**
     * 36 char max
     * @type {string}
     * @memberof FeeDetail
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDetail
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDetail
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeDetail
     */
    transactionToken: string;
    /**
     * 
     * @type {Fee}
     * @memberof FeeDetail
     */
    fee: Fee;
}

/**
 * 
 * @export
 * @interface FeeListResponse
 */
export interface FeeListResponse {
    /**
     * 
     * @type {number}
     * @memberof FeeListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof FeeListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof FeeListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FeeListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<Fee>}
     * @memberof FeeListResponse
     */
    data?: Array<Fee>;
}

/**
 * 
 * @export
 * @interface FeeModel
 */
export interface FeeModel {
    /**
     * 
     * @type {string}
     * @memberof FeeModel
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof FeeModel
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeModel
     */
    tags?: string;
}

/**
 * 
 * @export
 * @interface FeeRequest
 */
export interface FeeRequest {
    /**
     * 
     * @type {string}
     * @memberof FeeRequest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof FeeRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof FeeRequest
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeRequest
     */
    currencyCode: string;
    /**
     * 
     * @type {boolean}
     * @memberof FeeRequest
     */
    active?: boolean;
    /**
     * 
     * @type {RealTimeFeeAssessmentRequest}
     * @memberof FeeRequest
     */
    realTimeAssessment?: RealTimeFeeAssessmentRequest;
}

/**
 * 
 * @export
 * @interface FeeTransferRequest
 */
export interface FeeTransferRequest {
    /**
     * 
     * @type {string}
     * @memberof FeeTransferRequest
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeTransferRequest
     */
    token?: string;
    /**
     * Required if 'business_token' is null
     * @type {string}
     * @memberof FeeTransferRequest
     */
    userToken: string;
    /**
     * Required if 'user_token' is null
     * @type {string}
     * @memberof FeeTransferRequest
     */
    businessToken: string;
    /**
     * 
     * @type {Array<FeeModel>}
     * @memberof FeeTransferRequest
     */
    fees: Array<FeeModel>;
}

/**
 * 
 * @export
 * @interface FeeTransferResponse
 */
export interface FeeTransferResponse {
    /**
     * 
     * @type {string}
     * @memberof FeeTransferResponse
     */
    tags?: string;
    /**
     * 
     * @type {Array<FeeDetail>}
     * @memberof FeeTransferResponse
     */
    fees: Array<FeeDetail>;
    /**
     * 36 char max
     * @type {string}
     * @memberof FeeTransferResponse
     */
    token: string;
    /**
     * Required if 'business_token' is null
     * @type {string}
     * @memberof FeeTransferResponse
     */
    userToken: string;
    /**
     * Required if 'user_token' is null
     * @type {string}
     * @memberof FeeTransferResponse
     */
    businessToken: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof FeeTransferResponse
     */
    createdTime: Date;
}

/**
 * 
 * @export
 * @interface FeeUpdateRequest
 */
export interface FeeUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof FeeUpdateRequest
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof FeeUpdateRequest
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof FeeUpdateRequest
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof FeeUpdateRequest
     */
    currencyCode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FeeUpdateRequest
     */
    active?: boolean;
    /**
     * 
     * @type {RealTimeFeeAssessmentRequest}
     * @memberof FeeUpdateRequest
     */
    realTimeAssessment?: RealTimeFeeAssessmentRequest;
}

/**
 * 
 * @export
 * @interface FileProcessingRequest
 */
export interface FileProcessingRequest {
    /**
     * 
     * @type {string}
     * @memberof FileProcessingRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof FileProcessingRequest
     */
    fileProcessType: FileProcessingRequest.FileProcessTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FileProcessingRequest
     */
    sourceFile: string;
    /**
     * 
     * @type {string}
     * @memberof FileProcessingRequest
     */
    archiveFile?: string;
}

/**
 * @export
 * @namespace FileProcessingRequest
 */
export namespace FileProcessingRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum FileProcessTypeEnum {
        MASTERCARDCLEARING = <any> 'MASTERCARD_CLEARING',
        VISACLEARING = <any> 'VISA_CLEARING',
        PULSECLEARING = <any> 'PULSE_CLEARING',
        DISCOVERCLEARING = <any> 'DISCOVER_CLEARING'
    }
}

/**
 * 
 * @export
 * @interface FileProcessingResponse
 */
export interface FileProcessingResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof FileProcessingResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof FileProcessingResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof FileProcessingResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof FileProcessingResponse
     */
    fileProcessType: FileProcessingResponse.FileProcessTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FileProcessingResponse
     */
    sourceFile: string;
    /**
     * 
     * @type {string}
     * @memberof FileProcessingResponse
     */
    archiveFile?: string;
    /**
     * 
     * @type {string}
     * @memberof FileProcessingResponse
     */
    fileProcessStatus: FileProcessingResponse.FileProcessStatusEnum;
}

/**
 * @export
 * @namespace FileProcessingResponse
 */
export namespace FileProcessingResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum FileProcessTypeEnum {
        MASTERCARDCLEARING = <any> 'MASTERCARD_CLEARING',
        VISACLEARING = <any> 'VISA_CLEARING',
        PULSECLEARING = <any> 'PULSE_CLEARING',
        DISCOVERCLEARING = <any> 'DISCOVER_CLEARING'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FileProcessStatusEnum {
        QUEUED = <any> 'QUEUED',
        STARTED = <any> 'STARTED',
        COMPLETED = <any> 'COMPLETED',
        ERROR = <any> 'ERROR',
        TERMINATED = <any> 'TERMINATED'
    }
}

/**
 * 
 * @export
 * @interface FinancialRequestModel
 */
export interface FinancialRequestModel {
    /**
     * 
     * @type {number}
     * @memberof FinancialRequestModel
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof FinancialRequestModel
     */
    cardToken: string;
    /**
     * 
     * @type {string}
     * @memberof FinancialRequestModel
     */
    pin?: string;
    /**
     * 
     * @type {string}
     * @memberof FinancialRequestModel
     */
    mid: string;
    /**
     * 
     * @type {number}
     * @memberof FinancialRequestModel
     */
    cashBackAmount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FinancialRequestModel
     */
    isPreAuth?: boolean;
    /**
     * 
     * @type {CardAcceptorModel}
     * @memberof FinancialRequestModel
     */
    cardAcceptor: CardAcceptorModel;
    /**
     * 
     * @type {TransactionOptions}
     * @memberof FinancialRequestModel
     */
    transactionOptions?: TransactionOptions;
    /**
     * 
     * @type {Webhook}
     * @memberof FinancialRequestModel
     */
    webhook?: Webhook;
}

/**
 * 
 * @export
 * @interface FraudStreamRequest
 */
export interface FraudStreamRequest {
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    program?: string;
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    type?: FraudStreamRequest.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    state?: FraudStreamRequest.StateEnum;
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    itc?: string;
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    actingUserToken?: string;
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    cardToken?: string;
    /**
     * 
     * @type {Date}
     * @memberof FraudStreamRequest
     */
    userTransactionTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof FraudStreamRequest
     */
    requestAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof FraudStreamRequest
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    currencyCode?: string;
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    accountRiskScore?: string;
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    accountRiskScoreReasonCode?: string;
    /**
     * 
     * @type {number}
     * @memberof FraudStreamRequest
     */
    transactionRiskScore?: number;
    /**
     * 
     * @type {string}
     * @memberof FraudStreamRequest
     */
    transactionRiskScoreReasonCode?: string;
    /**
     * 
     * @type {TransactionCardAcceptorViewModelV1}
     * @memberof FraudStreamRequest
     */
    cardAcceptor?: TransactionCardAcceptorViewModelV1;
    /**
     * 
     * @type {AddressVerificationModel}
     * @memberof FraudStreamRequest
     */
    addressVerification?: AddressVerificationModel;
}

/**
 * @export
 * @namespace FraudStreamRequest
 */
export namespace FraudStreamRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        GpaCreditPending = <any> 'gpa.credit.pending',
        GpaCreditPendingReversal = <any> 'gpa.credit.pending.reversal',
        GpaCreditReversal = <any> 'gpa.credit.reversal',
        GpaCredit = <any> 'gpa.credit',
        GpaDebit = <any> 'gpa.debit',
        GpaDebitPending = <any> 'gpa.debit.pending',
        GpaDebitPendingReversal = <any> 'gpa.debit.pending.reversal',
        GpaDebitReversal = <any> 'gpa.debit.reversal',
        GpaGrant = <any> 'gpa.grant',
        GpaCreditNetworkload = <any> 'gpa.credit.networkload',
        GpaCreditNetworkloadClearing = <any> 'gpa.credit.networkload.clearing',
        GpaCreditNetworkloadReversal = <any> 'gpa.credit.networkload.reversal',
        GpaDebitNetworkload = <any> 'gpa.debit.networkload',
        GpaDebitNetworkloadClearing = <any> 'gpa.debit.networkload.clearing',
        GpaDebitNetworkloadReversal = <any> 'gpa.debit.networkload.reversal',
        OriginalCreditAuthorization = <any> 'original.credit.authorization',
        OriginalCreditAuthorizationClearing = <any> 'original.credit.authorization.clearing',
        OriginalCreditAuthorizationReversal = <any> 'original.credit.authorization.reversal',
        OriginalCreditAuthPlusCapture = <any> 'original.credit.auth_plus_capture',
        OriginalCreditAuthPlusCaptureReversal = <any> 'original.credit.auth_plus_capture.reversal',
        GpaCreditIssueroperator = <any> 'gpa.credit.issueroperator',
        GpaDebitIssueroperator = <any> 'gpa.debit.issueroperator',
        GpaDebitAuthorization = <any> 'gpa.debit.authorization',
        GpaCreditAuthorization = <any> 'gpa.credit.authorization',
        GpaCreditAuthorizationReversal = <any> 'gpa.credit.authorization.reversal',
        GpaCreditChargeback = <any> 'gpa.credit.chargeback',
        GpaCreditChargebackReversal = <any> 'gpa.credit.chargeback.reversal',
        GpaCreditBillpayment = <any> 'gpa.credit.billpayment',
        GpaCreditAuthorizationBillpayment = <any> 'gpa.credit.authorization.billpayment',
        GpaCreditAuthorizationBillpaymentReversal = <any> 'gpa.credit.authorization.billpayment.reversal',
        MsaCreditPending = <any> 'msa.credit.pending',
        MsaCreditPendingReversal = <any> 'msa.credit.pending.reversal',
        MsaCreditReversal = <any> 'msa.credit.reversal',
        MsaCredit = <any> 'msa.credit',
        MsaDebitReversal = <any> 'msa.debit.reversal',
        MsaDebitPendingReversal = <any> 'msa.debit.pending.reversal',
        MsaDebit = <any> 'msa.debit',
        MsaCreditAuthorization = <any> 'msa.credit.authorization',
        MsaCreditAuthorizationReversal = <any> 'msa.credit.authorization.reversal',
        MsaCreditChargeback = <any> 'msa.credit.chargeback',
        MsaCreditChargebackReversal = <any> 'msa.credit.chargeback.reversal',
        Authorization = <any> 'authorization',
        AuthorizationIncremental = <any> 'authorization.incremental',
        AuthorizationAdvice = <any> 'authorization.advice',
        AuthorizationReversal = <any> 'authorization.reversal',
        AuthorizationCashback = <any> 'authorization.cashback',
        AuthorizationQuasiCash = <any> 'authorization.quasi.cash',
        AuthorizationAtmWithdrawal = <any> 'authorization.atm.withdrawal',
        AuthorizationClearing = <any> 'authorization.clearing',
        AuthorizationClearingNetworkFee = <any> 'authorization.clearing.network.fee',
        AuthorizationClearingRepresentment = <any> 'authorization.clearing.representment',
        AuthorizationReversalIssuerexpiration = <any> 'authorization.reversal.issuerexpiration',
        DisputeCredit = <any> 'dispute.credit',
        DisputeDebit = <any> 'dispute.debit',
        ChargebackPfsDebit = <any> 'chargeback.pfs.debit',
        ChargebackPfsPendingDebit = <any> 'chargeback.pfs.pending.debit',
        ChargebackPfsCredit = <any> 'chargeback.pfs.credit',
        AuthorizationClearingChargeback = <any> 'authorization.clearing.chargeback',
        AuthorizationClearingChargebackReversal = <any> 'authorization.clearing.chargeback.reversal',
        AuthorizationClearingChargebackCompleted = <any> 'authorization.clearing.chargeback.completed',
        AuthorizationClearingChargebackProvisionalCredit = <any> 'authorization.clearing.chargeback.provisional.credit',
        AuthorizationClearingChargebackProvisionalDebit = <any> 'authorization.clearing.chargeback.provisional.debit',
        AuthorizationClearingChargebackWriteoff = <any> 'authorization.clearing.chargeback.writeoff',
        AuthorizationClearingCashback = <any> 'authorization.clearing.cashback',
        AuthorizationClearingQuasiCash = <any> 'authorization.clearing.quasi.cash',
        AuthorizationClearingAtmWithdrawal = <any> 'authorization.clearing.atm.withdrawal',
        AccountFundingAuthorization = <any> 'account.funding.authorization',
        AccountFundingAuthorizationClearing = <any> 'account.funding.authorization.clearing',
        AccountFundingAuthPlusCapture = <any> 'account.funding.auth_plus_capture',
        AccountFundingAuthorizationReversal = <any> 'account.funding.authorization.reversal',
        AccountFundingAuthPlusCaptureReversal = <any> 'account.funding.auth_plus_capture.reversal',
        AddressVerification = <any> 'address.verification',
        Balanceinquiry = <any> 'balanceinquiry',
        Refund = <any> 'refund',
        PindebitCreditAdjustment = <any> 'pindebit.credit.adjustment',
        PindebitDebitAdjustment = <any> 'pindebit.debit.adjustment',
        PindebitAtmWithdrawal = <any> 'pindebit.atm.withdrawal',
        PindebitQuasiCash = <any> 'pindebit.quasi.cash',
        PindebitBalanceinquiry = <any> 'pindebit.balanceinquiry',
        PindebitCashback = <any> 'pindebit.cashback',
        PindebitCheckavs = <any> 'pindebit.checkavs',
        PindebitFinancialDeposit = <any> 'pindebit.financial.deposit',
        PindebitRefund = <any> 'pindebit.refund',
        PindebitReversal = <any> 'pindebit.reversal',
        PindebitRefundReversal = <any> 'pindebit.refund.reversal',
        PindebitTransfer = <any> 'pindebit.transfer',
        Pindebit = <any> 'pindebit',
        PindebitRepresentment = <any> 'pindebit.representment',
        PindebitAuthorization = <any> 'pindebit.authorization',
        PindebitAuthorizationClearing = <any> 'pindebit.authorization.clearing',
        PindebitAuthorizationReversal = <any> 'pindebit.authorization.reversal',
        PindebitAuthorizationReversalIssuerexpiration = <any> 'pindebit.authorization.reversal.issuerexpiration',
        PindebitChargeback = <any> 'pindebit.chargeback',
        PindebitChargebackReversal = <any> 'pindebit.chargeback.reversal',
        PindebitChargebackCompleted = <any> 'pindebit.chargeback.completed',
        PindebitChargebackProvisionalCredit = <any> 'pindebit.chargeback.provisional.credit',
        PindebitChargebackProvisionalDebit = <any> 'pindebit.chargeback.provisional.debit',
        PindebitChargebackWriteoff = <any> 'pindebit.chargeback.writeoff',
        DirectdepositCredit = <any> 'directdeposit.credit',
        DirectdepositDebit = <any> 'directdeposit.debit',
        DirectdepositCreditPending = <any> 'directdeposit.credit.pending',
        DirectdepositDebitPending = <any> 'directdeposit.debit.pending',
        DirectdepositCreditReject = <any> 'directdeposit.credit.reject',
        DirectdepositDebitReject = <any> 'directdeposit.debit.reject',
        DirectdepositCreditPendingReversal = <any> 'directdeposit.credit.pending.reversal',
        DirectdepositDebitPendingReversal = <any> 'directdeposit.debit.pending.reversal',
        DirectdepositCreditReversal = <any> 'directdeposit.credit.reversal',
        DirectdepositDebitReversal = <any> 'directdeposit.debit.reversal',
        FeeChargePending = <any> 'fee.charge.pending',
        FeeCharge = <any> 'fee.charge',
        FeeChargePendingRefund = <any> 'fee.charge.pending.refund',
        FundsExpire = <any> 'funds.expire',
        ProgramreserveCredit = <any> 'programreserve.credit',
        ProgramreserveDebit = <any> 'programreserve.debit',
        RewardEarn = <any> 'reward.earn',
        TransferPeer = <any> 'transfer.peer',
        TransferFee = <any> 'transfer.fee',
        AccountCredit = <any> 'account.credit',
        AccountDebit = <any> 'account.debit',
        TransferProgram = <any> 'transfer.program',
        TokenActivationRequest = <any> 'token.activation-request',
        TokenAdvice = <any> 'token.advice',
        PushtocardDebit = <any> 'pushtocard.debit',
        PushtocardPending = <any> 'pushtocard.pending',
        PushtocardReversal = <any> 'pushtocard.reversal',
        Billpayment = <any> 'billpayment',
        BillpaymentClearing = <any> 'billpayment.clearing',
        BillpaymentReversal = <any> 'billpayment.reversal',
        RefundAuthorization = <any> 'refund.authorization',
        RefundAuthorizationClearing = <any> 'refund.authorization.clearing',
        RefundAuthorizationReversal = <any> 'refund.authorization.reversal',
        AchEarlyFunds = <any> 'ach.early.funds',
        AchEarlyFundsReversed = <any> 'ach.early.funds.reversed',
        AchPushPending = <any> 'ach.push.pending',
        AchPullPending = <any> 'ach.pull.pending',
        AchPush = <any> 'ach.push',
        AchPull = <any> 'ach.pull',
        AchCancel = <any> 'ach.cancel',
        AchReturned = <any> 'ach.returned',
        AchPullReturned = <any> 'ach.pull.returned',
        AchPushReturned = <any> 'ach.push.returned',
        AchProvisionalCredit = <any> 'ach.provisional.credit',
        AchProvisionalCreditReversed = <any> 'ach.provisional.credit.reversed',
        AchPushReversalCompleted = <any> 'ach.push.reversal.completed',
        AchPushReversalDeclined = <any> 'ach.push.reversal.declined',
        AchJitPushPending = <any> 'ach.jit.push.pending',
        AchJitPullPending = <any> 'ach.jit.pull.pending',
        AchJitPush = <any> 'ach.jit.push',
        AchJitPull = <any> 'ach.jit.pull',
        AchJitCancel = <any> 'ach.jit.cancel',
        AchJitPullReturned = <any> 'ach.jit.pull.returned',
        AchJitPushReturned = <any> 'ach.jit.push.returned',
        CheckReturnDebit = <any> 'check.return.debit',
        CheckReturnDebitReversal = <any> 'check.return.debit.reversal',
        CheckClearingDebit = <any> 'check.clearing.debit',
        PullfromcardPull = <any> 'pullfromcard.pull',
        PullfromcardPushVisa = <any> 'pullfromcard.push.visa',
        PullfromcardPushMc = <any> 'pullfromcard.push.mc',
        PullfromcardPullReversal = <any> 'pullfromcard.pull.reversal',
        AccountfundingPull = <any> 'accountfunding.pull',
        AccountfundingPullChargeback = <any> 'accountfunding.pull.chargeback',
        EscheatmentDebit = <any> 'escheatment.debit',
        EscheatmentDebitReversal = <any> 'escheatment.debit.reversal',
        EscheatmentDebitClearing = <any> 'escheatment.debit.clearing',
        ZeroClearing = <any> 'zero.clearing',
        CreditAdjustment = <any> 'credit.adjustment',
        DebitAdjustment = <any> 'debit.adjustment',
        AccountTransfer = <any> 'account.transfer',
        AccountTransferReversal = <any> 'account.transfer.reversal',
        Unknown = <any> 'unknown'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        PENDING = <any> 'PENDING',
        CLEARED = <any> 'CLEARED',
        COMPLETION = <any> 'COMPLETION',
        DECLINED = <any> 'DECLINED',
        ERROR = <any> 'ERROR',
        ALL = <any> 'ALL'
    }
}

/**
 * 
 * @export
 * @interface FraudView
 */
export interface FraudView {
    /**
     * 
     * @type {NetworkFraudView}
     * @memberof FraudView
     */
    network?: NetworkFraudView;
    /**
     * 
     * @type {IssuerFraudView}
     * @memberof FraudView
     */
    issuerProcessor?: IssuerFraudView;
    /**
     * 
     * @type {NetworkAccountIntelligenceScore}
     * @memberof FraudView
     */
    networkAccountIntelligenceScore?: NetworkAccountIntelligenceScore;
}

/**
 * 
 * @export
 * @interface FulfillmentAddressRequest
 */
export interface FulfillmentAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressRequest
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressRequest
     */
    middleName?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressRequest
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressRequest
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressRequest
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressRequest
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressRequest
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressRequest
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressRequest
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressRequest
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressRequest
     */
    postalCode?: string;
}

/**
 * 
 * @export
 * @interface FulfillmentAddressResponse
 */
export interface FulfillmentAddressResponse {
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressResponse
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressResponse
     */
    middleName?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressResponse
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressResponse
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressResponse
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressResponse
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressResponse
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressResponse
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressResponse
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressResponse
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof FulfillmentAddressResponse
     */
    phone?: string;
}

/**
 * 
 * @export
 * @interface FulfillmentRequest
 */
export interface FulfillmentRequest {
    /**
     * 
     * @type {Shipping}
     * @memberof FulfillmentRequest
     */
    shipping?: Shipping;
    /**
     * 
     * @type {CardPersonalization}
     * @memberof FulfillmentRequest
     */
    cardPersonalization: CardPersonalization;
}

/**
 * 
 * @export
 * @interface FulfillmentResponse
 */
export interface FulfillmentResponse {
    /**
     * 
     * @type {ShippingInformationResponse}
     * @memberof FulfillmentResponse
     */
    shipping?: ShippingInformationResponse;
    /**
     * 
     * @type {CardPersonalization}
     * @memberof FulfillmentResponse
     */
    cardPersonalization: CardPersonalization;
}

/**
 * 
 * @export
 * @interface Funding
 */
export interface Funding {
    /**
     * 
     * @type {number}
     * @memberof Funding
     */
    amount?: number;
    /**
     * 
     * @type {FundingSourceModel}
     * @memberof Funding
     */
    source: FundingSourceModel;
    /**
     * 
     * @type {CardholderAddressResponse}
     * @memberof Funding
     */
    sourceAddress?: CardholderAddressResponse;
    /**
     * 
     * @type {GatewayLogModel}
     * @memberof Funding
     */
    gatewayLog?: GatewayLogModel;
}

/**
 * 
 * @export
 * @interface FundingAccountListResponse
 */
export interface FundingAccountListResponse {
    /**
     * 
     * @type {number}
     * @memberof FundingAccountListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof FundingAccountListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof FundingAccountListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FundingAccountListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<FundingAccountResponseModel>}
     * @memberof FundingAccountListResponse
     */
    data?: Array<FundingAccountResponseModel>;
}

/**
 * 
 * @export
 * @interface FundingAccountResponseModel
 */
export interface FundingAccountResponseModel {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof FundingAccountResponseModel
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof FundingAccountResponseModel
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountResponseModel
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountResponseModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountResponseModel
     */
    accountSuffix?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountResponseModel
     */
    accountType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FundingAccountResponseModel
     */
    active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FundingAccountResponseModel
     */
    isDefaultAccount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountResponseModel
     */
    expDate?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountResponseModel
     */
    verificationStatus?: string;
    /**
     * 
     * @type {Date}
     * @memberof FundingAccountResponseModel
     */
    dateVerified?: Date;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountResponseModel
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountResponseModel
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountResponseModel
     */
    nameOnAccount?: string;
    /**
     * 
     * @type {Date}
     * @memberof FundingAccountResponseModel
     */
    dateSentForVerification?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof FundingAccountResponseModel
     */
    verificationOverride?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountResponseModel
     */
    verificationNotes?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountResponseModel
     */
    linkPartnerAccountReferenceToken?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingAccountResponseModel
     */
    partner?: string;
}

/**
 * 
 * @export
 * @interface FundingRequestModel
 */
export interface FundingRequestModel {
    /**
     * 
     * @type {string}
     * @memberof FundingRequestModel
     */
    userToken: string;
    /**
     * 
     * @type {string}
     * @memberof FundingRequestModel
     */
    orderNumber: string;
    /**
     * 
     * @type {number}
     * @memberof FundingRequestModel
     */
    amount: number;
    /**
     * Payment card or ACH account number
     * @type {string}
     * @memberof FundingRequestModel
     */
    fundingSource?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingRequestModel
     */
    fundingAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingRequestModel
     */
    fundgpadetail?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingRequestModel
     */
    orderToken?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingRequestModel
     */
    currencyCode?: string;
}

/**
 * 
 * @export
 * @interface FundingResponseModel
 */
export interface FundingResponseModel {
    /**
     * 
     * @type {number}
     * @memberof FundingResponseModel
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof FundingResponseModel
     */
    accountingBalance?: number;
    /**
     * 
     * @type {number}
     * @memberof FundingResponseModel
     */
    availableBalance?: number;
    /**
     * 
     * @type {Gatewaylog}
     * @memberof FundingResponseModel
     */
    transaction?: Gatewaylog;
}

/**
 * 
 * @export
 * @interface FundingSourceModel
 */
export interface FundingSourceModel {
    /**
     * 
     * @type {string}
     * @memberof FundingSourceModel
     */
    token: string;
    /**
     * 
     * @type {boolean}
     * @memberof FundingSourceModel
     */
    active: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FundingSourceModel
     */
    isDefaultAccount: boolean;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof FundingSourceModel
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof FundingSourceModel
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof FundingSourceModel
     */
    type: string;
}

/**
 * 
 * @export
 * @interface FundingTranlog
 */
export interface FundingTranlog {
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    returnedBalances?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    transactionType: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    token: string;
    /**
     * 
     * @type {InternalAuthorizationTransaction}
     * @memberof FundingTranlog
     */
    refTransaction?: InternalAuthorizationTransaction;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    node: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    network: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    subNetwork: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    mid?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    tid?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    stan?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    caName?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    caStreet?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    caZip?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    caCity?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    caRegion?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    caCountry?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    functionCode?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    reasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    responseCode?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    approvalNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    displayMessage?: string;
    /**
     * 
     * @type {Date}
     * @memberof FundingTranlog
     */
    date?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FundingTranlog
     */
    transmissionDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FundingTranlog
     */
    localTransactionDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FundingTranlog
     */
    captureDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FundingTranlog
     */
    settlementDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    itc?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    irc?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    currencyCode?: string;
    /**
     * 
     * @type {number}
     * @memberof FundingTranlog
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof FundingTranlog
     */
    additionalAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof FundingTranlog
     */
    acquirerFee?: number;
    /**
     * 
     * @type {number}
     * @memberof FundingTranlog
     */
    issuerFee?: number;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    rc?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    extrc?: string;
    /**
     * 
     * @type {number}
     * @memberof FundingTranlog
     */
    duration?: number;
    /**
     * 
     * @type {InternalUser}
     * @memberof FundingTranlog
     */
    cardholder?: InternalUser;
    /**
     * 
     * @type {InternalUser}
     * @memberof FundingTranlog
     */
    actingCardholder?: InternalUser;
    /**
     * 
     * @type {InternalCard}
     * @memberof FundingTranlog
     */
    card?: InternalCard;
    /**
     * 
     * @type {InternalAccount}
     * @memberof FundingTranlog
     */
    account?: InternalAccount;
    /**
     * 
     * @type {InternalAccount}
     * @memberof FundingTranlog
     */
    account2?: InternalAccount;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    mcc?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    networkReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    acquirerReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    retrievalReferenceNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    forwardingInstId?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    networkMid?: string;
    /**
     * 
     * @type {number}
     * @memberof FundingTranlog
     */
    requestAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    transactionState?: FundingTranlog.TransactionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    remoteHost?: string;
    /**
     * 
     * @type {number}
     * @memberof FundingTranlog
     */
    responseAmount?: number;
    /**
     * 
     * @type {Date}
     * @memberof FundingTranlog
     */
    expirationTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    incomingNetworkRequestITC?: string;
    /**
     * 
     * @type {InternalDigitalWallet}
     * @memberof FundingTranlog
     */
    digitalWalletToken?: InternalDigitalWallet;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof FundingTranlog
     */
    tranlogAttributes?: { [key: string]: string; };
    /**
     * 
     * @type {TransactionModel}
     * @memberof FundingTranlog
     */
    payload?: TransactionModel;
    /**
     * 
     * @type {number}
     * @memberof FundingTranlog
     */
    layer?: number;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    transactionName?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    originator?: string;
    /**
     * 
     * @type {string}
     * @memberof FundingTranlog
     */
    acquirer?: string;
    /**
     * 
     * @type {InternalGPAOrder}
     * @memberof FundingTranlog
     */
    gpaorder: InternalGPAOrder;
    /**
     * 
     * @type {InternalGatewayLog}
     * @memberof FundingTranlog
     */
    gatewayLog: InternalGatewayLog;
}

/**
 * @export
 * @namespace FundingTranlog
 */
export namespace FundingTranlog {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionStateEnum {
        PENDING = <any> 'PENDING',
        CLEARED = <any> 'CLEARED',
        COMPLETION = <any> 'COMPLETION',
        DECLINED = <any> 'DECLINED',
        ERROR = <any> 'ERROR',
        ALL = <any> 'ALL'
    }
}

/**
 * 
 * @export
 * @interface GLEntry
 */
export interface GLEntry {
    /**
     * 
     * @type {string}
     * @memberof GLEntry
     */
    detail?: string;
    /**
     * 
     * @type {string}
     * @memberof GLEntry
     */
    tag?: string;
    /**
     * 
     * @type {number}
     * @memberof GLEntry
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof GLEntry
     */
    layer: string;
    /**
     * 
     * @type {string}
     * @memberof GLEntry
     */
    account: string;
    /**
     * 
     * @type {string}
     * @memberof GLEntry
     */
    type: GLEntry.TypeEnum;
}

/**
 * @export
 * @namespace GLEntry
 */
export namespace GLEntry {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT'
    }
}

/**
 * 
 * @export
 * @interface GPA
 */
export interface GPA {
    /**
     * 
     * @type {number}
     * @memberof GPA
     */
    triggerAmount: number;
    /**
     * 
     * @type {number}
     * @memberof GPA
     */
    reloadAmount: number;
}

/**
 * 
 * @export
 * @interface GPAUnloadListResponse
 */
export interface GPAUnloadListResponse {
    /**
     * 
     * @type {number}
     * @memberof GPAUnloadListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof GPAUnloadListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof GPAUnloadListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GPAUnloadListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<GpaReturns>}
     * @memberof GPAUnloadListResponse
     */
    data?: Array<GpaReturns>;
}

/**
 * 
 * @export
 * @interface GatewayClearingRequest
 */
export interface GatewayClearingRequest {
    /**
     * 
     * @type {string}
     * @memberof GatewayClearingRequest
     */
    originalTransactionToken: string;
    /**
     * Default is same amount as original GPA pending credit
     * @type {number}
     * @memberof GatewayClearingRequest
     */
    amount?: number;
}

/**
 * 
 * @export
 * @interface GatewayLogModel
 */
export interface GatewayLogModel {
    /**
     * 
     * @type {string}
     * @memberof GatewayLogModel
     */
    orderNumber: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayLogModel
     */
    transactionId: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayLogModel
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof GatewayLogModel
     */
    duration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GatewayLogModel
     */
    timedOut?: boolean;
    /**
     * 
     * @type {GatewayResponse}
     * @memberof GatewayLogModel
     */
    response?: GatewayResponse;
}

/**
 * 
 * @export
 * @interface GatewayProgramCustomHeaderUpdateRequest
 */
export interface GatewayProgramCustomHeaderUpdateRequest {
    /**
     * Custom headers
     * @type {{ [key: string]: string; }}
     * @memberof GatewayProgramCustomHeaderUpdateRequest
     */
    customHeader?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface GatewayProgramFundingSourceRequest
 */
export interface GatewayProgramFundingSourceRequest {
    /**
     * 
     * @type {string}
     * @memberof GatewayProgramFundingSourceRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayProgramFundingSourceRequest
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayProgramFundingSourceRequest
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GatewayProgramFundingSourceRequest
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GatewayProgramFundingSourceRequest
     */
    basicAuthUsername: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayProgramFundingSourceRequest
     */
    basicAuthPassword: string;
    /**
     * Total timeout in milliseconds for gateway processing
     * @type {number}
     * @memberof GatewayProgramFundingSourceRequest
     */
    timeoutMillis?: number;
    /**
     * Custom headers
     * @type {{ [key: string]: string; }}
     * @memberof GatewayProgramFundingSourceRequest
     */
    customHeader?: { [key: string]: string; };
    /**
     * Use MTLS for funding request
     * @type {boolean}
     * @memberof GatewayProgramFundingSourceRequest
     */
    useMtls?: boolean;
}

/**
 * 
 * @export
 * @interface GatewayProgramFundingSourceResponse
 */
export interface GatewayProgramFundingSourceResponse {
    /**
     * 250 char max. Empty string (disabled). Must be HTTPS.
     * @type {string}
     * @memberof GatewayProgramFundingSourceResponse
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayProgramFundingSourceResponse
     */
    version: string;
    /**
     * 
     * @type {string}
     * @memberof GatewayProgramFundingSourceResponse
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof GatewayProgramFundingSourceResponse
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GatewayProgramFundingSourceResponse
     */
    token: string;
    /**
     * 
     * @type {Date}
     * @memberof GatewayProgramFundingSourceResponse
     */
    createdTime: Date;
    /**
     * 
     * @type {Date}
     * @memberof GatewayProgramFundingSourceResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof GatewayProgramFundingSourceResponse
     */
    account: string;
    /**
     * 50 char max. Required if URL is present
     * @type {string}
     * @memberof GatewayProgramFundingSourceResponse
     */
    basicAuthUsername: string;
    /**
     * 50 char max. Required if URL is present. Minimum 20 chars with upper and lowercase letters, numbers, and symbols
     * @type {string}
     * @memberof GatewayProgramFundingSourceResponse
     */
    basicAuthPassword: string;
    /**
     * Total timeout in milliseconds for gateway processing
     * @type {number}
     * @memberof GatewayProgramFundingSourceResponse
     */
    timeoutMillis: number;
    /**
     * Custom headers to be passed along with request
     * @type {{ [key: string]: string; }}
     * @memberof GatewayProgramFundingSourceResponse
     */
    customHeader: { [key: string]: string; };
    /**
     * Use MTLS for funding request
     * @type {boolean}
     * @memberof GatewayProgramFundingSourceResponse
     */
    useMtls: boolean;
}

/**
 * 
 * @export
 * @interface GatewayProgramFundingSourceUpdateRequest
 */
export interface GatewayProgramFundingSourceUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GatewayProgramFundingSourceUpdateRequest
     */
    name?: string;
    /**
     * Empty string (disabled); must be HTTPS
     * @type {string}
     * @memberof GatewayProgramFundingSourceUpdateRequest
     */
    url: string;
    /**
     * 
     * @type {boolean}
     * @memberof GatewayProgramFundingSourceUpdateRequest
     */
    active?: boolean;
    /**
     * Required if URL is present
     * @type {string}
     * @memberof GatewayProgramFundingSourceUpdateRequest
     */
    basicAuthUsername: string;
    /**
     * Required if URL is present; must contain upper and lowercase letters, numbers, and symbols
     * @type {string}
     * @memberof GatewayProgramFundingSourceUpdateRequest
     */
    basicAuthPassword: string;
    /**
     * Total timeout in milliseconds for gateway processing
     * @type {number}
     * @memberof GatewayProgramFundingSourceUpdateRequest
     */
    timeoutMillis?: number;
    /**
     * Custom headers
     * @type {{ [key: string]: string; }}
     * @memberof GatewayProgramFundingSourceUpdateRequest
     */
    customHeader?: { [key: string]: string; };
    /**
     * Use MTLS for funding request
     * @type {boolean}
     * @memberof GatewayProgramFundingSourceUpdateRequest
     */
    useMtls?: boolean;
}

/**
 * 
 * @export
 * @interface GatewayProgramVersionUpdateRequest
 */
export interface GatewayProgramVersionUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof GatewayProgramVersionUpdateRequest
     */
    version: GatewayProgramVersionUpdateRequest.VersionEnum;
}

/**
 * @export
 * @namespace GatewayProgramVersionUpdateRequest
 */
export namespace GatewayProgramVersionUpdateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum VersionEnum {
        _10 = <any> '1.0',
        _20 = <any> '2.0'
    }
}

/**
 * 
 * @export
 * @interface GatewayResponse
 */
export interface GatewayResponse {
    /**
     * 
     * @type {string}
     * @memberof GatewayResponse
     */
    code: string;
    /**
     * 
     * @type {JitProgramResponse}
     * @memberof GatewayResponse
     */
    data?: JitProgramResponse;
}

/**
 * 
 * @export
 * @interface Gatewaylog
 */
export interface Gatewaylog {
    /**
     * 
     * @type {number}
     * @memberof Gatewaylog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Gatewaylog
     */
    traceNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    paymentTypeCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    achTransactionType?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    gatewayVersion?: string;
    /**
     * 
     * @type {GatewayResponse}
     * @memberof Gatewaylog
     */
    gatewayResponse?: GatewayResponse;
    /**
     * 
     * @type {boolean}
     * @memberof Gatewaylog
     */
    timedOut?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Gatewaylog
     */
    dealId?: number;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    orderId?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    requestMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    responseCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    responseSubcode?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    responseReasoncode?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    responseMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    fraudAvs?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    fraudAuth?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    fraudCvv?: string;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    gatewayTransactionId?: string;
    /**
     * 
     * @type {Gatewaylog}
     * @memberof Gatewaylog
     */
    originalGateway?: Gatewaylog;
    /**
     * 
     * @type {number}
     * @memberof Gatewaylog
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    duplicate?: string;
    /**
     * 
     * @type {Date}
     * @memberof Gatewaylog
     */
    postDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Gatewaylog
     */
    responseTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof Gatewaylog
     */
    apiDuration?: number;
    /**
     * 
     * @type {number}
     * @memberof Gatewaylog
     */
    gatewayDuration?: number;
    /**
     * 
     * @type {string}
     * @memberof Gatewaylog
     */
    achStatus?: string;
    /**
     * 
     * @type {Date}
     * @memberof Gatewaylog
     */
    created?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Gatewaylog
     */
    modified?: Date;
}

/**
 * 
 * @export
 * @interface GlTransactionRequest
 */
export interface GlTransactionRequest {
    /**
     * 
     * @type {Array<GLEntry>}
     * @memberof GlTransactionRequest
     */
    entries: Array<GLEntry>;
    /**
     * 
     * @type {string}
     * @memberof GlTransactionRequest
     */
    detail?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GlTransactionRequest
     */
    cardholderVisible?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GlTransactionRequest
     */
    triggerWebhook?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GlTransactionRequest
     */
    referenceTransactionToken?: string;
}

/**
 * 
 * @export
 * @interface GpaRequest
 */
export interface GpaRequest {
    /**
     * 
     * @type {string}
     * @memberof GpaRequest
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof GpaRequest
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof GpaRequest
     */
    token?: string;
    /**
     * Required if 'business_token' is null
     * @type {string}
     * @memberof GpaRequest
     */
    userToken?: string;
    /**
     * Required if 'user_token' is null
     * @type {string}
     * @memberof GpaRequest
     */
    businessToken?: string;
    /**
     * 
     * @type {number}
     * @memberof GpaRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof GpaRequest
     */
    currencyCode: string;
    /**
     * 
     * @type {string}
     * @memberof GpaRequest
     */
    fundingSourceToken: string;
    /**
     * 
     * @type {string}
     * @memberof GpaRequest
     */
    fundingSourceAddressToken?: string;
    /**
     * 
     * @type {Array<FeeModel>}
     * @memberof GpaRequest
     */
    fees?: Array<FeeModel>;
}

/**
 * 
 * @export
 * @interface GpaResponse
 */
export interface GpaResponse {
    /**
     * 
     * @type {string}
     * @memberof GpaResponse
     */
    token: string;
    /**
     * 
     * @type {number}
     * @memberof GpaResponse
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof GpaResponse
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof GpaResponse
     */
    memo?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof GpaResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof GpaResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof GpaResponse
     */
    transactionToken: string;
    /**
     * 
     * @type {string}
     * @memberof GpaResponse
     */
    state: string;
    /**
     * 
     * @type {Response}
     * @memberof GpaResponse
     */
    response: Response;
    /**
     * 
     * @type {Funding}
     * @memberof GpaResponse
     */
    funding: Funding;
    /**
     * 
     * @type {string}
     * @memberof GpaResponse
     */
    fundingSourceToken: string;
    /**
     * 
     * @type {string}
     * @memberof GpaResponse
     */
    fundingSourceAddressToken?: string;
    /**
     * 
     * @type {JitFundingApi}
     * @memberof GpaResponse
     */
    jitFunding?: JitFundingApi;
    /**
     * 
     * @type {string}
     * @memberof GpaResponse
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof GpaResponse
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof GpaResponse
     */
    currencyCode: string;
    /**
     * 
     * @type {number}
     * @memberof GpaResponse
     */
    gatewayToken?: number;
    /**
     * 
     * @type {string}
     * @memberof GpaResponse
     */
    gatewayMessage?: string;
    /**
     * 
     * @type {Array<FeeDetail>}
     * @memberof GpaResponse
     */
    fees?: Array<FeeDetail>;
}

/**
 * 
 * @export
 * @interface GpaReturns
 */
export interface GpaReturns {
    /**
     * 
     * @type {string}
     * @memberof GpaReturns
     */
    token: string;
    /**
     * 
     * @type {number}
     * @memberof GpaReturns
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof GpaReturns
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof GpaReturns
     */
    memo?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof GpaReturns
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof GpaReturns
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof GpaReturns
     */
    transactionToken: string;
    /**
     * 
     * @type {string}
     * @memberof GpaReturns
     */
    state: string;
    /**
     * 
     * @type {Response}
     * @memberof GpaReturns
     */
    response: Response;
    /**
     * 
     * @type {Funding}
     * @memberof GpaReturns
     */
    funding: Funding;
    /**
     * 
     * @type {string}
     * @memberof GpaReturns
     */
    fundingSourceToken: string;
    /**
     * 
     * @type {string}
     * @memberof GpaReturns
     */
    fundingSourceAddressToken?: string;
    /**
     * 
     * @type {JitFundingApi}
     * @memberof GpaReturns
     */
    jitFunding?: JitFundingApi;
    /**
     * 
     * @type {string}
     * @memberof GpaReturns
     */
    originalOrderToken?: string;
}

/**
 * 
 * @export
 * @interface HealthCheckResult
 */
export interface HealthCheckResult {
    /**
     * 
     * @type {string}
     * @memberof HealthCheckResult
     */
    component?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HealthCheckResult
     */
    healthy?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HealthCheckResult
     */
    fatal?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HealthCheckResult
     */
    status?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof HealthCheckResult
     */
    data?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface HoldIncrease
 */
export interface HoldIncrease {
    /**
     * 
     * @type {string}
     * @memberof HoldIncrease
     */
    type: HoldIncrease.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof HoldIncrease
     */
    value: number;
}

/**
 * @export
 * @namespace HoldIncrease
 */
export namespace HoldIncrease {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        AMOUNT = <any> 'AMOUNT',
        PERCENT = <any> 'PERCENT',
        UPTOLIMIT = <any> 'UP_TO_LIMIT'
    }
}

/**
 * 
 * @export
 * @interface IdentificationRequestModel
 */
export interface IdentificationRequestModel {
    /**
     * 
     * @type {string}
     * @memberof IdentificationRequestModel
     */
    type: IdentificationRequestModel.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof IdentificationRequestModel
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentificationRequestModel
     */
    expirationDate?: string;
}

/**
 * @export
 * @namespace IdentificationRequestModel
 */
export namespace IdentificationRequestModel {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        SSN = <any> 'SSN',
        TIN = <any> 'TIN',
        SIN = <any> 'SIN',
        NIN = <any> 'NIN',
        PASSPORTNUMBER = <any> 'PASSPORT_NUMBER',
        DRIVERSLICENSE = <any> 'DRIVERS_LICENSE',
        BUSINESSNUMBER = <any> 'BUSINESS_NUMBER',
        BUSINESSTAXID = <any> 'BUSINESS_TAX_ID',
        TAXPAYERREFERENCE = <any> 'TAXPAYER_REFERENCE'
    }
}

/**
 * 
 * @export
 * @interface IdentificationResponseModel
 */
export interface IdentificationResponseModel {
    /**
     * 
     * @type {string}
     * @memberof IdentificationResponseModel
     */
    type?: IdentificationResponseModel.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof IdentificationResponseModel
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentificationResponseModel
     */
    expirationDate?: string;
}

/**
 * @export
 * @namespace IdentificationResponseModel
 */
export namespace IdentificationResponseModel {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        SSN = <any> 'SSN',
        TIN = <any> 'TIN',
        SIN = <any> 'SIN',
        NIN = <any> 'NIN',
        PASSPORTNUMBER = <any> 'PASSPORT_NUMBER',
        DRIVERSLICENSE = <any> 'DRIVERS_LICENSE',
        BUSINESSNUMBER = <any> 'BUSINESS_NUMBER',
        BUSINESSTAXID = <any> 'BUSINESS_TAX_ID',
        TAXPAYERREFERENCE = <any> 'TAXPAYER_REFERENCE'
    }
}

/**
 * 
 * @export
 * @interface Images
 */
export interface Images {
    /**
     * 
     * @type {ImagesCard}
     * @memberof Images
     */
    card?: ImagesCard;
    /**
     * 
     * @type {ImagesCarrier}
     * @memberof Images
     */
    carrier?: ImagesCarrier;
    /**
     * 
     * @type {ImagesSignature}
     * @memberof Images
     */
    signature?: ImagesSignature;
    /**
     * 
     * @type {ImagesCarrierReturnWindow}
     * @memberof Images
     */
    carrierReturnWindow?: ImagesCarrierReturnWindow;
}

/**
 * 
 * @export
 * @interface ImagesCard
 */
export interface ImagesCard {
    /**
     * 
     * @type {string}
     * @memberof ImagesCard
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ImagesCard
     */
    thermalColor?: string;
}

/**
 * 
 * @export
 * @interface ImagesCarrier
 */
export interface ImagesCarrier {
    /**
     * 
     * @type {string}
     * @memberof ImagesCarrier
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ImagesCarrier
     */
    message1?: string;
}

/**
 * 
 * @export
 * @interface ImagesCarrierReturnWindow
 */
export interface ImagesCarrierReturnWindow {
    /**
     * 
     * @type {string}
     * @memberof ImagesCarrierReturnWindow
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface ImagesSignature
 */
export interface ImagesSignature {
    /**
     * 
     * @type {string}
     * @memberof ImagesSignature
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface InAppProvisioning
 */
export interface InAppProvisioning {
    /**
     * 
     * @type {boolean}
     * @memberof InAppProvisioning
     */
    enabled?: boolean;
    /**
     * 
     * @type {DigitalWalletTokenAddressVerification}
     * @memberof InAppProvisioning
     */
    addressVerification?: DigitalWalletTokenAddressVerification;
}

/**
 * 
 * @export
 * @interface InstallmentPayment
 */
export interface InstallmentPayment {
    /**
     * 
     * @type {string}
     * @memberof InstallmentPayment
     */
    currencyCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InstallmentPayment
     */
    frequency?: string;
    /**
     * 
     * @type {string}
     * @memberof InstallmentPayment
     */
    firstInstallmentDate?: string;
    /**
     * 
     * @type {number}
     * @memberof InstallmentPayment
     */
    totalAmountFunded?: number;
    /**
     * 
     * @type {string}
     * @memberof InstallmentPayment
     */
    paymentType?: string;
}

/**
 * 
 * @export
 * @interface InternalAccount
 */
export interface InternalAccount {
    /**
     * 
     * @type {number}
     * @memberof InternalAccount
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InternalAccount
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAccount
     */
    subclass: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalAccount
     */
    finalAccount?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InternalAccount
     */
    cardholderAccount?: boolean;
}

/**
 * 
 * @export
 * @interface InternalAddressVerificationRequest
 */
export interface InternalAddressVerificationRequest {
    /**
     * 
     * @type {boolean}
     * @memberof InternalAddressVerificationRequest
     */
    compressed?: boolean;
    /**
     * cardholder address
     * @type {string}
     * @memberof InternalAddressVerificationRequest
     */
    address?: string;
    /**
     * cardholder city
     * @type {string}
     * @memberof InternalAddressVerificationRequest
     */
    city?: string;
    /**
     * cardholder state
     * @type {string}
     * @memberof InternalAddressVerificationRequest
     */
    state?: string;
    /**
     * cardholder country
     * @type {string}
     * @memberof InternalAddressVerificationRequest
     */
    country?: string;
    /**
     * cardholder postalcode
     * @type {string}
     * @memberof InternalAddressVerificationRequest
     */
    postalcode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalAddressVerificationRequest
     */
    isCompressed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalAddressVerificationRequest
     */
    cardholderName?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAddressVerificationRequest
     */
    configProviderType?: InternalAddressVerificationRequest.ConfigProviderTypeEnum;
}

/**
 * @export
 * @namespace InternalAddressVerificationRequest
 */
export namespace InternalAddressVerificationRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ConfigProviderTypeEnum {
        AUTH = <any> 'AUTH',
        DWT = <any> 'DWT',
        AV = <any> 'AV'
    }
}

/**
 * 
 * @export
 * @interface InternalAuthControlRequest
 */
export interface InternalAuthControlRequest {
    /**
     * 
     * @type {InternalCard}
     * @memberof InternalAuthControlRequest
     */
    card: InternalCard;
    /**
     * 
     * @type {InternalUser}
     * @memberof InternalAuthControlRequest
     */
    cardholder: InternalUser;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthControlRequest
     */
    mid?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthControlRequest
     */
    mcc?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InternalAuthControlRequest
     */
    mccGroups?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthControlRequest
     */
    controlsIndicator: InternalAuthControlRequest.ControlsIndicatorEnum;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthControlRequest
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthControlRequest
     */
    itc?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthControlRequest
     */
    businessApplicationIdentifier?: string;
}

/**
 * @export
 * @namespace InternalAuthControlRequest
 */
export namespace InternalAuthControlRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ControlsIndicatorEnum {
        LOAD = <any> 'LOAD',
        SPEND = <any> 'SPEND'
    }
}

/**
 * 
 * @export
 * @interface InternalAuthorizationTransaction
 */
export interface InternalAuthorizationTransaction {
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    returnedBalances?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    tags?: string;
    /**
     * 
     * @type {Array<NetworkFeeModel>}
     * @memberof InternalAuthorizationTransaction
     */
    feesModel?: Array<NetworkFeeModel>;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    transactionType: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    token: string;
    /**
     * 
     * @type {InternalAuthorizationTransaction}
     * @memberof InternalAuthorizationTransaction
     */
    refTransaction?: InternalAuthorizationTransaction;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    node: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    network: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    subNetwork: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    mid?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    tid?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    stan?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    caName?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    caStreet?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    caZip?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    caCity?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    caRegion?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    caCountry?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    functionCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    reasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    responseCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    approvalNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    displayMessage?: string;
    /**
     * 
     * @type {Date}
     * @memberof InternalAuthorizationTransaction
     */
    date?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InternalAuthorizationTransaction
     */
    transmissionDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InternalAuthorizationTransaction
     */
    localTransactionDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InternalAuthorizationTransaction
     */
    captureDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InternalAuthorizationTransaction
     */
    settlementDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    itc?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    irc?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    currencyCode?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalAuthorizationTransaction
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalAuthorizationTransaction
     */
    additionalAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalAuthorizationTransaction
     */
    acquirerFee?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalAuthorizationTransaction
     */
    issuerFee?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    rc?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    extrc?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalAuthorizationTransaction
     */
    duration?: number;
    /**
     * 
     * @type {InternalUser}
     * @memberof InternalAuthorizationTransaction
     */
    cardholder?: InternalUser;
    /**
     * 
     * @type {InternalUser}
     * @memberof InternalAuthorizationTransaction
     */
    actingCardholder?: InternalUser;
    /**
     * 
     * @type {InternalCard}
     * @memberof InternalAuthorizationTransaction
     */
    card?: InternalCard;
    /**
     * 
     * @type {InternalAccount}
     * @memberof InternalAuthorizationTransaction
     */
    account?: InternalAccount;
    /**
     * 
     * @type {InternalAccount}
     * @memberof InternalAuthorizationTransaction
     */
    account2?: InternalAccount;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    mcc?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    networkReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    acquirerReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    retrievalReferenceNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    forwardingInstId?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    networkMid?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalAuthorizationTransaction
     */
    requestAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    transactionState?: InternalAuthorizationTransaction.TransactionStateEnum;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    remoteHost?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalAuthorizationTransaction
     */
    responseAmount?: number;
    /**
     * 
     * @type {Date}
     * @memberof InternalAuthorizationTransaction
     */
    expirationTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    incomingNetworkRequestITC?: string;
    /**
     * 
     * @type {InternalDigitalWallet}
     * @memberof InternalAuthorizationTransaction
     */
    digitalWalletToken?: InternalDigitalWallet;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalAuthorizationTransaction
     */
    tranlogAttributes?: { [key: string]: string; };
    /**
     * 
     * @type {TransactionModel}
     * @memberof InternalAuthorizationTransaction
     */
    payload?: TransactionModel;
    /**
     * 
     * @type {number}
     * @memberof InternalAuthorizationTransaction
     */
    layer?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    transactionName?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    originator?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalAuthorizationTransaction
     */
    acquirer?: string;
}

/**
 * @export
 * @namespace InternalAuthorizationTransaction
 */
export namespace InternalAuthorizationTransaction {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionStateEnum {
        PENDING = <any> 'PENDING',
        CLEARED = <any> 'CLEARED',
        COMPLETION = <any> 'COMPLETION',
        DECLINED = <any> 'DECLINED',
        ERROR = <any> 'ERROR',
        ALL = <any> 'ALL'
    }
}

/**
 * 
 * @export
 * @interface InternalCard
 */
export interface InternalCard {
    /**
     * 
     * @type {string}
     * @memberof InternalCard
     */
    hash?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalCard
     */
    kid?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalCard
     */
    secureData?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalCard
     */
    serviceCode?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalCard
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InternalCard
     */
    token: string;
    /**
     * 
     * @type {InternalUser}
     * @memberof InternalCard
     */
    user: InternalUser;
    /**
     * 
     * @type {InternalCardProduct}
     * @memberof InternalCard
     */
    cardProduct: InternalCardProduct;
    /**
     * 
     * @type {string}
     * @memberof InternalCard
     */
    lastFour: string;
    /**
     * 
     * @type {Date}
     * @memberof InternalCard
     */
    expirationTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof InternalCard
     */
    state?: InternalCard.StateEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalCard
     */
    metadata?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof InternalCard
     */
    cardPinBlock?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalCard
     */
    contactlessConsecutiveTotalSpend?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalCard
     */
    contactlessConsecutiveCount?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalCard
     */
    lvpConsecutiveTotalSpend?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalCard
     */
    lvpConsecutiveCount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InternalCard
     */
    isOfflinePinSetRequired?: boolean;
}

/**
 * @export
 * @namespace InternalCard
 */
export namespace InternalCard {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        TERMINATED = <any> 'TERMINATED',
        UNSUPPORTED = <any> 'UNSUPPORTED',
        UNACTIVATED = <any> 'UNACTIVATED',
        LIMITED = <any> 'LIMITED'
    }
}

/**
 * 
 * @export
 * @interface InternalCardProduct
 */
export interface InternalCardProduct {
    /**
     * 
     * @type {string}
     * @memberof InternalCardProduct
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalCardProduct
     */
    id?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalCardProduct
     */
    cardProductConfig?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface InternalConfigsRequest
 */
export interface InternalConfigsRequest {
    /**
     * 
     * @type {string}
     * @memberof InternalConfigsRequest
     */
    cardProductToken?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InternalConfigsRequest
     */
    cardProductConfigs?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InternalConfigsRequest
     */
    sysConfigNames?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InternalConfigsRequest
     */
    sysConfigGroups?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InternalConfigsRequest
     */
    dnaConfigs?: Array<string>;
}

/**
 * 
 * @export
 * @interface InternalConfigsResponse
 */
export interface InternalConfigsResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalConfigsResponse
     */
    dna?: { [key: string]: string; };
    /**
     * 
     * @type {InternalCardProduct}
     * @memberof InternalConfigsResponse
     */
    cardProduct?: InternalCardProduct;
    /**
     * 
     * @type {Array<InternalSysConfig>}
     * @memberof InternalConfigsResponse
     */
    systemConfig?: Array<InternalSysConfig>;
}

/**
 * 
 * @export
 * @interface InternalCryptoKey
 */
export interface InternalCryptoKey {
    /**
     * 
     * @type {string}
     * @memberof InternalCryptoKey
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalCryptoKey
     */
    keyType?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalCryptoKey
     */
    keyValue?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalCryptoKey
     */
    keyIndicator?: string;
    /**
     * 
     * @type {Date}
     * @memberof InternalCryptoKey
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InternalCryptoKey
     */
    modifiedTime?: Date;
}

/**
 * 
 * @export
 * @interface InternalCryptoKeyRequest
 */
export interface InternalCryptoKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof InternalCryptoKeyRequest
     */
    network: string;
    /**
     * 
     * @type {string}
     * @memberof InternalCryptoKeyRequest
     */
    provider: string;
    /**
     * 
     * @type {string}
     * @memberof InternalCryptoKeyRequest
     */
    keyType: InternalCryptoKeyRequest.KeyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InternalCryptoKeyRequest
     */
    keyValue: string;
}

/**
 * @export
 * @namespace InternalCryptoKeyRequest
 */
export namespace InternalCryptoKeyRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum KeyTypeEnum {
        LMK = <any> 'LMK',
        ZMK = <any> 'ZMK',
        ZPK = <any> 'ZPK',
        WSDZEKINAPPPROV = <any> 'WSD_ZEK_INAPP_PROV',
        WSDZEKAPI = <any> 'WSD_ZEK_API',
        PVK = <any> 'PVK',
        CVK = <any> 'CVK',
        EMVMKAC = <any> 'EMV_MK_AC',
        EMVMKSMI = <any> 'EMV_MK_SMI',
        EMVMKSMC = <any> 'EMV_MK_SMC',
        EMVMKDAC = <any> 'EMV_MK_DAC',
        MKCVC3 = <any> 'MK_CVC3',
        CAVV = <any> 'CAVV',
        NOTAPPLICABLE = <any> 'NOT_APPLICABLE'
    }
}

/**
 * 
 * @export
 * @interface InternalCryptoKeyRequestModel
 */
export interface InternalCryptoKeyRequestModel {
    /**
     * A list of 'internal crypto key' items
     * @type {Array<InternalCryptoKeyRequest>}
     * @memberof InternalCryptoKeyRequestModel
     */
    cryptoKeys: Array<InternalCryptoKeyRequest>;
}

/**
 * 
 * @export
 * @interface InternalCryptoKeyResponse
 */
export interface InternalCryptoKeyResponse {
    /**
     * 
     * @type {string}
     * @memberof InternalCryptoKeyResponse
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalCryptoKeyResponse
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalCryptoKeyResponse
     */
    keyType?: InternalCryptoKeyResponse.KeyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof InternalCryptoKeyResponse
     */
    keyValue?: string;
    /**
     * 
     * @type {Date}
     * @memberof InternalCryptoKeyResponse
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InternalCryptoKeyResponse
     */
    updatedDate?: Date;
}

/**
 * @export
 * @namespace InternalCryptoKeyResponse
 */
export namespace InternalCryptoKeyResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum KeyTypeEnum {
        LMK = <any> 'LMK',
        ZMK = <any> 'ZMK',
        ZPK = <any> 'ZPK',
        WSDZEKINAPPPROV = <any> 'WSD_ZEK_INAPP_PROV',
        WSDZEKAPI = <any> 'WSD_ZEK_API',
        PVK = <any> 'PVK',
        CVK = <any> 'CVK',
        EMVMKAC = <any> 'EMV_MK_AC',
        EMVMKSMI = <any> 'EMV_MK_SMI',
        EMVMKSMC = <any> 'EMV_MK_SMC',
        EMVMKDAC = <any> 'EMV_MK_DAC',
        MKCVC3 = <any> 'MK_CVC3',
        CAVV = <any> 'CAVV',
        NOTAPPLICABLE = <any> 'NOT_APPLICABLE'
    }
}

/**
 * 
 * @export
 * @interface InternalDepositAccountInformation
 */
export interface InternalDepositAccountInformation {
    /**
     * 
     * @type {Array<string>}
     * @memberof InternalDepositAccountInformation
     */
    bankAcctNumbers?: Array<string>;
}

/**
 * 
 * @export
 * @interface InternalDigitalWallet
 */
export interface InternalDigitalWallet {
    /**
     * 
     * @type {number}
     * @memberof InternalDigitalWallet
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalDigitalWallet
     */
    token?: string;
    /**
     * 
     * @type {InternalCard}
     * @memberof InternalDigitalWallet
     */
    card?: InternalCard;
    /**
     * 
     * @type {string}
     * @memberof InternalDigitalWallet
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalDigitalWallet
     */
    stateReason?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalDigitalWallet
     */
    fulfillmentStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalDigitalWallet
     */
    issuerEligibilityDecision?: string;
    /**
     * 
     * @type {Date}
     * @memberof InternalDigitalWallet
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InternalDigitalWallet
     */
    lastModifiedTime?: Date;
    /**
     * 
     * @type {TokenServiceProvider}
     * @memberof InternalDigitalWallet
     */
    tokenServiceProvider?: TokenServiceProvider;
    /**
     * 
     * @type {Device}
     * @memberof InternalDigitalWallet
     */
    device?: Device;
    /**
     * 
     * @type {WalletProviderProfile}
     * @memberof InternalDigitalWallet
     */
    walletProviderProfile?: WalletProviderProfile;
    /**
     * 
     * @type {AddressVerification}
     * @memberof InternalDigitalWallet
     */
    addressVerification?: AddressVerification;
    /**
     * 
     * @type {Response}
     * @memberof InternalDigitalWallet
     */
    response?: Response;
}

/**
 * 
 * @export
 * @interface InternalDigitalWalletToken
 */
export interface InternalDigitalWalletToken {
    /**
     * 
     * @type {boolean}
     * @memberof InternalDigitalWalletToken
     */
    isDigitalWalletTransaction?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalDigitalWalletToken
     */
    panSource?: string;
}

/**
 * 
 * @export
 * @interface InternalFindOriginalRequest
 */
export interface InternalFindOriginalRequest {
    /**
     * 
     * @type {InternalAuthorizationTransaction}
     * @memberof InternalFindOriginalRequest
     */
    authorizationTranlog: InternalAuthorizationTransaction;
    /**
     * 
     * @type {number}
     * @memberof InternalFindOriginalRequest
     */
    overrideDays?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof InternalFindOriginalRequest
     */
    context?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalFindOriginalRequest
     */
    configuration?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof InternalFindOriginalRequest
     */
    finders?: Array<InternalFindOriginalRequest.FindersEnum>;
    /**
     * 
     * @type {Date}
     * @memberof InternalFindOriginalRequest
     */
    originalTimestamp?: Date;
    /**
     * 
     * @type {string}
     * @memberof InternalFindOriginalRequest
     */
    originalStan?: string;
}

/**
 * @export
 * @namespace InternalFindOriginalRequest
 */
export namespace InternalFindOriginalRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum FindersEnum {
        AMOUNTLOCALTXNDATE = <any> 'AMOUNT_LOCAL_TXN_DATE',
        APPROVALCODERRN = <any> 'APPROVAL_CODE_RRN',
        APPROVALCODESTAN = <any> 'APPROVAL_CODE_STAN',
        APPROVALCODESTANLOCALTXNDATE = <any> 'APPROVAL_CODE_STAN_LOCAL_TXN_DATE',
        APPROVALCODECARDHOLDERAMOUNT = <any> 'APPROVAL_CODE_CARDHOLDER_AMOUNT',
        CHARGEBACKNREF = <any> 'CHARGEBACK_NREF_',
        EXPIRABLEAUTHDIGEST = <any> 'EXPIRABLE_AUTH_DIGEST',
        LOCALTXNDATEMIDAMOUNT = <any> 'LOCAL_TXN_DATE_MID_AMOUNT',
        LOCALTXNDATEMIDAMOUNTTIP = <any> 'LOCAL_TXN_DATE_MID_AMOUNT_TIP',
        MODLOCALTXNDATEMIDAMOUNTTIP = <any> 'MOD_LOCAL_TXN_DATE_MID_AMOUNT_TIP',
        MOSTRECENTCHARGEBACKTXN = <any> 'MOST_RECENT_CHARGEBACK_TXN',
        NRIDEXCEPTPULSE = <any> 'NRID_EXCEPT_PULSE',
        NRID = <any> 'NRID',
        NULLRESULT = <any> 'NULL_RESULT',
        PULSESTANRRN = <any> 'PULSE_STAN_RRN',
        RRNEXCEPTPULSE = <any> 'RRN_EXCEPT_PULSE',
        RRN = <any> 'RRN',
        TXNTOKEN = <any> 'TXN_TOKEN'
    }
}

/**
 * 
 * @export
 * @interface InternalFindOriginalResponse
 */
export interface InternalFindOriginalResponse {
    /**
     * 
     * @type {boolean}
     * @memberof InternalFindOriginalResponse
     */
    originalFound?: boolean;
    /**
     * 
     * @type {InternalAuthorizationTransaction}
     * @memberof InternalFindOriginalResponse
     */
    originalTranlog?: InternalAuthorizationTransaction;
    /**
     * 
     * @type {FundingTranlog}
     * @memberof InternalFindOriginalResponse
     */
    fundingTransaction?: FundingTranlog;
    /**
     * 
     * @type {string}
     * @memberof InternalFindOriginalResponse
     */
    finderName?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalFindOriginalResponse
     */
    context?: { [key: string]: string; };
    /**
     * 
     * @type {Response}
     * @memberof InternalFindOriginalResponse
     */
    response?: Response;
}

/**
 * 
 * @export
 * @interface InternalFundingSource
 */
export interface InternalFundingSource {
    /**
     * 
     * @type {string}
     * @memberof InternalFundingSource
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalFundingSource
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalFundingSource
     */
    account?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalFundingSource
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalFundingSource
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalFundingSource
     */
    token: string;
    /**
     * 
     * @type {Date}
     * @memberof InternalFundingSource
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InternalFundingSource
     */
    lastModifiedTime?: Date;
    /**
     * 
     * @type {InternalAccount}
     * @memberof InternalFundingSource
     */
    debitAccount?: InternalAccount;
    /**
     * 
     * @type {boolean}
     * @memberof InternalFundingSource
     */
    isDefaultAccount?: boolean;
}

/**
 * 
 * @export
 * @interface InternalGPAOrder
 */
export interface InternalGPAOrder {
    /**
     * 
     * @type {string}
     * @memberof InternalGPAOrder
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGPAOrder
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGPAOrder
     */
    token: string;
    /**
     * 
     * @type {number}
     * @memberof InternalGPAOrder
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof InternalGPAOrder
     */
    currency?: string;
    /**
     * 
     * @type {InternalFundingSource}
     * @memberof InternalGPAOrder
     */
    fundingSource?: InternalFundingSource;
    /**
     * 
     * @type {string}
     * @memberof InternalGPAOrder
     */
    originalOrderId?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGPAOrder
     */
    orderType?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGPAOrder
     */
    orderState?: InternalGPAOrder.OrderStateEnum;
    /**
     * 
     * @type {string}
     * @memberof InternalGPAOrder
     */
    responseCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGPAOrder
     */
    responseMemo?: string;
    /**
     * 
     * @type {Date}
     * @memberof InternalGPAOrder
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof InternalGPAOrder
     */
    lastModifiedTime?: Date;
}

/**
 * @export
 * @namespace InternalGPAOrder
 */
export namespace InternalGPAOrder {
    /**
     * @export
     * @enum {string}
     */
    export enum OrderStateEnum {
        PENDING = <any> 'PENDING',
        REVERSED = <any> 'REVERSED',
        CLEARED = <any> 'CLEARED',
        COMPLETION = <any> 'COMPLETION',
        DECLINED = <any> 'DECLINED',
        ERROR = <any> 'ERROR'
    }
}

/**
 * 
 * @export
 * @interface InternalGatewayLog
 */
export interface InternalGatewayLog {
    /**
     * 
     * @type {InternalGatewayMerchant}
     * @memberof InternalGatewayLog
     */
    gatewayMerchant?: InternalGatewayMerchant;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayLog
     */
    orderId?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayLog
     */
    requestMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayLog
     */
    gatewayRequestMethod?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayLog
     */
    responseCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayLog
     */
    responseSubCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayLog
     */
    responseReasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayLog
     */
    responseMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayLog
     */
    gatewayResponseMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayLog
     */
    responseStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayLog
     */
    gatewayTransactionId?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalGatewayLog
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalGatewayLog
     */
    apiDuration?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalGatewayLog
     */
    gatewayDuration?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayLog
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayLog
     */
    gatewayVersion?: string;
    /**
     * 
     * @type {InternalFundingSource}
     * @memberof InternalGatewayLog
     */
    fundingSource: InternalFundingSource;
    /**
     * 
     * @type {InternalUser}
     * @memberof InternalGatewayLog
     */
    internalUser?: InternalUser;
    /**
     * 
     * @type {NetworkMetadata}
     * @memberof InternalGatewayLog
     */
    networkMetadata?: NetworkMetadata;
}

/**
 * 
 * @export
 * @interface InternalGatewayMerchant
 */
export interface InternalGatewayMerchant {
    /**
     * 
     * @type {number}
     * @memberof InternalGatewayMerchant
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InternalGatewayMerchant
     */
    token: string;
}

/**
 * 
 * @export
 * @interface InternalGatewayResponse
 */
export interface InternalGatewayResponse {
    /**
     * 
     * @type {InternalGatewayLog}
     * @memberof InternalGatewayResponse
     */
    exception: InternalGatewayLog;
    /**
     * 
     * @type {boolean}
     * @memberof InternalGatewayResponse
     */
    successfulGatewayCall: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InternalGatewayResponse
     */
    approved: boolean;
}

/**
 * 
 * @export
 * @interface InternalNetworkTransactionRequest
 */
export interface InternalNetworkTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof InternalNetworkTransactionRequest
     */
    token: string;
    /**
     * Encryption key ID
     * @type {string}
     * @memberof InternalNetworkTransactionRequest
     */
    encryptionKeyId?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalNetworkTransactionRequest
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InternalNetworkTransactionRequest
     */
    network: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalNetworkTransactionRequest
     */
    debit: boolean;
    /**
     * 
     * @type {number}
     * @memberof InternalNetworkTransactionRequest
     */
    retryCount?: number;
}

/**
 * 
 * @export
 * @interface InternalSysConfig
 */
export interface InternalSysConfig {
    /**
     * 
     * @type {string}
     * @memberof InternalSysConfig
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalSysConfig
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalSysConfig
     */
    group?: string;
}

/**
 * 
 * @export
 * @interface InternalTransactionDataModel
 */
export interface InternalTransactionDataModel {
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionDataModel
     */
    pcode?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalTransactionDataModel
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalTransactionDataModel
     */
    requestAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalTransactionDataModel
     */
    additionalAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalTransactionDataModel
     */
    acquirerFee?: number;
    /**
     * 
     * @type {number}
     * @memberof InternalTransactionDataModel
     */
    refid?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionDataModel
     */
    refItc?: string;
    /**
     * 
     * @type {number}
     * @memberof InternalTransactionDataModel
     */
    account2Id?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionDataModel
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionDataModel
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionDataModel
     */
    settlementCurrency?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionDataModel
     */
    paymentChannel?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionDataModel
     */
    itc?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionDataModel
     */
    processingCode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalTransactionDataModel
     */
    isTrackDataPresent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InternalTransactionDataModel
     */
    isCvv2Present?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InternalTransactionDataModel
     */
    isCavvDataPresent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionDataModel
     */
    cavvResultCode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalTransactionDataModel
     */
    isIccPresent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InternalTransactionDataModel
     */
    isPinPresent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionDataModel
     */
    panEntryMode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalTransactionDataModel
     */
    isCardholderPresent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InternalTransactionDataModel
     */
    isCardPresent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionDataModel
     */
    mcc?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionDataModel
     */
    mid?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InternalTransactionDataModel
     */
    attributes?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface InternalTransactionMessage
 */
export interface InternalTransactionMessage {
    /**
     * 
     * @type {number}
     * @memberof InternalTransactionMessage
     */
    processingStartTimeMillis?: number;
    /**
     * 
     * @type {InternalAuthorizationTransaction}
     * @memberof InternalTransactionMessage
     */
    authorizationTranlog: InternalAuthorizationTransaction;
    /**
     * 
     * @type {FundingTranlog}
     * @memberof InternalTransactionMessage
     */
    fundingTranlog?: FundingTranlog;
    /**
     * 
     * @type {Array<VelocityCache>}
     * @memberof InternalTransactionMessage
     */
    velocityCaches?: Array<VelocityCache>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof InternalTransactionMessage
     */
    context?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof InternalTransactionMessage
     */
    creditDebitIndicator?: InternalTransactionMessage.CreditDebitIndicatorEnum;
}

/**
 * @export
 * @namespace InternalTransactionMessage
 */
export namespace InternalTransactionMessage {
    /**
     * @export
     * @enum {string}
     */
    export enum CreditDebitIndicatorEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT',
        NONE = <any> 'NONE'
    }
}

/**
 * 
 * @export
 * @interface InternalTransactionResponse
 */
export interface InternalTransactionResponse {
    /**
     * 
     * @type {Response}
     * @memberof InternalTransactionResponse
     */
    response?: Response;
}

/**
 * 
 * @export
 * @interface InternalUser
 */
export interface InternalUser {
    /**
     * 
     * @type {number}
     * @memberof InternalUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InternalUser
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalUser
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InternalUser
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalUser
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InternalUser
     */
    usesParentAccount?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InternalUser
     */
    corporateCardHolder?: boolean;
    /**
     * 
     * @type {Array<InternalAccount>}
     * @memberof InternalUser
     */
    userAccounts?: Array<InternalAccount>;
}

/**
 * 
 * @export
 * @interface InternalUserTransactionRequest
 */
export interface InternalUserTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof InternalUserTransactionRequest
     */
    token: string;
    /**
     * 
     * @type {InternalCard}
     * @memberof InternalUserTransactionRequest
     */
    card: InternalCard;
    /**
     * 
     * @type {string}
     * @memberof InternalUserTransactionRequest
     */
    digitalWalletToken?: string;
    /**
     * 
     * @type {Transaction}
     * @memberof InternalUserTransactionRequest
     */
    transaction?: Transaction;
}

/**
 * 
 * @export
 * @interface Iso8583DigitalWalletToken
 */
export interface Iso8583DigitalWalletToken {
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    tokenPan?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    tokenAssuranceLevel?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    tokenRequestorId?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    tokenReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    correlationId?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    tokenExpiryDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    tokenType?: Iso8583DigitalWalletToken.TokenTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    tokenStatus?: Iso8583DigitalWalletToken.TokenStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    panReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    networkTokenScore?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    networkDecisioning?: Iso8583DigitalWalletToken.NetworkDecisioningEnum;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    numberOfActiveTokens?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    numberOfInactiveTokens?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    numberOfSuspendedTokens?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso8583DigitalWalletToken
     */
    issuerTermsAndCondition?: string;
    /**
     * yyyy-MM-dd, yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof Iso8583DigitalWalletToken
     */
    issuerTermsAndConditionDate?: Date;
    /**
     * 
     * @type {number}
     * @memberof Iso8583DigitalWalletToken
     */
    elapsedTimeToLive?: number;
    /**
     * 
     * @type {number}
     * @memberof Iso8583DigitalWalletToken
     */
    numberOfTransactions?: number;
    /**
     * 
     * @type {number}
     * @memberof Iso8583DigitalWalletToken
     */
    cumulativeTransactionAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof Iso8583DigitalWalletToken
     */
    numberOfActivationAttempts?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Iso8583DigitalWalletToken
     */
    visaAutoFillIndicator?: boolean;
}

/**
 * @export
 * @namespace Iso8583DigitalWalletToken
 */
export namespace Iso8583DigitalWalletToken {
    /**
     * @export
     * @enum {string}
     */
    export enum TokenTypeEnum {
        DEVICESECUREELEMENT = <any> 'DEVICE_SECURE_ELEMENT',
        DEVICECLOUDBASED = <any> 'DEVICE_CLOUD_BASED',
        MERCHANTCARDONFILE = <any> 'MERCHANT_CARD_ON_FILE',
        ECOMMERCEDIGITALWALLET = <any> 'ECOMMERCE_DIGITAL_WALLET',
        PSEUDOACCOUNT = <any> 'PSEUDO_ACCOUNT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TokenStatusEnum {
        REQUESTED = <any> 'REQUESTED',
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        TERMINATED = <any> 'TERMINATED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NetworkDecisioningEnum {
        GREEN = <any> 'DECISION_GREEN',
        YELLOW = <any> 'DECISION_YELLOW',
        RED = <any> 'DECISION_RED'
    }
}

/**
 * 
 * @export
 * @interface Issuer
 */
export interface Issuer {
    /**
     * 
     * @type {boolean}
     * @memberof Issuer
     */
    success?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Issuer
     */
    fraudScore?: number;
    /**
     * 
     * @type {string}
     * @memberof Issuer
     */
    fraudRating?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Issuer
     */
    ruleViolations?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Issuer
     */
    fraudScoreReasons?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Issuer
     */
    recommendedAction?: string;
    /**
     * 
     * @type {string}
     * @memberof Issuer
     */
    model?: string;
    /**
     * 
     * @type {string}
     * @memberof Issuer
     */
    message?: string;
    /**
     * 
     * @type {Array<RiskcontrolTags>}
     * @memberof Issuer
     */
    riskcontrolTags?: Array<RiskcontrolTags>;
    /**
     * 
     * @type {Array<TriggeredRule>}
     * @memberof Issuer
     */
    triggeredRules?: Array<TriggeredRule>;
}

/**
 * 
 * @export
 * @interface IssuerFraudView
 */
export interface IssuerFraudView {
    /**
     * 
     * @type {number}
     * @memberof IssuerFraudView
     */
    score?: number;
    /**
     * 
     * @type {string}
     * @memberof IssuerFraudView
     */
    riskLevel?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof IssuerFraudView
     */
    ruleViolations?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IssuerFraudView
     */
    recommendedAction?: string;
    /**
     * 
     * @type {Array<RiskcontrolTags>}
     * @memberof IssuerFraudView
     */
    riskcontrolTags?: Array<RiskcontrolTags>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IssuerFraudView
     */
    fraudScoreReasons?: Array<string>;
    /**
     * 
     * @type {Array<TriggeredRule>}
     * @memberof IssuerFraudView
     */
    triggeredRules?: Array<TriggeredRule>;
}

/**
 * 
 * @export
 * @interface JitAddressVerification
 */
export interface JitAddressVerification {
    /**
     * 
     * @type {AvsInformation}
     * @memberof JitAddressVerification
     */
    request?: AvsInformation;
    /**
     * 
     * @type {AddressVerificationSource}
     * @memberof JitAddressVerification
     */
    issuer?: AddressVerificationSource;
    /**
     * 
     * @type {AddressVerificationSource}
     * @memberof JitAddressVerification
     */
    gateway?: AddressVerificationSource;
}

/**
 * 
 * @export
 * @interface JitFunding
 */
export interface JitFunding {
    /**
     * 
     * @type {JitFundingPaymentcardFundingSource}
     * @memberof JitFunding
     */
    paymentcardFundingSource?: JitFundingPaymentcardFundingSource;
    /**
     * 
     * @type {JitFundingProgramgatewayFundingSource}
     * @memberof JitFunding
     */
    programgatewayFundingSource?: JitFundingProgramgatewayFundingSource;
    /**
     * 
     * @type {JitFundingProgramFundingSource}
     * @memberof JitFunding
     */
    programFundingSource?: JitFundingProgramFundingSource;
}

/**
 * 
 * @export
 * @interface JitFundingApi
 */
export interface JitFundingApi {
    /**
     * 
     * @type {string}
     * @memberof JitFundingApi
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof JitFundingApi
     */
    method: JitFundingApi.MethodEnum;
    /**
     * 
     * @type {string}
     * @memberof JitFundingApi
     */
    userToken: string;
    /**
     * 
     * @type {string}
     * @memberof JitFundingApi
     */
    actingUserToken?: string;
    /**
     * 
     * @type {string}
     * @memberof JitFundingApi
     */
    businessToken?: string;
    /**
     * 
     * @type {number}
     * @memberof JitFundingApi
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof JitFundingApi
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof JitFundingApi
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof JitFundingApi
     */
    originalJitFundingToken?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof JitFundingApi
     */
    incrementalAuthorizationJitFundingTokens?: Array<string>;
    /**
     * 
     * @type {JitAddressVerification}
     * @memberof JitFundingApi
     */
    addressVerification?: JitAddressVerification;
    /**
     * 
     * @type {string}
     * @memberof JitFundingApi
     */
    declineReason?: JitFundingApi.DeclineReasonEnum;
    /**
     * 
     * @type {{ [key: string]: CardholderBalance; }}
     * @memberof JitFundingApi
     */
    balances?: { [key: string]: CardholderBalance; };
}

/**
 * @export
 * @namespace JitFundingApi
 */
export namespace JitFundingApi {
    /**
     * @export
     * @enum {string}
     */
    export enum MethodEnum {
        Authorization = <any> 'pgfs.authorization',
        Balanceinquiry = <any> 'pgfs.balanceinquiry',
        AuthorizationIncremental = <any> 'pgfs.authorization.incremental',
        AuthorizationCapture = <any> 'pgfs.authorization.capture',
        AuthorizationReversal = <any> 'pgfs.authorization.reversal',
        AuthPlusCapture = <any> 'pgfs.auth_plus_capture',
        Refund = <any> 'pgfs.refund',
        ForceCapture = <any> 'pgfs.force_capture',
        AuthorizationCaptureChargeback = <any> 'pgfs.authorization.capture.chargeback',
        AuthorizationCaptureChargebackReversal = <any> 'pgfs.authorization.capture.chargeback.reversal',
        PindebitChargeback = <any> 'pgfs.pindebit.chargeback',
        PindebitChargebackReversal = <any> 'pgfs.pindebit.chargeback.reversal',
        DisputeCredit = <any> 'pgfs.dispute.credit',
        DisputeDebit = <any> 'pgfs.dispute.debit',
        DirectdepositCredit = <any> 'pgfs.directdeposit.credit',
        DirectdepositDebit = <any> 'pgfs.directdeposit.debit',
        DirectdepositCreditReversal = <any> 'pgfs.directdeposit.credit.reversal',
        DirectdepositDebitReversal = <any> 'pgfs.directdeposit.debit.reversal',
        AdjustmentCredit = <any> 'pgfs.adjustment.credit',
        AdjustmentDebit = <any> 'pgfs.adjustment.debit',
        AuthPlusCaptureStandin = <any> 'pgfs.auth_plus_capture.standin',
        AuthorizationStandin = <any> 'pgfs.authorization.standin',
        NetworkLoad = <any> 'pgfs.network.load',
        OriginalCreditAuthorization = <any> 'pgfs.original.credit.authorization',
        OriginalCreditAuthPlusCapture = <any> 'pgfs.original.credit.auth_plus_capture',
        RefundAuthorization = <any> 'pgfs.refund.authorization',
        RefundAuthorizationReversalpgfsBillpayment = <any> 'pgfs.refund.authorization.reversalpgfs.billpayment',
        BillpaymentCapture = <any> 'pgfs.billpayment.capture',
        BillpaymentReversal = <any> 'pgfs.billpayment.reversal',
        AuthorizationAccountVerification = <any> 'pgfs.authorization.account_verification'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DeclineReasonEnum {
        INVALIDAMOUNT = <any> 'INVALID_AMOUNT',
        INSUFFICIENTFUNDS = <any> 'INSUFFICIENT_FUNDS',
        TRANSACTIONNOTPERMITTED = <any> 'TRANSACTION_NOT_PERMITTED',
        SUSPECTEDFRAUD = <any> 'SUSPECTED_FRAUD',
        AMOUNTLIMITEXCEEDED = <any> 'AMOUNT_LIMIT_EXCEEDED',
        TRANSACTIONCOUNTLIMITEXCEEDED = <any> 'TRANSACTION_COUNT_LIMIT_EXCEEDED',
        DUPLICATETRANSACTION = <any> 'DUPLICATE_TRANSACTION',
        INVALIDMERCHANT = <any> 'INVALID_MERCHANT',
        INVALIDCARD = <any> 'INVALID_CARD',
        NOCREDITACCOUNT = <any> 'NO_CREDIT_ACCOUNT',
        EXPIREDCARD = <any> 'EXPIRED_CARD',
        NOCHECKINGACCOUNT = <any> 'NO_CHECKING_ACCOUNT',
        NOSAVINGSACCOUNT = <any> 'NO_SAVINGS_ACCOUNT',
        STOPPAYMENT = <any> 'STOP_PAYMENT',
        REVOCATIONAUTHORIZATIONORDER = <any> 'REVOCATION_AUTHORIZATION_ORDER',
        REVOCATIONALLAUTHORIZATIONORDER = <any> 'REVOCATION_ALL_AUTHORIZATION_ORDER',
        SOFTDECLINEAUTHENTICATIONREQUIRED = <any> 'SOFT_DECLINE_AUTHENTICATION_REQUIRED',
        CLOSEDACCOUNT = <any> 'CLOSED_ACCOUNT',
        SOFTDECLINEPINREQUIRED = <any> 'SOFT_DECLINE_PIN_REQUIRED',
        CARDNOTACTIVE = <any> 'CARD_NOT_ACTIVE',
        CARDHOLDERNOTACTIVE = <any> 'CARDHOLDER_NOT_ACTIVE'
    }
}

/**
 * 
 * @export
 * @interface JitFundingPaymentcardFundingSource
 */
export interface JitFundingPaymentcardFundingSource {
    /**
     * 
     * @type {boolean}
     * @memberof JitFundingPaymentcardFundingSource
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JitFundingPaymentcardFundingSource
     */
    refundsDestination?: JitFundingPaymentcardFundingSource.RefundsDestinationEnum;
}

/**
 * @export
 * @namespace JitFundingPaymentcardFundingSource
 */
export namespace JitFundingPaymentcardFundingSource {
    /**
     * @export
     * @enum {string}
     */
    export enum RefundsDestinationEnum {
        GATEWAY = <any> 'GATEWAY',
        GPA = <any> 'GPA',
        WATERFALL = <any> 'WATERFALL'
    }
}

/**
 * 
 * @export
 * @interface JitFundingProgramFundingSource
 */
export interface JitFundingProgramFundingSource {
    /**
     * 
     * @type {boolean}
     * @memberof JitFundingProgramFundingSource
     */
    enabled?: boolean;
    /**
     * required if enabled
     * @type {string}
     * @memberof JitFundingProgramFundingSource
     */
    fundingSourceToken?: string;
    /**
     * 
     * @type {string}
     * @memberof JitFundingProgramFundingSource
     */
    refundsDestination?: JitFundingProgramFundingSource.RefundsDestinationEnum;
}

/**
 * @export
 * @namespace JitFundingProgramFundingSource
 */
export namespace JitFundingProgramFundingSource {
    /**
     * @export
     * @enum {string}
     */
    export enum RefundsDestinationEnum {
        PROGRAMFUNDINGSOURCE = <any> 'PROGRAM_FUNDING_SOURCE',
        GPA = <any> 'GPA',
        WATERFALL = <any> 'WATERFALL'
    }
}

/**
 * 
 * @export
 * @interface JitFundingProgramgatewayFundingSource
 */
export interface JitFundingProgramgatewayFundingSource {
    /**
     * 
     * @type {boolean}
     * @memberof JitFundingProgramgatewayFundingSource
     */
    enabled?: boolean;
    /**
     * Required if enabled
     * @type {string}
     * @memberof JitFundingProgramgatewayFundingSource
     */
    fundingSourceToken?: string;
    /**
     * 
     * @type {string}
     * @memberof JitFundingProgramgatewayFundingSource
     */
    refundsDestination?: JitFundingProgramgatewayFundingSource.RefundsDestinationEnum;
    /**
     * 
     * @type {boolean}
     * @memberof JitFundingProgramgatewayFundingSource
     */
    alwaysFund?: boolean;
}

/**
 * @export
 * @namespace JitFundingProgramgatewayFundingSource
 */
export namespace JitFundingProgramgatewayFundingSource {
    /**
     * @export
     * @enum {string}
     */
    export enum RefundsDestinationEnum {
        GATEWAY = <any> 'GATEWAY',
        GPA = <any> 'GPA',
        WATERFALL = <any> 'WATERFALL'
    }
}

/**
 * 
 * @export
 * @interface JitProgramResponse
 */
export interface JitProgramResponse {
    /**
     * 
     * @type {JitFundingApi}
     * @memberof JitProgramResponse
     */
    jitFunding: JitFundingApi;
    /**
     * 
     * @type {NetworkMetadata}
     * @memberof JitProgramResponse
     */
    networkMetadata?: NetworkMetadata;
}

/**
 * 
 * @export
 * @interface KYCListResponse
 */
export interface KYCListResponse {
    /**
     * 
     * @type {number}
     * @memberof KYCListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof KYCListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof KYCListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof KYCListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<KycResponse>}
     * @memberof KYCListResponse
     */
    data?: Array<KycResponse>;
}

/**
 * 
 * @export
 * @interface KYCSubmitAnswersRequestModel
 */
export interface KYCSubmitAnswersRequestModel {
    /**
     * 
     * @type {Array<KycAnswer>}
     * @memberof KYCSubmitAnswersRequestModel
     */
    answers: Array<KycAnswer>;
}

/**
 * 
 * @export
 * @interface KycAnswer
 */
export interface KycAnswer {
    /**
     * 
     * @type {string}
     * @memberof KycAnswer
     */
    answer?: string;
    /**
     * 
     * @type {string}
     * @memberof KycAnswer
     */
    key?: string;
}

/**
 * 
 * @export
 * @interface KycRequest
 */
export interface KycRequest {
    /**
     * 
     * @type {string}
     * @memberof KycRequest
     */
    notes?: string;
    /**
     * 
     * @type {string}
     * @memberof KycRequest
     */
    token?: string;
    /**
     * Required if 'business_token' is null
     * @type {string}
     * @memberof KycRequest
     */
    userToken?: string;
    /**
     * Required if 'user_token' is null
     * @type {string}
     * @memberof KycRequest
     */
    businessToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KycRequest
     */
    manualOverride?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KycRequest
     */
    referenceId?: string;
}

/**
 * 
 * @export
 * @interface KycResponse
 */
export interface KycResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof KycResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof KycResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof KycResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof KycResponse
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof KycResponse
     */
    businessToken?: string;
    /**
     * 
     * @type {Result}
     * @memberof KycResponse
     */
    result?: Result;
    /**
     * 
     * @type {boolean}
     * @memberof KycResponse
     */
    manualOverride?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KycResponse
     */
    notes?: string;
    /**
     * 
     * @type {string}
     * @memberof KycResponse
     */
    referenceId?: string;
}

/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    rel: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    method: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href: string;
}

/**
 * 
 * @export
 * @interface LinkedAccountBalanceResponse
 */
export interface LinkedAccountBalanceResponse {
    /**
     * 
     * @type {string}
     * @memberof LinkedAccountBalanceResponse
     */
    balanceIsoCurrencyCode?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkedAccountBalanceResponse
     */
    processorToken?: string;
    /**
     * 
     * @type {number}
     * @memberof LinkedAccountBalanceResponse
     */
    availableBalance?: number;
    /**
     * 
     * @type {number}
     * @memberof LinkedAccountBalanceResponse
     */
    accountBalance?: number;
    /**
     * 
     * @type {Date}
     * @memberof LinkedAccountBalanceResponse
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof LinkedAccountBalanceResponse
     */
    lastModifiedTime?: Date;
}

/**
 * 
 * @export
 * @interface LoadRuleListResponse
 */
export interface LoadRuleListResponse {
    /**
     * 
     * @type {number}
     * @memberof LoadRuleListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadRuleListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadRuleListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LoadRuleListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<LoadVelocityModel>}
     * @memberof LoadRuleListResponse
     */
    data?: Array<LoadVelocityModel>;
}

/**
 * 
 * @export
 * @interface LoadVelocityModel
 */
export interface LoadVelocityModel {
    /**
     * 
     * @type {string}
     * @memberof LoadVelocityModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof LoadVelocityModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof LoadVelocityModel
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof LoadVelocityModel
     */
    layers?: string;
    /**
     * 
     * @type {number}
     * @memberof LoadVelocityModel
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadVelocityModel
     */
    days?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LoadVelocityModel
     */
    active?: boolean;
}

/**
 * 
 * @export
 * @interface LoginRequestModel
 */
export interface LoginRequestModel {
    /**
     * 
     * @type {string}
     * @memberof LoginRequestModel
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequestModel
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequestModel
     */
    userToken?: string;
}

/**
 * 
 * @export
 * @interface LoginResponseModel
 */
export interface LoginResponseModel {
    /**
     * 
     * @type {AccessTokenResponse}
     * @memberof LoginResponseModel
     */
    accessToken?: AccessTokenResponse;
    /**
     * 
     * @type {UserCardHolderResponse}
     * @memberof LoginResponseModel
     */
    user?: UserCardHolderResponse;
}

/**
 * 
 * @export
 * @interface MCCConfig
 */
export interface MCCConfig {
    /**
     * 
     * @type {AuthControls}
     * @memberof MCCConfig
     */
    authorizationControls?: AuthControls;
}

/**
 * 
 * @export
 * @interface MCCGroupListResponse
 */
export interface MCCGroupListResponse {
    /**
     * 
     * @type {number}
     * @memberof MCCGroupListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof MCCGroupListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof MCCGroupListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MCCGroupListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<MccGroupModel>}
     * @memberof MCCGroupListResponse
     */
    data?: Array<MccGroupModel>;
}

/**
 * 
 * @export
 * @interface MSA
 */
export interface MSA {
    /**
     * 
     * @type {string}
     * @memberof MSA
     */
    campaignToken: string;
    /**
     * 
     * @type {number}
     * @memberof MSA
     */
    triggerAmount: number;
    /**
     * 
     * @type {number}
     * @memberof MSA
     */
    reloadAmount: number;
}

/**
 * 
 * @export
 * @interface ManualEntry
 */
export interface ManualEntry {
    /**
     * 
     * @type {boolean}
     * @memberof ManualEntry
     */
    enabled?: boolean;
    /**
     * 
     * @type {DigitalWalletTokenAddressVerification}
     * @memberof ManualEntry
     */
    addressVerification?: DigitalWalletTokenAddressVerification;
}

/**
 * 
 * @export
 * @interface MccGroupModel
 */
export interface MccGroupModel {
    /**
     * 
     * @type {string}
     * @memberof MccGroupModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof MccGroupModel
     */
    name: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof MccGroupModel
     */
    mccs: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof MccGroupModel
     */
    active?: boolean;
    /**
     * 
     * @type {MCCConfig}
     * @memberof MccGroupModel
     */
    config?: MCCConfig;
}

/**
 * 
 * @export
 * @interface MccGroupUpdateModel
 */
export interface MccGroupUpdateModel {
    /**
     * 
     * @type {string}
     * @memberof MccGroupUpdateModel
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MccGroupUpdateModel
     */
    mccs?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof MccGroupUpdateModel
     */
    active?: boolean;
    /**
     * 
     * @type {MCCConfig}
     * @memberof MccGroupUpdateModel
     */
    config?: MCCConfig;
}

/**
 * 
 * @export
 * @interface MerchantCardRequest
 */
export interface MerchantCardRequest {
    /**
     * 
     * @type {string}
     * @memberof MerchantCardRequest
     */
    cardProductToken: string;
    /**
     * 
     * @type {boolean}
     * @memberof MerchantCardRequest
     */
    expedite?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MerchantCardRequest
     */
    metadata?: { [key: string]: string; };
    /**
     * 
     * @type {ExpirationOffset}
     * @memberof MerchantCardRequest
     */
    expirationOffset?: ExpirationOffset;
}

/**
 * 
 * @export
 * @interface MerchantGroupListResponse
 */
export interface MerchantGroupListResponse {
    /**
     * 
     * @type {number}
     * @memberof MerchantGroupListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof MerchantGroupListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof MerchantGroupListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof MerchantGroupListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<MerchantGroupResponse>}
     * @memberof MerchantGroupListResponse
     */
    data?: Array<MerchantGroupResponse>;
}

/**
 * 
 * @export
 * @interface MerchantGroupRequest
 */
export interface MerchantGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof MerchantGroupRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantGroupRequest
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MerchantGroupRequest
     */
    mids?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof MerchantGroupRequest
     */
    active?: boolean;
}

/**
 * 
 * @export
 * @interface MerchantGroupResponse
 */
export interface MerchantGroupResponse {
    /**
     * 
     * @type {string}
     * @memberof MerchantGroupResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantGroupResponse
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MerchantGroupResponse
     */
    mids?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof MerchantGroupResponse
     */
    active?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof MerchantGroupResponse
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof MerchantGroupResponse
     */
    lastModifiedTime?: Date;
}

/**
 * 
 * @export
 * @interface MerchantGroupUpdateRequest
 */
export interface MerchantGroupUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof MerchantGroupUpdateRequest
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MerchantGroupUpdateRequest
     */
    mids?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof MerchantGroupUpdateRequest
     */
    active?: boolean;
}

/**
 * 
 * @export
 * @interface MerchantResponseModel
 */
export interface MerchantResponseModel {
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseModel
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof MerchantResponseModel
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseModel
     */
    contact?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseModel
     */
    contactEmail?: string;
    /**
     * 
     * @type {number}
     * @memberof MerchantResponseModel
     */
    longitude?: number;
    /**
     * 
     * @type {number}
     * @memberof MerchantResponseModel
     */
    latitude?: number;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseModel
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseModel
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseModel
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseModel
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseModel
     */
    province?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseModel
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseModel
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantResponseModel
     */
    country?: string;
    /**
     * The unique identifier of the merchant
     * @type {string}
     * @memberof MerchantResponseModel
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MerchantResponseModel
     */
    partialAuthFlag?: boolean;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof MerchantResponseModel
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof MerchantResponseModel
     */
    lastModifiedTime: Date;
}

/**
 * 
 * @export
 * @interface MerchantScope
 */
export interface MerchantScope {
    /**
     * 36 char max
     * @type {string}
     * @memberof MerchantScope
     */
    mid?: string;
    /**
     * 4 char max
     * @type {string}
     * @memberof MerchantScope
     */
    mcc?: string;
    /**
     * 36 char max
     * @type {string}
     * @memberof MerchantScope
     */
    mccGroup?: string;
}

/**
 * 
 * @export
 * @interface MinOffset
 */
export interface MinOffset {
    /**
     * specify if a value is provided; default is expiration_offset.unit
     * @type {string}
     * @memberof MinOffset
     */
    unit?: MinOffset.UnitEnum;
    /**
     * specify if unit is provided; default is expiration_offset.value
     * @type {number}
     * @memberof MinOffset
     */
    value?: number;
}

/**
 * @export
 * @namespace MinOffset
 */
export namespace MinOffset {
    /**
     * @export
     * @enum {string}
     */
    export enum UnitEnum {
        YEARS = <any> 'YEARS',
        MONTHS = <any> 'MONTHS',
        DAYS = <any> 'DAYS',
        HOURS = <any> 'HOURS',
        MINUTES = <any> 'MINUTES',
        SECONDS = <any> 'SECONDS'
    }
}

/**
 * 
 * @export
 * @interface MoneyInTransaction
 */
export interface MoneyInTransaction {
    /**
     * Supported values are: CASH_DEPOSIT, ALL, NONE
     * @type {Array<string>}
     * @memberof MoneyInTransaction
     */
    includeCreditsTypes?: Array<string>;
    /**
     * Currently only support: ALL, NONE
     * @type {Array<string>}
     * @memberof MoneyInTransaction
     */
    includeNetworkLoadTypes?: Array<string>;
}

/**
 * 
 * @export
 * @interface MoneyModel
 */
export interface MoneyModel {
    /**
     * 
     * @type {number}
     * @memberof MoneyModel
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof MoneyModel
     */
    currency: string;
}

/**
 * 
 * @export
 * @interface MonitorResponse
 */
export interface MonitorResponse {
    /**
     * 
     * @type {boolean}
     * @memberof MonitorResponse
     */
    success?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof MonitorResponse
     */
    metadata?: { [key: string]: any; };
    /**
     * 
     * @type {Array<string>}
     * @memberof MonitorResponse
     */
    errors?: Array<string>;
}

/**
 * 
 * @export
 * @interface MsaAggregatedBalances
 */
export interface MsaAggregatedBalances {
    /**
     * 
     * @type {string}
     * @memberof MsaAggregatedBalances
     */
    currencyCode: string;
    /**
     * 
     * @type {number}
     * @memberof MsaAggregatedBalances
     */
    ledgerBalance: number;
    /**
     * 
     * @type {number}
     * @memberof MsaAggregatedBalances
     */
    availableBalance: number;
    /**
     * 
     * @type {number}
     * @memberof MsaAggregatedBalances
     */
    creditBalance: number;
    /**
     * 
     * @type {number}
     * @memberof MsaAggregatedBalances
     */
    cachedBalance: number;
    /**
     * 
     * @type {number}
     * @memberof MsaAggregatedBalances
     */
    pendingCredits: number;
    /**
     * 
     * @type {number}
     * @memberof MsaAggregatedBalances
     */
    impactedAmount?: number;
    /**
     * 
     * @type {{ [key: string]: MsaAggregatedBalances; }}
     * @memberof MsaAggregatedBalances
     */
    balances: { [key: string]: MsaAggregatedBalances; };
    /**
     * 
     * @type {Date}
     * @memberof MsaAggregatedBalances
     */
    lastUpdatedTime: Date;
}

/**
 * 
 * @export
 * @interface MsaBalances
 */
export interface MsaBalances {
    /**
     * 
     * @type {string}
     * @memberof MsaBalances
     */
    currencyCode: string;
    /**
     * 
     * @type {number}
     * @memberof MsaBalances
     */
    ledgerBalance: number;
    /**
     * 
     * @type {number}
     * @memberof MsaBalances
     */
    availableBalance: number;
    /**
     * 
     * @type {number}
     * @memberof MsaBalances
     */
    creditBalance: number;
    /**
     * 
     * @type {number}
     * @memberof MsaBalances
     */
    cachedBalance: number;
    /**
     * 
     * @type {number}
     * @memberof MsaBalances
     */
    pendingCredits: number;
    /**
     * 
     * @type {number}
     * @memberof MsaBalances
     */
    impactedAmount?: number;
    /**
     * 
     * @type {{ [key: string]: MsaBalances; }}
     * @memberof MsaBalances
     */
    balances: { [key: string]: MsaBalances; };
    /**
     * 
     * @type {Date}
     * @memberof MsaBalances
     */
    lastUpdatedTime: Date;
}

/**
 * 
 * @export
 * @interface MsaOrderResponse
 */
export interface MsaOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof MsaOrderResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof MsaOrderResponse
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof MsaOrderResponse
     */
    businessToken?: string;
    /**
     * 
     * @type {MsaBalances}
     * @memberof MsaOrderResponse
     */
    orderBalances: MsaBalances;
    /**
     * 
     * @type {number}
     * @memberof MsaOrderResponse
     */
    purchaseAmount: number;
    /**
     * yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof MsaOrderResponse
     */
    lastTransactionDate: Date;
    /**
     * yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof MsaOrderResponse
     */
    startDate?: Date;
    /**
     * yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof MsaOrderResponse
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof MsaOrderResponse
     */
    currencyCode: string;
    /**
     * 
     * @type {boolean}
     * @memberof MsaOrderResponse
     */
    active: boolean;
    /**
     * 
     * @type {number}
     * @memberof MsaOrderResponse
     */
    rewardAmount: number;
    /**
     * 
     * @type {number}
     * @memberof MsaOrderResponse
     */
    rewardTriggerAmount: number;
    /**
     * 
     * @type {number}
     * @memberof MsaOrderResponse
     */
    unloadedAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof MsaOrderResponse
     */
    campaignToken: string;
    /**
     * 
     * @type {Funding}
     * @memberof MsaOrderResponse
     */
    funding: Funding;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof MsaOrderResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof MsaOrderResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {MsaAggregatedBalances}
     * @memberof MsaOrderResponse
     */
    aggregatedBalances: MsaAggregatedBalances;
    /**
     * 
     * @type {string}
     * @memberof MsaOrderResponse
     */
    transactionToken: string;
}

/**
 * 
 * @export
 * @interface MsaReturns
 */
export interface MsaReturns {
    /**
     * 
     * @type {string}
     * @memberof MsaReturns
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof MsaReturns
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof MsaReturns
     */
    businessToken?: string;
    /**
     * 
     * @type {MsaBalances}
     * @memberof MsaReturns
     */
    orderBalances: MsaBalances;
    /**
     * 
     * @type {number}
     * @memberof MsaReturns
     */
    amount: number;
    /**
     * yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof MsaReturns
     */
    lastTransactionDate: Date;
    /**
     * yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof MsaReturns
     */
    startDate?: Date;
    /**
     * yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof MsaReturns
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof MsaReturns
     */
    currencyCode: string;
    /**
     * 
     * @type {boolean}
     * @memberof MsaReturns
     */
    active: boolean;
    /**
     * 
     * @type {number}
     * @memberof MsaReturns
     */
    rewardAmount: number;
    /**
     * 
     * @type {number}
     * @memberof MsaReturns
     */
    rewardTriggerAmount: number;
    /**
     * 
     * @type {number}
     * @memberof MsaReturns
     */
    unloadedAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof MsaReturns
     */
    campaignToken: string;
    /**
     * 
     * @type {Funding}
     * @memberof MsaReturns
     */
    funding: Funding;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof MsaReturns
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof MsaReturns
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {MsaAggregatedBalances}
     * @memberof MsaReturns
     */
    aggregatedBalances: MsaAggregatedBalances;
    /**
     * 
     * @type {string}
     * @memberof MsaReturns
     */
    originalOrderToken: string;
    /**
     * 
     * @type {string}
     * @memberof MsaReturns
     */
    transactionToken: string;
}

/**
 * 
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * 
     * @type {number}
     * @memberof Network
     */
    originalAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof Network
     */
    conversionRate?: number;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    originalCurrencyCode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Network
     */
    dynamicCurrencyConversion?: boolean;
    /**
     * 
     * @type {SettlementData}
     * @memberof Network
     */
    settlementData?: SettlementData;
}

/**
 * 
 * @export
 * @interface NetworkAccountIntelligenceScore
 */
export interface NetworkAccountIntelligenceScore {
    /**
     * 
     * @type {string}
     * @memberof NetworkAccountIntelligenceScore
     */
    serviceType?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkAccountIntelligenceScore
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkAccountIntelligenceScore
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface NetworkFeeModel
 */
export interface NetworkFeeModel {
    /**
     * 
     * @type {string}
     * @memberof NetworkFeeModel
     */
    type?: NetworkFeeModel.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof NetworkFeeModel
     */
    amount?: number;
    /**
     * C = credit; D = debit
     * @type {string}
     * @memberof NetworkFeeModel
     */
    creditDebit?: NetworkFeeModel.CreditDebitEnum;
}

/**
 * @export
 * @namespace NetworkFeeModel
 */
export namespace NetworkFeeModel {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        ISSUERFEE = <any> 'ISSUER_FEE',
        SWITCHFEE = <any> 'SWITCH_FEE',
        PINDEBITASSOCFEE = <any> 'PINDEBIT_ASSOC_FEE',
        ACQUIRERFEE = <any> 'ACQUIRER_FEE',
        INTERCHANGEFEE = <any> 'INTERCHANGE_FEE',
        CURCONVCARDHOLDERFEE = <any> 'CUR_CONV_CARDHOLDER_FEE',
        CURCONVISSUERFEE = <any> 'CUR_CONV_ISSUER_FEE',
        CROSSBORDERISSUERFEE = <any> 'CROSS_BORDER_ISSUER_FEE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CreditDebitEnum {
        C = <any> 'C',
        D = <any> 'D'
    }
}

/**
 * 
 * @export
 * @interface NetworkFraudView
 */
export interface NetworkFraudView {
    /**
     * 
     * @type {number}
     * @memberof NetworkFraudView
     */
    transactionRiskScore?: number;
    /**
     * 
     * @type {string}
     * @memberof NetworkFraudView
     */
    transactionRiskScoreReasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkFraudView
     */
    transactionRiskScoreReasonDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkFraudView
     */
    accountRiskScore?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkFraudView
     */
    accountRiskScoreReasonCode?: string;
}

/**
 * 
 * @export
 * @interface NetworkMetadata
 */
export interface NetworkMetadata {
    /**
     * 
     * @type {string}
     * @memberof NetworkMetadata
     */
    productId?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkMetadata
     */
    programId?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkMetadata
     */
    spendQualifier?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkMetadata
     */
    surchargeFreeAtmNetwork?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkMetadata
     */
    accountIdentification1?: string;
    /**
     * 
     * @type {InstallmentPayment}
     * @memberof NetworkMetadata
     */
    installmentPayment?: InstallmentPayment;
    /**
     * 
     * @type {string}
     * @memberof NetworkMetadata
     */
    incomingResponseCode?: string;
}

/**
 * 
 * @export
 * @interface OfferModel
 */
export interface OfferModel {
    /**
     * 
     * @type {string}
     * @memberof OfferModel
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OfferModel
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OfferModel
     */
    name: string;
    /**
     * 
     * @type {Date}
     * @memberof OfferModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof OfferModel
     */
    endDate?: Date;
    /**
     * 
     * @type {number}
     * @memberof OfferModel
     */
    purchaseAmount: number;
    /**
     * 
     * @type {number}
     * @memberof OfferModel
     */
    rewardAmount: number;
    /**
     * 
     * @type {number}
     * @memberof OfferModel
     */
    rewardTriggerAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof OfferModel
     */
    campaignToken: string;
    /**
     * 
     * @type {string}
     * @memberof OfferModel
     */
    currencyCode: string;
}

/**
 * 
 * @export
 * @interface OfferOrderAggregatedBalances
 */
export interface OfferOrderAggregatedBalances {
    /**
     * 
     * @type {string}
     * @memberof OfferOrderAggregatedBalances
     */
    currencyCode: string;
    /**
     * 
     * @type {number}
     * @memberof OfferOrderAggregatedBalances
     */
    ledgerBalance: number;
    /**
     * 
     * @type {number}
     * @memberof OfferOrderAggregatedBalances
     */
    availableBalance: number;
    /**
     * 
     * @type {number}
     * @memberof OfferOrderAggregatedBalances
     */
    creditBalance: number;
    /**
     * 
     * @type {number}
     * @memberof OfferOrderAggregatedBalances
     */
    cachedBalance: number;
    /**
     * 
     * @type {number}
     * @memberof OfferOrderAggregatedBalances
     */
    pendingCredits: number;
    /**
     * 
     * @type {number}
     * @memberof OfferOrderAggregatedBalances
     */
    impactedAmount?: number;
    /**
     * 
     * @type {{ [key: string]: OfferOrderAggregatedBalances; }}
     * @memberof OfferOrderAggregatedBalances
     */
    balances: { [key: string]: OfferOrderAggregatedBalances; };
    /**
     * 
     * @type {Date}
     * @memberof OfferOrderAggregatedBalances
     */
    lastUpdatedTime: Date;
}

/**
 * 
 * @export
 * @interface OfferOrderBalances
 */
export interface OfferOrderBalances {
    /**
     * 
     * @type {string}
     * @memberof OfferOrderBalances
     */
    currencyCode: string;
    /**
     * 
     * @type {number}
     * @memberof OfferOrderBalances
     */
    ledgerBalance: number;
    /**
     * 
     * @type {number}
     * @memberof OfferOrderBalances
     */
    availableBalance: number;
    /**
     * 
     * @type {number}
     * @memberof OfferOrderBalances
     */
    creditBalance: number;
    /**
     * 
     * @type {number}
     * @memberof OfferOrderBalances
     */
    cachedBalance: number;
    /**
     * 
     * @type {number}
     * @memberof OfferOrderBalances
     */
    pendingCredits: number;
    /**
     * 
     * @type {number}
     * @memberof OfferOrderBalances
     */
    impactedAmount?: number;
    /**
     * 
     * @type {{ [key: string]: OfferOrderBalances; }}
     * @memberof OfferOrderBalances
     */
    balances: { [key: string]: OfferOrderBalances; };
    /**
     * 
     * @type {Date}
     * @memberof OfferOrderBalances
     */
    lastUpdatedTime: Date;
}

/**
 * 
 * @export
 * @interface OfferOrderResponse
 */
export interface OfferOrderResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof OfferOrderResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof OfferOrderResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof OfferOrderResponse
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferOrderResponse
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof OfferOrderResponse
     */
    token: string;
    /**
     * 
     * @type {OfferOrderBalances}
     * @memberof OfferOrderResponse
     */
    orderBalances: OfferOrderBalances;
    /**
     * 
     * @type {OfferOrderAggregatedBalances}
     * @memberof OfferOrderResponse
     */
    orderAggregatedBalances: OfferOrderAggregatedBalances;
    /**
     * 
     * @type {Funding}
     * @memberof OfferOrderResponse
     */
    funding?: Funding;
    /**
     * 
     * @type {OfferModel}
     * @memberof OfferOrderResponse
     */
    offer?: OfferModel;
    /**
     * yyyy-MM-ddThh:mm:ssZ
     * @type {Date}
     * @memberof OfferOrderResponse
     */
    lastTransactionDate: Date;
}

/**
 * 
 * @export
 * @interface OneTimeRequestModel
 */
export interface OneTimeRequestModel {
    /**
     * 
     * @type {string}
     * @memberof OneTimeRequestModel
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof OneTimeRequestModel
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof OneTimeRequestModel
     */
    userToken?: string;
}

/**
 * 
 * @export
 * @interface OrderScope
 */
export interface OrderScope {
    /**
     * 
     * @type {GPA}
     * @memberof OrderScope
     */
    gpa?: GPA;
    /**
     * 
     * @type {MSA}
     * @memberof OrderScope
     */
    msa?: MSA;
}

/**
 * 
 * @export
 * @interface OriginalCredit
 */
export interface OriginalCredit {
    /**
     * 
     * @type {string}
     * @memberof OriginalCredit
     */
    transactionType?: OriginalCredit.TransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginalCredit
     */
    fundingSource?: OriginalCredit.FundingSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginalCredit
     */
    senderAccountType?: OriginalCredit.SenderAccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginalCredit
     */
    senderName?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCredit
     */
    senderAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCredit
     */
    senderCity?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCredit
     */
    senderState?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCredit
     */
    senderCountry?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCredit
     */
    screeningScore?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCredit
     */
    transactionPurpose?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCredit
     */
    deferredHoldBy?: OriginalCredit.DeferredHoldByEnum;
}

/**
 * @export
 * @namespace OriginalCredit
 */
export namespace OriginalCredit {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionTypeEnum {
        AccountToAccount = <any> 'account_to_account',
        PersonToPerson = <any> 'person_to_person',
        WalletTransfer = <any> 'wallet_transfer',
        MoneyTransferByBank = <any> 'money_transfer_by_bank',
        BusinessToBusiness = <any> 'business_to_business',
        Disbursement = <any> 'disbursement',
        GovernmentDisbursement = <any> 'government_disbursement',
        GamblingPayout = <any> 'gambling_payout',
        Loyalty = <any> 'loyalty',
        MerchantDisbursement = <any> 'merchant_disbursement',
        OnlineGamblingPayout = <any> 'online_gambling_payout',
        PensionDisbursement = <any> 'pension_disbursement',
        PrepaidLoads = <any> 'prepaid_loads',
        CardBillPayment = <any> 'card_bill_payment',
        BillPayment = <any> 'bill_payment',
        CashClaim = <any> 'cash_claim',
        CashIn = <any> 'cash_in',
        CashOut = <any> 'cash_out',
        MobileAirTimePayment = <any> 'mobile_air_time_payment',
        MoneyTransferByMerchant = <any> 'money_transfer_by_merchant',
        FaceToFaceMerchantPayment = <any> 'face_to_face_merchant_payment',
        GovernmentPayment = <any> 'government_payment',
        PaymentsGoodsServices = <any> 'payments_goods_services',
        FundsTransfer = <any> 'funds_transfer',
        GeneralBusinessToBusinessTransfer = <any> 'general_business_to_business_transfer',
        BusinessToBusinessTransfer = <any> 'business_to_business_transfer',
        CashDeposit = <any> 'cash_deposit',
        PurchaseRepayment = <any> 'purchase_repayment'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FundingSourceEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT',
        PREPAID = <any> 'PREPAID',
        DEPOSITACCOUNT = <any> 'DEPOSIT_ACCOUNT',
        CASH = <any> 'CASH',
        MOBILEMONEYACCOUNT = <any> 'MOBILE_MONEY_ACCOUNT',
        NONVISACREDIT = <any> 'NON_VISA_CREDIT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SenderAccountTypeEnum {
        OTHER = <any> 'OTHER',
        RTNBANKACCOUNT = <any> 'RTN_BANK_ACCOUNT',
        IBAN = <any> 'IBAN',
        CARDACCOUNT = <any> 'CARD_ACCOUNT',
        EMAIL = <any> 'EMAIL',
        PHONENUMBER = <any> 'PHONE_NUMBER',
        BANKACCOUNTNUMBERANDBANKIDENTIFICATIONCODE = <any> 'BANK_ACCOUNT_NUMBER_AND_BANK_IDENTIFICATION_CODE',
        WALLETID = <any> 'WALLET_ID',
        SOCIALNETWORKID = <any> 'SOCIAL_NETWORK_ID'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DeferredHoldByEnum {
        Absent = <any> 'absent',
        Visa = <any> 'visa',
        Originator = <any> 'originator'
    }
}

/**
 * 
 * @export
 * @interface OriginalCreditSenderData
 */
export interface OriginalCreditSenderData {
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    fundingSource: OriginalCreditSenderData.FundingSourceEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    senderAccountType?: OriginalCreditSenderData.SenderAccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    senderName?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    senderReferenceNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    senderAccountNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    senderAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    senderCity?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    senderState?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    senderCountry?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    uniqueTransactionReferenceNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    transactionPurpose?: OriginalCreditSenderData.TransactionPurposeEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    visaTransactionPurpose?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalCreditSenderData
     */
    deferredHoldBy?: OriginalCreditSenderData.DeferredHoldByEnum;
}

/**
 * @export
 * @namespace OriginalCreditSenderData
 */
export namespace OriginalCreditSenderData {
    /**
     * @export
     * @enum {string}
     */
    export enum FundingSourceEnum {
        Credit = <any> 'credit',
        Debit = <any> 'debit',
        Prepaid = <any> 'prepaid',
        DepositAccount = <any> 'deposit_account',
        Cash = <any> 'cash',
        MobileMoneyPayment = <any> 'mobile_money_payment',
        NonVisaCredit = <any> 'non_visa_credit'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SenderAccountTypeEnum {
        Other = <any> 'other',
        RtnBankAccount = <any> 'rtn_bank_account',
        Iban = <any> 'iban',
        CardAccount = <any> 'card_account',
        Email = <any> 'email',
        PhoneNumber = <any> 'phone_number',
        BankAccountNumberAndIdentificationCode = <any> 'bank_account_number_and_identification_code',
        WalletId = <any> 'wallet_id',
        SocialNetworkId = <any> 'social_network_id'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionPurposeEnum {
        FamilySupport = <any> 'family_support',
        LaborTransfers = <any> 'labor_transfers',
        Travel = <any> 'travel',
        Education = <any> 'education',
        MedicalTreatment = <any> 'medical_treatment',
        EmergencyNeed = <any> 'emergency_need',
        Savings = <any> 'savings',
        Gifts = <any> 'gifts',
        Other = <any> 'other',
        Salary = <any> 'salary',
        Lending = <any> 'lending',
        CryptoCurrency = <any> 'crypto_currency'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DeferredHoldByEnum {
        Absent = <any> 'absent',
        Visa = <any> 'visa',
        Originator = <any> 'originator'
    }
}

/**
 * 
 * @export
 * @interface OriginalDataElements
 */
export interface OriginalDataElements {
    /**
     * 
     * @type {string}
     * @memberof OriginalDataElements
     */
    mti?: OriginalDataElements.MtiEnum;
    /**
     * 
     * @type {string}
     * @memberof OriginalDataElements
     */
    stan?: string;
    /**
     * yyyyMMddHHmmss
     * @type {string}
     * @memberof OriginalDataElements
     */
    transmissionTime?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalDataElements
     */
    acquiringInstitutionId?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalDataElements
     */
    networkReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalDataElements
     */
    forwardingInstitutionId?: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalDataElements
     */
    transactionToken?: string;
}

/**
 * @export
 * @namespace OriginalDataElements
 */
export namespace OriginalDataElements {
    /**
     * @export
     * @enum {string}
     */
    export enum MtiEnum {
        _0100 = <any> '0100',
        _0120 = <any> '0120',
        _0200 = <any> '0200'
    }
}

/**
 * 
 * @export
 * @interface OrignalcreditRequestModel
 */
export interface OrignalcreditRequestModel {
    /**
     * 
     * @type {string}
     * @memberof OrignalcreditRequestModel
     */
    transactionPurpose?: string;
    /**
     * 
     * @type {number}
     * @memberof OrignalcreditRequestModel
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof OrignalcreditRequestModel
     */
    cardToken: string;
    /**
     * 
     * @type {string}
     * @memberof OrignalcreditRequestModel
     */
    mid: string;
    /**
     * 
     * @type {string}
     * @memberof OrignalcreditRequestModel
     */
    screeningScore?: string;
    /**
     * 
     * @type {CardAcceptorModel}
     * @memberof OrignalcreditRequestModel
     */
    cardAcceptor?: CardAcceptorModel;
    /**
     * 
     * @type {string}
     * @memberof OrignalcreditRequestModel
     */
    type: OrignalcreditRequestModel.TypeEnum;
    /**
     * 
     * @type {OriginalCreditSenderData}
     * @memberof OrignalcreditRequestModel
     */
    senderData?: OriginalCreditSenderData;
    /**
     * 
     * @type {Webhook}
     * @memberof OrignalcreditRequestModel
     */
    webhook?: Webhook;
}

/**
 * @export
 * @namespace OrignalcreditRequestModel
 */
export namespace OrignalcreditRequestModel {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        AccountToAccount = <any> 'account_to_account',
        PersonToPerson = <any> 'person_to_person',
        Prepaid = <any> 'prepaid',
        WalletTransfer = <any> 'wallet_transfer',
        MoneyTransferByBank = <any> 'money_transfer_by_bank',
        BusinessToBusiness = <any> 'business_to_business',
        Disbursement = <any> 'disbursement',
        GovernmentDisbursement = <any> 'government_disbursement',
        GamblingPayout = <any> 'gambling_payout',
        Loyalty = <any> 'loyalty',
        MerchantDisbursement = <any> 'merchant_disbursement',
        OnlineGamblingPayout = <any> 'online_gambling_payout',
        PensionDisbursement = <any> 'pension_disbursement',
        PrepaidLoads = <any> 'prepaid_loads',
        CardBillPayment = <any> 'card_bill_payment',
        BillPayment = <any> 'bill_payment',
        CashClaim = <any> 'cash_claim',
        CashIn = <any> 'cash_in',
        CashOut = <any> 'cash_out',
        MobileAirTimePayment = <any> 'mobile_air_time_payment',
        MoneyTransferByMerchant = <any> 'money_transfer_by_merchant',
        FaceToFaceMerchantPayment = <any> 'face_to_face_merchant_payment',
        GovernmentPayment = <any> 'government_payment',
        PaymentsGoodsServices = <any> 'payments_goods_services',
        PurchaseRepayment = <any> 'purchase_repayment'
    }
}

/**
 * 
 * @export
 * @interface OtherPoi
 */
export interface OtherPoi {
    /**
     * 
     * @type {boolean}
     * @memberof OtherPoi
     */
    allow?: boolean;
    /**
     * Default = false
     * @type {boolean}
     * @memberof OtherPoi
     */
    cardPresenceRequired?: boolean;
    /**
     * Default = false
     * @type {boolean}
     * @memberof OtherPoi
     */
    cardholderPresenceRequired?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OtherPoi
     */
    track1DiscretionaryData?: string;
    /**
     * 
     * @type {string}
     * @memberof OtherPoi
     */
    track2DiscretionaryData?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OtherPoi
     */
    useStaticPin?: boolean;
}

/**
 * 
 * @export
 * @interface PTCAddress
 */
export interface PTCAddress {
    /**
     * 
     * @type {string}
     * @memberof PTCAddress
     */
    line1: string;
    /**
     * 
     * @type {string}
     * @memberof PTCAddress
     */
    line2?: string;
    /**
     * 
     * @type {string}
     * @memberof PTCAddress
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof PTCAddress
     */
    county: string;
    /**
     * 
     * @type {string}
     * @memberof PTCAddress
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof PTCAddress
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof PTCAddress
     */
    postalCode: string;
}

/**
 * 
 * @export
 * @interface PTCPhone
 */
export interface PTCPhone {
    /**
     * 
     * @type {string}
     * @memberof PTCPhone
     */
    countryCode?: string;
    /**
     * 
     * @type {string}
     * @memberof PTCPhone
     */
    number: string;
}

/**
 * 
 * @export
 * @interface PTCSoftDescriptor
 */
export interface PTCSoftDescriptor {
    /**
     * 
     * @type {string}
     * @memberof PTCSoftDescriptor
     */
    name: string;
    /**
     * 
     * @type {PTCAddress}
     * @memberof PTCSoftDescriptor
     */
    address: PTCAddress;
    /**
     * 
     * @type {PTCPhone}
     * @memberof PTCSoftDescriptor
     */
    phone?: PTCPhone;
    /**
     * 
     * @type {string}
     * @memberof PTCSoftDescriptor
     */
    email?: string;
}

/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pagination
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof Pagination
     */
    data?: Array<any>;
}

/**
 * 
 * @export
 * @interface PanRequest
 */
export interface PanRequest {
    /**
     * 
     * @type {string}
     * @memberof PanRequest
     */
    pan: string;
    /**
     * 
     * @type {string}
     * @memberof PanRequest
     */
    cvvNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof PanRequest
     */
    expiration?: string;
}

/**
 * 
 * @export
 * @interface PanResponse
 */
export interface PanResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof PanResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof PanResponse
     */
    lastModifiedTime: Date;
    /**
     * The unique identifier of the card user
     * @type {string}
     * @memberof PanResponse
     */
    userToken: string;
    /**
     * The unique identifier of the card
     * @type {string}
     * @memberof PanResponse
     */
    cardToken: string;
}

/**
 * 
 * @export
 * @interface PasswordUpdateModel
 */
export interface PasswordUpdateModel {
    /**
     * 
     * @type {string}
     * @memberof PasswordUpdateModel
     */
    newPassword: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordUpdateModel
     */
    currentPassword: string;
}

/**
 * 
 * @export
 * @interface PaymentCardFundingSourceModel
 */
export interface PaymentCardFundingSourceModel extends FundingSourceModel {
    /**
     * Required if 'business_token' is null
     * @type {string}
     * @memberof PaymentCardFundingSourceModel
     */
    userToken?: string;
    /**
     * Required if 'user_token' is null
     * @type {string}
     * @memberof PaymentCardFundingSourceModel
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCardFundingSourceModel
     */
    accountSuffix: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCardFundingSourceModel
     */
    accountType: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCardFundingSourceModel
     */
    expDate: string;
}

/**
 * 
 * @export
 * @interface PaymentCardResponseModel
 */
export interface PaymentCardResponseModel {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof PaymentCardResponseModel
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof PaymentCardResponseModel
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof PaymentCardResponseModel
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCardResponseModel
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCardResponseModel
     */
    accountSuffix: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentCardResponseModel
     */
    accountType: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentCardResponseModel
     */
    active: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentCardResponseModel
     */
    isDefaultAccount: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentCardResponseModel
     */
    expDate: string;
    /**
     * Required if 'business_token' is not present
     * @type {string}
     * @memberof PaymentCardResponseModel
     */
    userToken?: string;
    /**
     * Required if 'user_token' is not present
     * @type {string}
     * @memberof PaymentCardResponseModel
     */
    businessToken?: string;
}

/**
 * 
 * @export
 * @interface PeerTransferRequest
 */
export interface PeerTransferRequest {
    /**
     * 
     * @type {string}
     * @memberof PeerTransferRequest
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof PeerTransferRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof PeerTransferRequest
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof PeerTransferRequest
     */
    memo?: string;
    /**
     * Required if 'send_business_token' is null
     * @type {string}
     * @memberof PeerTransferRequest
     */
    senderUserToken?: string;
    /**
     * Required if 'recipient_business_token' is null
     * @type {string}
     * @memberof PeerTransferRequest
     */
    recipientUserToken?: string;
    /**
     * Required if 'send_user_token' is null
     * @type {string}
     * @memberof PeerTransferRequest
     */
    senderBusinessToken?: string;
    /**
     * Required if 'recipient_business_token' is null
     * @type {string}
     * @memberof PeerTransferRequest
     */
    recipientBusinessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PeerTransferRequest
     */
    currencyCode: string;
}

/**
 * 
 * @export
 * @interface PeerTransferResponse
 */
export interface PeerTransferResponse {
    /**
     * 
     * @type {string}
     * @memberof PeerTransferResponse
     */
    token: string;
    /**
     * 
     * @type {number}
     * @memberof PeerTransferResponse
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof PeerTransferResponse
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof PeerTransferResponse
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof PeerTransferResponse
     */
    currencyCode: string;
    /**
     * 
     * @type {string}
     * @memberof PeerTransferResponse
     */
    senderUserToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PeerTransferResponse
     */
    recipientUserToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PeerTransferResponse
     */
    senderBusinessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PeerTransferResponse
     */
    recipientBusinessToken?: string;
    /**
     * 
     * @type {Date}
     * @memberof PeerTransferResponse
     */
    createdTime: Date;
}

/**
 * 
 * @export
 * @interface PinRequest
 */
export interface PinRequest {
    /**
     * 
     * @type {string}
     * @memberof PinRequest
     */
    controlToken: string;
    /**
     * 
     * @type {string}
     * @memberof PinRequest
     */
    pin: string;
}

/**
 * 
 * @export
 * @interface PinRevealRequest
 */
export interface PinRevealRequest {
    /**
     * 
     * @type {string}
     * @memberof PinRevealRequest
     */
    controlToken: string;
    /**
     * Verification method required
     * @type {string}
     * @memberof PinRevealRequest
     */
    cardholderVerificationMethod: PinRevealRequest.CardholderVerificationMethodEnum;
}

/**
 * @export
 * @namespace PinRevealRequest
 */
export namespace PinRevealRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum CardholderVerificationMethodEnum {
        BIOMETRICFACE = <any> 'BIOMETRIC_FACE',
        BIOMETRICFINGERPRINT = <any> 'BIOMETRIC_FINGERPRINT',
        LOGIN = <any> 'LOGIN',
        EXPCVV = <any> 'EXP_CVV',
        OTPCVV = <any> 'OTP_CVV',
        OTP = <any> 'OTP',
        OTHER = <any> 'OTHER'
    }
}

/**
 * 
 * @export
 * @interface PingResponse
 */
export interface PingResponse {
    /**
     * 
     * @type {boolean}
     * @memberof PingResponse
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PingResponse
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof PingResponse
     */
    revision?: string;
    /**
     * 
     * @type {string}
     * @memberof PingResponse
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof PingResponse
     */
    env?: string;
    /**
     * 
     * @type {string}
     * @memberof PingResponse
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface PingResponseExtended
 */
export interface PingResponseExtended {
    /**
     * 
     * @type {boolean}
     * @memberof PingResponseExtended
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PingResponseExtended
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof PingResponseExtended
     */
    revision?: string;
    /**
     * 
     * @type {string}
     * @memberof PingResponseExtended
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof PingResponseExtended
     */
    env?: string;
    /**
     * 
     * @type {string}
     * @memberof PingResponseExtended
     */
    id?: string;
    /**
     * 
     * @type {Array<HealthCheckResult>}
     * @memberof PingResponseExtended
     */
    systemComponents?: Array<HealthCheckResult>;
}

/**
 * 
 * @export
 * @interface Poi
 */
export interface Poi {
    /**
     * 
     * @type {OtherPoi}
     * @memberof Poi
     */
    other?: OtherPoi;
    /**
     * 
     * @type {boolean}
     * @memberof Poi
     */
    ecommerce?: boolean;
    /**
     * Default = false
     * @type {boolean}
     * @memberof Poi
     */
    atm?: boolean;
}

/**
 * 
 * @export
 * @interface Pos
 */
export interface Pos {
    /**
     * 
     * @type {string}
     * @memberof Pos
     */
    panEntryMode?: Pos.PanEntryModeEnum;
    /**
     * 
     * @type {string}
     * @memberof Pos
     */
    pinEntryMode?: Pos.PinEntryModeEnum;
    /**
     * 
     * @type {string}
     * @memberof Pos
     */
    terminalId?: string;
    /**
     * 
     * @type {string}
     * @memberof Pos
     */
    terminalAttendance?: Pos.TerminalAttendanceEnum;
    /**
     * 
     * @type {string}
     * @memberof Pos
     */
    terminalLocation?: Pos.TerminalLocationEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Pos
     */
    cardHolderPresence?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Pos
     */
    cardholderAuthenticationMethod?: Pos.CardholderAuthenticationMethodEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Pos
     */
    cardPresence?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pos
     */
    pinPresent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Pos
     */
    terminalType?: Pos.TerminalTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Pos
     */
    cardDataInputCapability?: Pos.CardDataInputCapabilityEnum;
    /**
     * 
     * @type {string}
     * @memberof Pos
     */
    countryCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Pos
     */
    zip?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Pos
     */
    partialApprovalCapable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pos
     */
    purchaseAmountOnly?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pos
     */
    isRecurring?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pos
     */
    isInstallment?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Pos
     */
    specialConditionIndicator?: Pos.SpecialConditionIndicatorEnum;
}

/**
 * @export
 * @namespace Pos
 */
export namespace Pos {
    /**
     * @export
     * @enum {string}
     */
    export enum PanEntryModeEnum {
        UNKNOWN = <any> 'UNKNOWN',
        MANUAL = <any> 'MANUAL',
        MAGSTRIPE = <any> 'MAG_STRIPE',
        MAGSTRIPECONTACTLESS = <any> 'MAG_STRIPE_CONTACTLESS',
        BARCODE = <any> 'BAR_CODE',
        OCR = <any> 'OCR',
        MICR = <any> 'MICR',
        CHIP = <any> 'CHIP',
        CHIPCONTACTLESS = <any> 'CHIP_CONTACTLESS',
        CARDONFILE = <any> 'CARD_ON_FILE',
        CHIPFALLBACK = <any> 'CHIP_FALLBACK',
        OTHER = <any> 'OTHER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PinEntryModeEnum {
        UNKNOWN = <any> 'UNKNOWN',
        TRUE = <any> 'TRUE',
        FALSE = <any> 'FALSE',
        DEFECTIVE = <any> 'DEFECTIVE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TerminalAttendanceEnum {
        UNSPECIFIED = <any> 'UNSPECIFIED',
        ATTENDED = <any> 'ATTENDED',
        UNATTENDED = <any> 'UNATTENDED',
        NOTERMINAL = <any> 'NO_TERMINAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TerminalLocationEnum {
        ONPREMISE = <any> 'ON_PREMISE',
        OFFPREMISEMERCHANT = <any> 'OFF_PREMISE_MERCHANT',
        OFFPREMISECARDHOLDER = <any> 'OFF_PREMISE_CARDHOLDER',
        NOTERMINAL = <any> 'NO_TERMINAL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CardholderAuthenticationMethodEnum {
        UNSPECIFIED = <any> 'UNSPECIFIED',
        NONAUTHENTICATED = <any> 'NON_AUTHENTICATED',
        SIGNATURE = <any> 'SIGNATURE',
        PIN = <any> 'PIN',
        IDVERIFIED = <any> 'ID_VERIFIED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TerminalTypeEnum {
        AUTODISPENSERWITHPIN = <any> 'AUTO_DISPENSER_WITH_PIN',
        SELFSERVICE = <any> 'SELF_SERVICE',
        LIMITEDAMOUNT = <any> 'LIMITED_AMOUNT',
        INFLIGHT = <any> 'IN_FLIGHT',
        ECOMMERCE = <any> 'ECOMMERCE',
        TRANSPONDER = <any> 'TRANSPONDER'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CardDataInputCapabilityEnum {
        UNKNOWN = <any> 'UNKNOWN',
        NOTERMINAL = <any> 'NO_TERMINAL',
        MAGSTRIPE = <any> 'MAG_STRIPE',
        MAGSTRIPECONTACTLESS = <any> 'MAG_STRIPE_CONTACTLESS',
        MAGSTRIPEKEYENTRY = <any> 'MAG_STRIPE_KEY_ENTRY',
        CHIP = <any> 'CHIP',
        CHIPCONTACTLESS = <any> 'CHIP_CONTACTLESS',
        CHIPMAGSTRIPE = <any> 'CHIP_MAG_STRIPE',
        CHIPMAGSTRIPEKEYENTRY = <any> 'CHIP_MAG_STRIPE_KEY_ENTRY',
        KEYENTRY = <any> 'KEY_ENTRY',
        OCR = <any> 'OCR',
        MICR = <any> 'MICR',
        BARCODE = <any> 'BAR_CODE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SpecialConditionIndicatorEnum {
        UNSPECIFIED = <any> 'UNSPECIFIED',
        CRYPTOCURRENCYPURCHASE = <any> 'CRYPTOCURRENCY_PURCHASE',
        QUASICASH = <any> 'QUASI_CASH',
        DEBTPAYMENT = <any> 'DEBT_PAYMENT'
    }
}

/**
 * 
 * @export
 * @interface PreKycControls
 */
export interface PreKycControls {
    /**
     * 
     * @type {boolean}
     * @memberof PreKycControls
     */
    cashAccessEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PreKycControls
     */
    internationalEnabled?: boolean;
    /**
     * Minimum is 0.01
     * @type {number}
     * @memberof PreKycControls
     */
    balanceMax?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PreKycControls
     */
    enableNonProgramLoads?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PreKycControls
     */
    isReloadablePreKyc?: boolean;
}

/**
 * 
 * @export
 * @interface PrecedingTransaction
 */
export interface PrecedingTransaction {
    /**
     * Amount of the preceding transaction
     * @type {number}
     * @memberof PrecedingTransaction
     */
    amount?: number;
    /**
     * Token of the preceding transaction
     * @type {string}
     * @memberof PrecedingTransaction
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface PrimaryContactInfoModel
 */
export interface PrimaryContactInfoModel {
    /**
     * 
     * @type {string}
     * @memberof PrimaryContactInfoModel
     */
    fullName?: string;
    /**
     * 
     * @type {string}
     * @memberof PrimaryContactInfoModel
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PrimaryContactInfoModel
     */
    department?: string;
    /**
     * 
     * @type {string}
     * @memberof PrimaryContactInfoModel
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof PrimaryContactInfoModel
     */
    extension?: string;
    /**
     * 
     * @type {string}
     * @memberof PrimaryContactInfoModel
     */
    fax?: string;
    /**
     * 
     * @type {string}
     * @memberof PrimaryContactInfoModel
     */
    mobile?: string;
    /**
     * 
     * @type {string}
     * @memberof PrimaryContactInfoModel
     */
    email?: string;
}

/**
 * 
 * @export
 * @interface Program
 */
export interface Program {
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    programId: string;
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    shortCode: string;
    /**
     * 
     * @type {string}
     * @memberof Program
     */
    longCode: string;
}

/**
 * 
 * @export
 * @interface ProgramFundingSourceAchUpdateRequest
 */
export interface ProgramFundingSourceAchUpdateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ProgramFundingSourceAchUpdateRequest
     */
    active?: boolean;
}

/**
 * 
 * @export
 * @interface ProgramFundingSourceListResponse
 */
export interface ProgramFundingSourceListResponse {
    /**
     * 
     * @type {number}
     * @memberof ProgramFundingSourceListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramFundingSourceListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramFundingSourceListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProgramFundingSourceListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<ProgramFundingSourceResponse>}
     * @memberof ProgramFundingSourceListResponse
     */
    data?: Array<ProgramFundingSourceResponse>;
}

/**
 * 
 * @export
 * @interface ProgramFundingSourceModel
 */
export interface ProgramFundingSourceModel extends FundingSourceModel {
    /**
     * 
     * @type {string}
     * @memberof ProgramFundingSourceModel
     */
    name: string;
}

/**
 * 
 * @export
 * @interface ProgramFundingSourceRequest
 */
export interface ProgramFundingSourceRequest {
    /**
     * 
     * @type {string}
     * @memberof ProgramFundingSourceRequest
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProgramFundingSourceRequest
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProgramFundingSourceRequest
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface ProgramFundingSourceResponse
 */
export interface ProgramFundingSourceResponse {
    /**
     * 
     * @type {string}
     * @memberof ProgramFundingSourceResponse
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProgramFundingSourceResponse
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProgramFundingSourceResponse
     */
    token: string;
    /**
     * 
     * @type {Date}
     * @memberof ProgramFundingSourceResponse
     */
    createdTime: Date;
    /**
     * 
     * @type {Date}
     * @memberof ProgramFundingSourceResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof ProgramFundingSourceResponse
     */
    account: string;
}

/**
 * 
 * @export
 * @interface ProgramFundingSourceUpdateRequest
 */
export interface ProgramFundingSourceUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProgramFundingSourceUpdateRequest
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProgramFundingSourceUpdateRequest
     */
    active?: boolean;
}

/**
 * 
 * @export
 * @interface ProgramGatewayFundingSourceModel
 */
export interface ProgramGatewayFundingSourceModel extends FundingSourceModel {
    /**
     * 
     * @type {string}
     * @memberof ProgramGatewayFundingSourceModel
     */
    name: string;
}

/**
 * 
 * @export
 * @interface ProgramReserveAccountBalance
 */
export interface ProgramReserveAccountBalance {
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveAccountBalance
     */
    currencyCode?: string;
    /**
     * 
     * @type {number}
     * @memberof ProgramReserveAccountBalance
     */
    ledgerBalance?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramReserveAccountBalance
     */
    availableBalance?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramReserveAccountBalance
     */
    creditBalance?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramReserveAccountBalance
     */
    pendingCredits?: number;
    /**
     * 
     * @type {{ [key: string]: ProgramReserveAccountBalance; }}
     * @memberof ProgramReserveAccountBalance
     */
    balances?: { [key: string]: ProgramReserveAccountBalance; };
}

/**
 * 
 * @export
 * @interface ProgramReserveDepositRequest
 */
export interface ProgramReserveDepositRequest {
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveDepositRequest
     */
    idempotentHash?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveDepositRequest
     */
    token: string;
    /**
     * 
     * @type {number}
     * @memberof ProgramReserveDepositRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveDepositRequest
     */
    currencyCode: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveDepositRequest
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveDepositRequest
     */
    tags?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProgramReserveDepositRequest
     */
    isCollateral?: boolean;
}

/**
 * 
 * @export
 * @interface ProgramReserveTransactionClearingRequest
 */
export interface ProgramReserveTransactionClearingRequest {
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionClearingRequest
     */
    programReserveTransactionToken: string;
}

/**
 * 
 * @export
 * @interface ProgramReserveTransactionListResponse
 */
export interface ProgramReserveTransactionListResponse {
    /**
     * 
     * @type {number}
     * @memberof ProgramReserveTransactionListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramReserveTransactionListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramReserveTransactionListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProgramReserveTransactionListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<ProgramReserveTransactionResponse>}
     * @memberof ProgramReserveTransactionListResponse
     */
    data?: Array<ProgramReserveTransactionResponse>;
}

/**
 * 
 * @export
 * @interface ProgramReserveTransactionRequest
 */
export interface ProgramReserveTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionRequest
     */
    idempotentHash?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionRequest
     */
    token: string;
    /**
     * 
     * @type {number}
     * @memberof ProgramReserveTransactionRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionRequest
     */
    currencyCode: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionRequest
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionRequest
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionRequest
     */
    type: ProgramReserveTransactionRequest.TypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ProgramReserveTransactionRequest
     */
    isCollateral?: boolean;
}

/**
 * @export
 * @namespace ProgramReserveTransactionRequest
 */
export namespace ProgramReserveTransactionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT',
        PENDINGCREDIT = <any> 'PENDING_CREDIT',
        PENDINGDEBIT = <any> 'PENDING_DEBIT'
    }
}

/**
 * 
 * @export
 * @interface ProgramReserveTransactionResponse
 */
export interface ProgramReserveTransactionResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof ProgramReserveTransactionResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof ProgramReserveTransactionResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionResponse
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof ProgramReserveTransactionResponse
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionResponse
     */
    currencyCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionResponse
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionResponse
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionResponse
     */
    transactionToken?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionResponse
     */
    type?: ProgramReserveTransactionResponse.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProgramReserveTransactionResponse
     */
    state?: ProgramReserveTransactionResponse.StateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ProgramReserveTransactionResponse
     */
    isCollateral?: boolean;
}

/**
 * @export
 * @namespace ProgramReserveTransactionResponse
 */
export namespace ProgramReserveTransactionResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT',
        PENDINGCREDIT = <any> 'PENDING_CREDIT',
        PENDINGDEBIT = <any> 'PENDING_DEBIT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        PENDING = <any> 'PENDING',
        COMPLETE = <any> 'COMPLETE'
    }
}

/**
 * 
 * @export
 * @interface ProgramTransfer
 */
export interface ProgramTransfer {
    /**
     * 
     * @type {string}
     * @memberof ProgramTransfer
     */
    token?: string;
    /**
     * Required if 'business_token' is null
     * @type {string}
     * @memberof ProgramTransfer
     */
    userToken?: string;
    /**
     * Required if 'user_token' is null
     * @type {string}
     * @memberof ProgramTransfer
     */
    businessToken?: string;
    /**
     * 
     * @type {number}
     * @memberof ProgramTransfer
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransfer
     */
    typeToken: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransfer
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransfer
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransfer
     */
    currencyCode: string;
    /**
     * 
     * @type {Array<FeeModel>}
     * @memberof ProgramTransfer
     */
    fees?: Array<FeeModel>;
}

/**
 * 
 * @export
 * @interface ProgramTransferListResponse
 */
export interface ProgramTransferListResponse {
    /**
     * 
     * @type {number}
     * @memberof ProgramTransferListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramTransferListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramTransferListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProgramTransferListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<ProgramTransferResponse>}
     * @memberof ProgramTransferListResponse
     */
    data?: Array<ProgramTransferResponse>;
}

/**
 * 
 * @export
 * @interface ProgramTransferResponse
 */
export interface ProgramTransferResponse {
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferResponse
     */
    typeToken: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferResponse
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferResponse
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferResponse
     */
    transactionToken: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferResponse
     */
    currencyCode: string;
    /**
     * 
     * @type {number}
     * @memberof ProgramTransferResponse
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferResponse
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferResponse
     */
    tags?: string;
    /**
     * 
     * @type {Array<FeeDetail>}
     * @memberof ProgramTransferResponse
     */
    fees?: Array<FeeDetail>;
    /**
     * 
     * @type {Date}
     * @memberof ProgramTransferResponse
     */
    createdTime?: Date;
    /**
     * 
     * @type {JitFundingApi}
     * @memberof ProgramTransferResponse
     */
    jitFunding?: JitFundingApi;
}

/**
 * 
 * @export
 * @interface ProgramTransferTypeListResponse
 */
export interface ProgramTransferTypeListResponse {
    /**
     * 
     * @type {number}
     * @memberof ProgramTransferTypeListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramTransferTypeListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramTransferTypeListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProgramTransferTypeListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<ProgramTransferTypeResponse>}
     * @memberof ProgramTransferTypeListResponse
     */
    data?: Array<ProgramTransferTypeResponse>;
}

/**
 * 
 * @export
 * @interface ProgramTransferTypeRequest
 */
export interface ProgramTransferTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferTypeRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferTypeRequest
     */
    programFundingSourceToken: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferTypeRequest
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferTypeRequest
     */
    memo: string;
}

/**
 * 
 * @export
 * @interface ProgramTransferTypeResponse
 */
export interface ProgramTransferTypeResponse {
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferTypeResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferTypeResponse
     */
    programFundingSourceToken: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferTypeResponse
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramTransferTypeResponse
     */
    memo?: string;
    /**
     * 
     * @type {Date}
     * @memberof ProgramTransferTypeResponse
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ProgramTransferTypeResponse
     */
    lastModifiedTime?: Date;
}

/**
 * 
 * @export
 * @interface ProvisioningControls
 */
export interface ProvisioningControls {
    /**
     * 
     * @type {ManualEntry}
     * @memberof ProvisioningControls
     */
    manualEntry?: ManualEntry;
    /**
     * 
     * @type {WalletProviderCardOnFile}
     * @memberof ProvisioningControls
     */
    walletProviderCardOnFile?: WalletProviderCardOnFile;
    /**
     * 
     * @type {InAppProvisioning}
     * @memberof ProvisioningControls
     */
    inAppProvisioning?: InAppProvisioning;
    /**
     * 
     * @type {WebPushProvisioning}
     * @memberof ProvisioningControls
     */
    webPushProvisioning?: WebPushProvisioning;
    /**
     * 
     * @type {boolean}
     * @memberof ProvisioningControls
     */
    forceYellowPathForCardProduct?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProvisioningControls
     */
    dwtVerifyAtcDuringAuth?: boolean;
}

/**
 * 
 * @export
 * @interface PublishEFTToTrancacheAndWebhookQueue
 */
export interface PublishEFTToTrancacheAndWebhookQueue {
    /**
     * 
     * @type {Array<TranlogTokenWithInjectableDomainDataToPublishToTrancacheAndWebhookQueue>}
     * @memberof PublishEFTToTrancacheAndWebhookQueue
     */
    entries: Array<TranlogTokenWithInjectableDomainDataToPublishToTrancacheAndWebhookQueue>;
}

/**
 * 
 * @export
 * @interface PublishTransferResponse
 */
export interface PublishTransferResponse {
    /**
     * 
     * @type {{ [key: string]: Cacheable; }}
     * @memberof PublishTransferResponse
     */
    transactions?: { [key: string]: Cacheable; };
}

/**
 * 
 * @export
 * @interface PullFromCardTransferResponse
 */
export interface PullFromCardTransferResponse {
    /**
     * 
     * @type {string}
     * @memberof PullFromCardTransferResponse
     */
    cardToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PullFromCardTransferResponse
     */
    transferToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PullFromCardTransferResponse
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof PullFromCardTransferResponse
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof PullFromCardTransferResponse
     */
    statementDescriptor?: string;
    /**
     * 
     * @type {string}
     * @memberof PullFromCardTransferResponse
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof PullFromCardTransferResponse
     */
    createdTime?: string;
    /**
     * 
     * @type {string}
     * @memberof PullFromCardTransferResponse
     */
    lastModifiedTime?: string;
}

/**
 * 
 * @export
 * @interface PushToCardDisburseListResponse
 */
export interface PushToCardDisburseListResponse {
    /**
     * 
     * @type {number}
     * @memberof PushToCardDisburseListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof PushToCardDisburseListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof PushToCardDisburseListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PushToCardDisburseListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<PushToCardDisbursementResponse>}
     * @memberof PushToCardDisburseListResponse
     */
    data?: Array<PushToCardDisbursementResponse>;
}

/**
 * 
 * @export
 * @interface PushToCardDisburseRequest
 */
export interface PushToCardDisburseRequest {
    /**
     * 
     * @type {string}
     * @memberof PushToCardDisburseRequest
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardDisburseRequest
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardDisburseRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardDisburseRequest
     */
    currencyCode: string;
    /**
     * 
     * @type {number}
     * @memberof PushToCardDisburseRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof PushToCardDisburseRequest
     */
    paymentInstrumentToken: string;
    /**
     * 
     * @type {PTCSoftDescriptor}
     * @memberof PushToCardDisburseRequest
     */
    softDescriptor?: PTCSoftDescriptor;
}

/**
 * 
 * @export
 * @interface PushToCardDisbursementResponse
 */
export interface PushToCardDisbursementResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof PushToCardDisbursementResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof PushToCardDisbursementResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof PushToCardDisbursementResponse
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardDisbursementResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardDisbursementResponse
     */
    currencyCode?: string;
    /**
     * 
     * @type {number}
     * @memberof PushToCardDisbursementResponse
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof PushToCardDisbursementResponse
     */
    paymentInstrumentToken?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardDisbursementResponse
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardDisbursementResponse
     */
    memo?: string;
}

/**
 * 
 * @export
 * @interface PushToCardListResponse
 */
export interface PushToCardListResponse {
    /**
     * 
     * @type {number}
     * @memberof PushToCardListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof PushToCardListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof PushToCardListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PushToCardListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<PushToCardResponse>}
     * @memberof PushToCardListResponse
     */
    data?: Array<PushToCardResponse>;
}

/**
 * 
 * @export
 * @interface PushToCardRequest
 */
export interface PushToCardRequest {
    /**
     * 
     * @type {string}
     * @memberof PushToCardRequest
     */
    address1: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardRequest
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardRequest
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardRequest
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardRequest
     */
    postalCode: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardRequest
     */
    country: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardRequest
     */
    userToken: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardRequest
     */
    nameOnCard: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardRequest
     */
    pan: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardRequest
     */
    cvv: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardRequest
     */
    expDate: string;
}

/**
 * 
 * @export
 * @interface PushToCardResponse
 */
export interface PushToCardResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof PushToCardResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof PushToCardResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof PushToCardResponse
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardResponse
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardResponse
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardResponse
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardResponse
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardResponse
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardResponse
     */
    lastFour?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardResponse
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PushToCardResponse
     */
    fastFundTransferEligible?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PushToCardResponse
     */
    gamblingFundTransferEligible?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PushToCardResponse
     */
    nameOnCard?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardResponse
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof PushToCardResponse
     */
    expDate?: string;
}

/**
 * 
 * @export
 * @interface RealTimeFeeAssessment
 */
export interface RealTimeFeeAssessment {
    /**
     * 
     * @type {string}
     * @memberof RealTimeFeeAssessment
     */
    transactionType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeFeeAssessment
     */
    internationalEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeFeeAssessment
     */
    domesticEnabled?: boolean;
}

/**
 * 
 * @export
 * @interface RealTimeFeeAssessmentRequest
 */
export interface RealTimeFeeAssessmentRequest {
    /**
     * 
     * @type {string}
     * @memberof RealTimeFeeAssessmentRequest
     */
    transactionType?: RealTimeFeeAssessmentRequest.TransactionTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeFeeAssessmentRequest
     */
    internationalEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeFeeAssessmentRequest
     */
    domesticEnabled?: boolean;
}

/**
 * @export
 * @namespace RealTimeFeeAssessmentRequest
 */
export namespace RealTimeFeeAssessmentRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionTypeEnum {
        Authorization = <any> 'authorization',
        PindebitAtmWithdrawal = <any> 'pindebit.atm.withdrawal',
        Pindebit = <any> 'pindebit'
    }
}

/**
 * 
 * @export
 * @interface RealTimeFeeGroup
 */
export interface RealTimeFeeGroup {
    /**
     * 36 char max
     * @type {string}
     * @memberof RealTimeFeeGroup
     */
    token: string;
    /**
     * 
     * @type {Date}
     * @memberof RealTimeFeeGroup
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof RealTimeFeeGroup
     */
    lastModifiedTime?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeFeeGroup
     */
    active: boolean;
    /**
     * 50 char max
     * @type {string}
     * @memberof RealTimeFeeGroup
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RealTimeFeeGroup
     */
    feeTokens?: Array<string>;
}

/**
 * 
 * @export
 * @interface RealTimeFeeGroupCreateRequest
 */
export interface RealTimeFeeGroupCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof RealTimeFeeGroupCreateRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RealTimeFeeGroupCreateRequest
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeFeeGroupCreateRequest
     */
    active?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RealTimeFeeGroupCreateRequest
     */
    feeTokens?: Array<string>;
}

/**
 * 
 * @export
 * @interface RealTimeFeeGroupListResponse
 */
export interface RealTimeFeeGroupListResponse {
    /**
     * 
     * @type {number}
     * @memberof RealTimeFeeGroupListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof RealTimeFeeGroupListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof RealTimeFeeGroupListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeFeeGroupListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<RealTimeFeeGroup>}
     * @memberof RealTimeFeeGroupListResponse
     */
    data?: Array<RealTimeFeeGroup>;
}

/**
 * 
 * @export
 * @interface RealTimeFeeGroupRequest
 */
export interface RealTimeFeeGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof RealTimeFeeGroupRequest
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeFeeGroupRequest
     */
    active?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RealTimeFeeGroupRequest
     */
    feeTokens?: Array<string>;
}

/**
 * 
 * @export
 * @interface RealTimeStandinCriteria
 */
export interface RealTimeStandinCriteria {
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeStandinCriteria
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeStandinCriteria
     */
    includeConnectionErrors?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeStandinCriteria
     */
    includeResponseTimeouts?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeStandinCriteria
     */
    includeApplicationErrors?: boolean;
}

/**
 * 
 * @export
 * @interface ReplacementAmount
 */
export interface ReplacementAmount {
    /**
     * 
     * @type {number}
     * @memberof ReplacementAmount
     */
    transactionAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof ReplacementAmount
     */
    settlementAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof ReplacementAmount
     */
    transactionFee?: number;
    /**
     * 
     * @type {number}
     * @memberof ReplacementAmount
     */
    settlementFee?: number;
    /**
     * 
     * @type {string}
     * @memberof ReplacementAmount
     */
    transactionFeeIndicator?: string;
    /**
     * 
     * @type {string}
     * @memberof ReplacementAmount
     */
    settlementFeeIndicator?: string;
}

/**
 * 
 * @export
 * @interface ReportRequest
 */
export interface ReportRequest {
    /**
     * 
     * @type {string}
     * @memberof ReportRequest
     */
    partner?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportRequest
     */
    report?: string;
    /**
     * 
     * @type {Date}
     * @memberof ReportRequest
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ReportRequest
     */
    endDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof ReportRequest
     */
    sendFiles?: boolean;
}

/**
 * 
 * @export
 * @interface RequestForApplePayWppJWT
 */
export interface RequestForApplePayWppJWT {
    /**
     * identifier for card issued by MQ
     * @type {string}
     * @memberof RequestForApplePayWppJWT
     */
    cardToken: string;
}

/**
 * 
 * @export
 * @interface RequestForWppParameters
 */
export interface RequestForWppParameters {
    /**
     * identifier for card issued by MQ
     * @type {string}
     * @memberof RequestForWppParameters
     */
    cardToken: string;
}

/**
 * 
 * @export
 * @interface ResetUserPasswordEmailModel
 */
export interface ResetUserPasswordEmailModel {
    /**
     * 
     * @type {string}
     * @memberof ResetUserPasswordEmailModel
     */
    email: string;
}

/**
 * 
 * @export
 * @interface ResetUserPasswordModel
 */
export interface ResetUserPasswordModel {
    /**
     * 
     * @type {string}
     * @memberof ResetUserPasswordModel
     */
    userToken: string;
    /**
     * 
     * @type {string}
     * @memberof ResetUserPasswordModel
     */
    newPassword: string;
}

/**
 * 
 * @export
 * @interface Response
 */
export interface Response {
    /**
     * 
     * @type {string}
     * @memberof Response
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof Response
     */
    memo: string;
    /**
     * 
     * @type {string}
     * @memberof Response
     */
    additionalInformation?: string;
}

/**
 * 
 * @export
 * @interface Result
 */
export interface Result {
    /**
     * 
     * @type {string}
     * @memberof Result
     */
    status?: string;
    /**
     * 
     * @type {Array<ResultCode>}
     * @memberof Result
     */
    codes?: Array<ResultCode>;
}

/**
 * 
 * @export
 * @interface ResultCode
 */
export interface ResultCode {
    /**
     * 
     * @type {number}
     * @memberof ResultCode
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ResultCode
     */
    mnemonic?: string;
    /**
     * 
     * @type {string}
     * @memberof ResultCode
     */
    description?: string;
    /**
     * 
     * @type {{ [key: string]: ResultCodeInfo; }}
     * @memberof ResultCode
     */
    locales?: { [key: string]: ResultCodeInfo; };
}

/**
 * 
 * @export
 * @interface ResultCodeInfo
 */
export interface ResultCodeInfo {
    /**
     * 
     * @type {string}
     * @memberof ResultCodeInfo
     */
    resultCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ResultCodeInfo
     */
    resultInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof ResultCodeInfo
     */
    extendedResultCode?: string;
}

/**
 * 
 * @export
 * @interface ReversalModel
 */
export interface ReversalModel {
    /**
     * 
     * @type {Array<NetworkFeeModel>}
     * @memberof ReversalModel
     */
    networkFees?: Array<NetworkFeeModel>;
    /**
     * 
     * @type {Webhook}
     * @memberof ReversalModel
     */
    webhook?: Webhook;
    /**
     * 
     * @type {string}
     * @memberof ReversalModel
     */
    originalTransactionToken: string;
    /**
     * 
     * @type {number}
     * @memberof ReversalModel
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof ReversalModel
     */
    findOriginalWindowDays?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ReversalModel
     */
    isAdvice?: boolean;
}

/**
 * 
 * @export
 * @interface RiskAssessment
 */
export interface RiskAssessment {
    /**
     * 
     * @type {string}
     * @memberof RiskAssessment
     */
    score?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskAssessment
     */
    version?: string;
}

/**
 * 
 * @export
 * @interface RiskcontrolTags
 */
export interface RiskcontrolTags {
    /**
     * 
     * @type {Array<string>}
     * @memberof RiskcontrolTags
     */
    values?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RiskcontrolTags
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof RiskcontrolTags
     */
    ruleName?: string;
}

/**
 * 
 * @export
 * @interface SamsungPushTokenizeRequestData
 */
export interface SamsungPushTokenizeRequestData {
    /**
     * 
     * @type {string}
     * @memberof SamsungPushTokenizeRequestData
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof SamsungPushTokenizeRequestData
     */
    lastDigits?: string;
    /**
     * 
     * @type {string}
     * @memberof SamsungPushTokenizeRequestData
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof SamsungPushTokenizeRequestData
     */
    tokenServiceProvider?: string;
    /**
     * 
     * @type {string}
     * @memberof SamsungPushTokenizeRequestData
     */
    extraProvisionPayload?: string;
    /**
     * 
     * @type {string}
     * @memberof SamsungPushTokenizeRequestData
     */
    cardType?: string;
}

/**
 * 
 * @export
 * @interface SelectiveAuth
 */
export interface SelectiveAuth {
    /**
     * 
     * @type {number}
     * @memberof SelectiveAuth
     */
    saMode?: SelectiveAuth.SaModeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof SelectiveAuth
     */
    enableRegexSearchChain?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SelectiveAuth
     */
    dmdLocationSensitivity?: SelectiveAuth.DmdLocationSensitivityEnum;
}

/**
 * @export
 * @namespace SelectiveAuth
 */
export namespace SelectiveAuth {
    /**
     * @export
     * @enum {string}
     */
    export enum SaModeEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2
    }
    /**
     * @export
     * @enum {string}
     */
    export enum DmdLocationSensitivityEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1,
        NUMBER_2 = <any> 2,
        NUMBER_3 = <any> 3,
        NUMBER_4 = <any> 4
    }
}

/**
 * 
 * @export
 * @interface SendingProvisioningDataToGooglePayBackendRequest
 */
export interface SendingProvisioningDataToGooglePayBackendRequest {
    /**
     * A string that identifies the backend session. Provided by Google pay backend.
     * @type {string}
     * @memberof SendingProvisioningDataToGooglePayBackendRequest
     */
    serverSessionId: string;
    /**
     * A string that identifies the client session. Provided by Google pay backend.
     * @type {string}
     * @memberof SendingProvisioningDataToGooglePayBackendRequest
     */
    clientSessionId: string;
    /**
     * 1 => Tokenization will be attempted.; 0 =>Tokenization will not be attempted.
     * @type {number}
     * @memberof SendingProvisioningDataToGooglePayBackendRequest
     */
    tokenSetting: SendingProvisioningDataToGooglePayBackendRequest.TokenSettingEnum;
    /**
     * 1 => FPAN save will be attempted.; 0 => FPAN save will not be attempted.
     * @type {number}
     * @memberof SendingProvisioningDataToGooglePayBackendRequest
     */
    cardSetting: SendingProvisioningDataToGooglePayBackendRequest.CardSettingEnum;
    /**
     * String identifying the device-scoped Google Pay wallet that will receive the token. Provided by Google Pay backend.
     * @type {string}
     * @memberof SendingProvisioningDataToGooglePayBackendRequest
     */
    publicWalletId: string;
    /**
     * String identifying the Android device that will receive the token. Provided by Google Pay backend
     * @type {string}
     * @memberof SendingProvisioningDataToGooglePayBackendRequest
     */
    publicDeviceId: string;
    /**
     * identifier for card issued by MQ
     * @type {string}
     * @memberof SendingProvisioningDataToGooglePayBackendRequest
     */
    cardToken: string;
    /**
     * A Google-assigned string that uniquely identifies both the integrator that is initiating the session and the issuer of the payment card.
     * @type {string}
     * @memberof SendingProvisioningDataToGooglePayBackendRequest
     */
    integratorId: string;
}

/**
 * @export
 * @namespace SendingProvisioningDataToGooglePayBackendRequest
 */
export namespace SendingProvisioningDataToGooglePayBackendRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TokenSettingEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
    /**
     * @export
     * @enum {string}
     */
    export enum CardSettingEnum {
        NUMBER_0 = <any> 0,
        NUMBER_1 = <any> 1
    }
}

/**
 * 
 * @export
 * @interface SettlementData
 */
export interface SettlementData {
    /**
     * 
     * @type {number}
     * @memberof SettlementData
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof SettlementData
     */
    conversionRate?: number;
    /**
     * 
     * @type {string}
     * @memberof SettlementData
     */
    currencyCode?: string;
}

/**
 * 
 * @export
 * @interface Shipping
 */
export interface Shipping {
    /**
     * 
     * @type {string}
     * @memberof Shipping
     */
    method?: Shipping.MethodEnum;
    /**
     * 
     * @type {FulfillmentAddressRequest}
     * @memberof Shipping
     */
    returnAddress?: FulfillmentAddressRequest;
    /**
     * 
     * @type {FulfillmentAddressRequest}
     * @memberof Shipping
     */
    recipientAddress?: FulfillmentAddressRequest;
    /**
     * 255 char max
     * @type {string}
     * @memberof Shipping
     */
    careOfLine?: string;
}

/**
 * @export
 * @namespace Shipping
 */
export namespace Shipping {
    /**
     * @export
     * @enum {string}
     */
    export enum MethodEnum {
        LOCALMAIL = <any> 'LOCAL_MAIL',
        LOCALMAILPACKAGE = <any> 'LOCAL_MAIL_PACKAGE',
        GROUND = <any> 'GROUND',
        TWODAY = <any> 'TWO_DAY',
        OVERNIGHT = <any> 'OVERNIGHT',
        INTERNATIONAL = <any> 'INTERNATIONAL',
        INTERNATIONALPRIORITY = <any> 'INTERNATIONAL_PRIORITY',
        LOCALPRIORITY = <any> 'LOCAL_PRIORITY',
        FEDEXEXPEDITED = <any> 'FEDEX_EXPEDITED',
        FEDEXREGULAR = <any> 'FEDEX_REGULAR',
        UPSEXPEDITED = <any> 'UPS_EXPEDITED',
        UPSREGULAR = <any> 'UPS_REGULAR',
        USPSEXPEDITED = <any> 'USPS_EXPEDITED',
        USPSREGULAR = <any> 'USPS_REGULAR'
    }
}

/**
 * 
 * @export
 * @interface ShippingInformationResponse
 */
export interface ShippingInformationResponse {
    /**
     * 
     * @type {string}
     * @memberof ShippingInformationResponse
     */
    method?: ShippingInformationResponse.MethodEnum;
    /**
     * 
     * @type {FulfillmentAddressResponse}
     * @memberof ShippingInformationResponse
     */
    returnAddress?: FulfillmentAddressResponse;
    /**
     * 
     * @type {FulfillmentAddressResponse}
     * @memberof ShippingInformationResponse
     */
    recipientAddress?: FulfillmentAddressResponse;
    /**
     * 255 char max
     * @type {string}
     * @memberof ShippingInformationResponse
     */
    careOfLine?: string;
}

/**
 * @export
 * @namespace ShippingInformationResponse
 */
export namespace ShippingInformationResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum MethodEnum {
        LOCALMAIL = <any> 'LOCAL_MAIL',
        LOCALMAILPACKAGE = <any> 'LOCAL_MAIL_PACKAGE',
        GROUND = <any> 'GROUND',
        TWODAY = <any> 'TWO_DAY',
        OVERNIGHT = <any> 'OVERNIGHT',
        INTERNATIONAL = <any> 'INTERNATIONAL',
        INTERNATIONALPRIORITY = <any> 'INTERNATIONAL_PRIORITY',
        LOCALPRIORITY = <any> 'LOCAL_PRIORITY',
        FEDEXEXPEDITED = <any> 'FEDEX_EXPEDITED',
        FEDEXREGULAR = <any> 'FEDEX_REGULAR',
        UPSEXPEDITED = <any> 'UPS_EXPEDITED',
        UPSREGULAR = <any> 'UPS_REGULAR',
        USPSEXPEDITED = <any> 'USPS_EXPEDITED',
        USPSREGULAR = <any> 'USPS_REGULAR'
    }
}

/**
 * 
 * @export
 * @interface SimulateIncrementalAuthRequest
 */
export interface SimulateIncrementalAuthRequest {
    /**
     * The card token of the original transaction
     * @type {string}
     * @memberof SimulateIncrementalAuthRequest
     */
    cardToken: string;
    /**
     * The amount of the transaction in the clearing currency
     * @type {number}
     * @memberof SimulateIncrementalAuthRequest
     */
    amount: number;
    /**
     * The ISO-3166-1 Alpha-3 or Numeric code for the clearing currency for the transaction
     * @type {string}
     * @memberof SimulateIncrementalAuthRequest
     */
    settlementCurrency?: string;
    /**
     * The amount of the transaction in the local currency
     * @type {number}
     * @memberof SimulateIncrementalAuthRequest
     */
    localAmount?: number;
    /**
     * The ISO-3166-1 Alpha-3 or Numeric code for the local currency
     * @type {string}
     * @memberof SimulateIncrementalAuthRequest
     */
    localCurrency?: string;
    /**
     * The conversion rate between the local and settlement currencies
     * @type {number}
     * @memberof SimulateIncrementalAuthRequest
     */
    currencyConversionRate?: number;
    /**
     * The transaction network for the authorization
     * @type {string}
     * @memberof SimulateIncrementalAuthRequest
     */
    network: SimulateIncrementalAuthRequest.NetworkEnum;
    /**
     * The transaction sub-network for the authorization
     * @type {string}
     * @memberof SimulateIncrementalAuthRequest
     */
    subNetwork?: SimulateIncrementalAuthRequest.SubNetworkEnum;
    /**
     * The merchant id for the transaction
     * @type {string}
     * @memberof SimulateIncrementalAuthRequest
     */
    merchantId: string;
    /**
     * The webhook the transaction should be passed to
     * @type {Webhook}
     * @memberof SimulateIncrementalAuthRequest
     */
    webhook?: Webhook;
    /**
     * The network fees for the transaction
     * @type {Array<NetworkFeeModel>}
     * @memberof SimulateIncrementalAuthRequest
     */
    networkFees?: Array<NetworkFeeModel>;
    /**
     * The network reference id from the original transaction
     * @type {string}
     * @memberof SimulateIncrementalAuthRequest
     */
    networkReferenceId: string;
}

/**
 * @export
 * @namespace SimulateIncrementalAuthRequest
 */
export namespace SimulateIncrementalAuthRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum NetworkEnum {
        MARQETA = <any> 'MARQETA',
        DISCOVER = <any> 'DISCOVER',
        MASTERCARD = <any> 'MASTERCARD',
        PULSE = <any> 'PULSE',
        VISA = <any> 'VISA'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SubNetworkEnum {
        VISANET = <any> 'VISANET',
        VISANETDEBIT = <any> 'VISANETDEBIT',
        VISAINTERLINK = <any> 'VISAINTERLINK',
        VISAPLUS = <any> 'VISAPLUS',
        MAESTRO = <any> 'MAESTRO',
        CIRRUS = <any> 'CIRRUS',
        MASTERCARDDEBIT = <any> 'MASTERCARDDEBIT',
        GATEWAYJIT = <any> 'GATEWAY_JIT',
        MANAGEDJIT = <any> 'MANAGED_JIT'
    }
}

/**
 * 
 * @export
 * @interface SimulatePinDebitAuthRequest
 */
export interface SimulatePinDebitAuthRequest {
    /**
     * The card token of the original transaction
     * @type {string}
     * @memberof SimulatePinDebitAuthRequest
     */
    cardToken: string;
    /**
     * The amount of the transaction in the clearing currency
     * @type {number}
     * @memberof SimulatePinDebitAuthRequest
     */
    amount: number;
    /**
     * The ISO-3166-1 Alpha-3 or Numeric code for the clearing currency for the transaction
     * @type {string}
     * @memberof SimulatePinDebitAuthRequest
     */
    settlementCurrency?: string;
    /**
     * The amount of the transaction in the local currency
     * @type {number}
     * @memberof SimulatePinDebitAuthRequest
     */
    localAmount?: number;
    /**
     * The ISO-3166-1 Alpha-3 or Numeric code for the local currency
     * @type {string}
     * @memberof SimulatePinDebitAuthRequest
     */
    localCurrency?: string;
    /**
     * The conversion rate between the local and settlement currencies
     * @type {number}
     * @memberof SimulatePinDebitAuthRequest
     */
    currencyConversionRate?: number;
    /**
     * The transaction network for the authorization
     * @type {string}
     * @memberof SimulatePinDebitAuthRequest
     */
    network: SimulatePinDebitAuthRequest.NetworkEnum;
    /**
     * The transaction sub-network for the authorization
     * @type {string}
     * @memberof SimulatePinDebitAuthRequest
     */
    subNetwork?: SimulatePinDebitAuthRequest.SubNetworkEnum;
    /**
     * The merchant id for the transaction
     * @type {string}
     * @memberof SimulatePinDebitAuthRequest
     */
    merchantId: string;
    /**
     * The webhook the transaction should be passed to
     * @type {Webhook}
     * @memberof SimulatePinDebitAuthRequest
     */
    webhook?: Webhook;
    /**
     * The network fees for the transaction
     * @type {Array<NetworkFeeModel>}
     * @memberof SimulatePinDebitAuthRequest
     */
    networkFees?: Array<NetworkFeeModel>;
}

/**
 * @export
 * @namespace SimulatePinDebitAuthRequest
 */
export namespace SimulatePinDebitAuthRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum NetworkEnum {
        MARQETA = <any> 'MARQETA',
        DISCOVER = <any> 'DISCOVER',
        MASTERCARD = <any> 'MASTERCARD',
        PULSE = <any> 'PULSE',
        VISA = <any> 'VISA'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SubNetworkEnum {
        VISANET = <any> 'VISANET',
        VISANETDEBIT = <any> 'VISANETDEBIT',
        VISAINTERLINK = <any> 'VISAINTERLINK',
        VISAPLUS = <any> 'VISAPLUS',
        MAESTRO = <any> 'MAESTRO',
        CIRRUS = <any> 'CIRRUS',
        MASTERCARDDEBIT = <any> 'MASTERCARDDEBIT',
        GATEWAYJIT = <any> 'GATEWAY_JIT',
        MANAGEDJIT = <any> 'MANAGED_JIT'
    }
}

/**
 * 
 * @export
 * @interface SimulationResponseModel
 */
export interface SimulationResponseModel {
    /**
     * 
     * @type {TransactionModel}
     * @memberof SimulationResponseModel
     */
    transaction?: TransactionModel;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SimulationResponseModel
     */
    rawIso8583?: { [key: string]: any; };
}

/**
 * 
 * @export
 * @interface Special
 */
export interface Special {
    /**
     * 
     * @type {boolean}
     * @memberof Special
     */
    merchantOnBoarding?: boolean;
}

/**
 * 
 * @export
 * @interface SpendControlAssociation
 */
export interface SpendControlAssociation {
    /**
     * 
     * @type {string}
     * @memberof SpendControlAssociation
     */
    cardProductToken?: string;
    /**
     * 
     * @type {string}
     * @memberof SpendControlAssociation
     */
    userToken?: string;
}

/**
 * 
 * @export
 * @interface SsnResponseModel
 */
export interface SsnResponseModel {
    /**
     * 
     * @type {string}
     * @memberof SsnResponseModel
     */
    ssn?: string;
    /**
     * 
     * @type {string}
     * @memberof SsnResponseModel
     */
    tin?: string;
    /**
     * 
     * @type {string}
     * @memberof SsnResponseModel
     */
    sin?: string;
    /**
     * 
     * @type {string}
     * @memberof SsnResponseModel
     */
    nin?: string;
}

/**
 * 
 * @export
 * @interface StoreResponseModel
 */
export interface StoreResponseModel {
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof StoreResponseModel
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    contact?: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    contactEmail?: string;
    /**
     * 
     * @type {number}
     * @memberof StoreResponseModel
     */
    longitude?: number;
    /**
     * 
     * @type {number}
     * @memberof StoreResponseModel
     */
    latitude?: number;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    address1: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    province?: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    country?: string;
    /**
     * The unique identifier of the merchant
     * @type {string}
     * @memberof StoreResponseModel
     */
    token?: string;
    /**
     * 1 char max
     * @type {boolean}
     * @memberof StoreResponseModel
     */
    partialAuthFlag?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    mid: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    networkMid?: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponseModel
     */
    merchantToken: string;
    /**
     * 
     * @type {boolean}
     * @memberof StoreResponseModel
     */
    partialApprovalCapable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StoreResponseModel
     */
    keyedAuthCvvEnforced?: boolean;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof StoreResponseModel
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof StoreResponseModel
     */
    lastModifiedTime: Date;
}

/**
 * 
 * @export
 * @interface StrongCustomerAuthenticationLimits
 */
export interface StrongCustomerAuthenticationLimits {
    /**
     * 
     * @type {number}
     * @memberof StrongCustomerAuthenticationLimits
     */
    scaContactlessTransactionLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof StrongCustomerAuthenticationLimits
     */
    scaContactlessCumulativeAmountLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof StrongCustomerAuthenticationLimits
     */
    scaContactlessTransactionsCountLimit?: number;
    /**
     * 
     * @type {string}
     * @memberof StrongCustomerAuthenticationLimits
     */
    scaContactlessTransactionsCurrency?: string;
    /**
     * 
     * @type {number}
     * @memberof StrongCustomerAuthenticationLimits
     */
    scaLvpTransactionLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof StrongCustomerAuthenticationLimits
     */
    scaLvpCumulativeAmountLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof StrongCustomerAuthenticationLimits
     */
    scaLvpTransactionsCountLimit?: number;
    /**
     * 
     * @type {string}
     * @memberof StrongCustomerAuthenticationLimits
     */
    scaLvpTransactionsCurrency?: string;
    /**
     * 
     * @type {number}
     * @memberof StrongCustomerAuthenticationLimits
     */
    scaTraExemptionAmountLimit?: number;
}

/**
 * 
 * @export
 * @interface TabaPayAccounts
 */
export interface TabaPayAccounts {
    /**
     * 
     * @type {string}
     * @memberof TabaPayAccounts
     */
    sourceAccountID?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayAccounts
     */
    destinationAccountID?: string;
}

/**
 * 
 * @export
 * @interface TabaPayAddPaymentInstrumentRequest
 */
export interface TabaPayAddPaymentInstrumentRequest {
    /**
     * 
     * @type {TabaPayAddPaymentInstrumentRequest}
     * @memberof TabaPayAddPaymentInstrumentRequest
     */
    entity?: TabaPayAddPaymentInstrumentRequest;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TabaPayAddPaymentInstrumentRequest
     */
    tags?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof TabaPayAddPaymentInstrumentRequest
     */
    referenceID?: string;
    /**
     * 
     * @type {TabaPayCard}
     * @memberof TabaPayAddPaymentInstrumentRequest
     */
    card?: TabaPayCard;
    /**
     * 
     * @type {TabaPayOwner}
     * @memberof TabaPayAddPaymentInstrumentRequest
     */
    owner?: TabaPayOwner;
}

/**
 * 
 * @export
 * @interface TabaPayCard
 */
export interface TabaPayCard {
    /**
     * 
     * @type {string}
     * @memberof TabaPayCard
     */
    accountNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayCard
     */
    expirationDate?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayCard
     */
    securityCode?: string;
    /**
     * 
     * @type {TabaPayPush}
     * @memberof TabaPayCard
     */
    push?: TabaPayPush;
}

/**
 * 
 * @export
 * @interface TabaPayName
 */
export interface TabaPayName {
    /**
     * 
     * @type {string}
     * @memberof TabaPayName
     */
    first?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayName
     */
    middle?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayName
     */
    last?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayName
     */
    suffix?: string;
}

/**
 * 
 * @export
 * @interface TabaPayOwner
 */
export interface TabaPayOwner {
    /**
     * 
     * @type {TabaPayName}
     * @memberof TabaPayOwner
     */
    name?: TabaPayName;
    /**
     * 
     * @type {TabapayPTCAddress}
     * @memberof TabaPayOwner
     */
    address?: TabapayPTCAddress;
}

/**
 * 
 * @export
 * @interface TabaPayPayoutRequest
 */
export interface TabaPayPayoutRequest {
    /**
     * 
     * @type {TabaPayPayoutRequest}
     * @memberof TabaPayPayoutRequest
     */
    entity?: TabaPayPayoutRequest;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TabaPayPayoutRequest
     */
    tags?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof TabaPayPayoutRequest
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayPayoutRequest
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayPayoutRequest
     */
    referenceID?: string;
    /**
     * 
     * @type {TabaPayAccounts}
     * @memberof TabaPayPayoutRequest
     */
    accounts?: TabaPayAccounts;
    /**
     * 
     * @type {string}
     * @memberof TabaPayPayoutRequest
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayPayoutRequest
     */
    timeout?: string;
    /**
     * 
     * @type {TabapaySoftDescriptor}
     * @memberof TabaPayPayoutRequest
     */
    softDescriptor?: TabapaySoftDescriptor;
    /**
     * 
     * @type {string}
     * @memberof TabaPayPayoutRequest
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface TabaPayPush
 */
export interface TabaPayPush {
    /**
     * 
     * @type {string}
     * @memberof TabaPayPush
     */
    enabled?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayPush
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayPush
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayPush
     */
    availability?: string;
    /**
     * 
     * @type {string}
     * @memberof TabaPayPush
     */
    currency?: string;
}

/**
 * 
 * @export
 * @interface TabapayPTCAddress
 */
export interface TabapayPTCAddress {
    /**
     * 
     * @type {string}
     * @memberof TabapayPTCAddress
     */
    line1: string;
    /**
     * 
     * @type {string}
     * @memberof TabapayPTCAddress
     */
    line2?: string;
    /**
     * 
     * @type {string}
     * @memberof TabapayPTCAddress
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof TabapayPTCAddress
     */
    county: string;
    /**
     * 
     * @type {string}
     * @memberof TabapayPTCAddress
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof TabapayPTCAddress
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof TabapayPTCAddress
     */
    zipcode?: string;
}

/**
 * 
 * @export
 * @interface TabapaySoftDescriptor
 */
export interface TabapaySoftDescriptor {
    /**
     * 
     * @type {string}
     * @memberof TabapaySoftDescriptor
     */
    name?: string;
    /**
     * 
     * @type {TabapayPTCAddress}
     * @memberof TabapaySoftDescriptor
     */
    address?: TabapayPTCAddress;
    /**
     * 
     * @type {TabapaySoftDescriptorPhone}
     * @memberof TabapaySoftDescriptor
     */
    phone?: TabapaySoftDescriptorPhone;
    /**
     * 
     * @type {string}
     * @memberof TabapaySoftDescriptor
     */
    email?: string;
}

/**
 * 
 * @export
 * @interface TabapaySoftDescriptorPhone
 */
export interface TabapaySoftDescriptorPhone {
    /**
     * 
     * @type {string}
     * @memberof TabapaySoftDescriptorPhone
     */
    countryCode?: string;
    /**
     * 
     * @type {string}
     * @memberof TabapaySoftDescriptorPhone
     */
    number?: string;
}

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface TerminalModel
 */
export interface TerminalModel {
    /**
     * 
     * @type {string}
     * @memberof TerminalModel
     */
    tid?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalModel
     */
    partialApprovalCapable?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalModel
     */
    cardholderPresence?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalModel
     */
    cardPresence?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalModel
     */
    channel?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalModel
     */
    processingType?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalModel
     */
    pinPresent?: string;
    /**
     * 
     * @type {string}
     * @memberof TerminalModel
     */
    specialConditionIndicator?: TerminalModel.SpecialConditionIndicatorEnum;
}

/**
 * @export
 * @namespace TerminalModel
 */
export namespace TerminalModel {
    /**
     * @export
     * @enum {string}
     */
    export enum SpecialConditionIndicatorEnum {
        UNSPECIFIED = <any> 'UNSPECIFIED',
        CRYPTOCURRENCYPURCHASE = <any> 'CRYPTOCURRENCY_PURCHASE',
        QUASICASH = <any> 'QUASI_CASH',
        DEBTPAYMENT = <any> 'DEBT_PAYMENT'
    }
}

/**
 * 
 * @export
 * @interface Text
 */
export interface Text {
    /**
     * 
     * @type {TextValue}
     * @memberof Text
     */
    nameLine1: TextValue;
    /**
     * 
     * @type {TextValue}
     * @memberof Text
     */
    nameLine2?: TextValue;
    /**
     * 
     * @type {TextValue}
     * @memberof Text
     */
    nameLine3?: TextValue;
}

/**
 * 
 * @export
 * @interface TextValue
 */
export interface TextValue {
    /**
     * 
     * @type {string}
     * @memberof TextValue
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    token?: string;
    /**
     * required if 'business_token' is null
     * @type {string}
     * @memberof TokenRequest
     */
    userToken?: string;
    /**
     * required if 'user_token' is null
     * @type {string}
     * @memberof TokenRequest
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    accountNumber: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    cvvNumber: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    expDate: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    postalCode?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenRequest
     */
    isDefaultAccount?: boolean;
}

/**
 * 
 * @export
 * @interface TokenServiceProvider
 */
export interface TokenServiceProvider {
    /**
     * 
     * @type {string}
     * @memberof TokenServiceProvider
     */
    tokenReferenceId?: string;
    /**
     * 50 char max
     * @type {string}
     * @memberof TokenServiceProvider
     */
    panReferenceId: string;
    /**
     * 
     * @type {string}
     * @memberof TokenServiceProvider
     */
    correlationId?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenServiceProvider
     */
    tokenRequestorId?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenServiceProvider
     */
    tokenRequestorName?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenServiceProvider
     */
    tokenType?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenServiceProvider
     */
    tokenPan?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenServiceProvider
     */
    tokenExpiration?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenServiceProvider
     */
    tokenScore?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenServiceProvider
     */
    tokenAssuranceLevel?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenServiceProvider
     */
    tokenEligibilityDecision?: string;
}

/**
 * 
 * @export
 * @interface TokenUpdateRequest
 */
export interface TokenUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenUpdateRequest
     */
    expDate: string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenUpdateRequest
     */
    active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TokenUpdateRequest
     */
    isDefaultAccount?: boolean;
}

/**
 * 
 * @export
 * @interface Track1Data
 */
export interface Track1Data {
    /**
     * 
     * @type {string}
     * @memberof Track1Data
     */
    cvv?: string;
    /**
     * 
     * @type {string}
     * @memberof Track1Data
     */
    atc?: string;
}

/**
 * 
 * @export
 * @interface TranLogAttributeRequest
 */
export interface TranLogAttributeRequest {
    /**
     * 
     * @type {string}
     * @memberof TranLogAttributeRequest
     */
    transactionToken: string;
    /**
     * 
     * @type {string}
     * @memberof TranLogAttributeRequest
     */
    attributeName: TranLogAttributeRequest.AttributeNameEnum;
    /**
     * 
     * @type {string}
     * @memberof TranLogAttributeRequest
     */
    attributeValue: string;
}

/**
 * @export
 * @namespace TranLogAttributeRequest
 */
export namespace TranLogAttributeRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum AttributeNameEnum {
        FUELTYPE = <any> 'FUEL_TYPE',
        NUMGALLONS = <any> 'NUM_GALLONS',
        PRICEPERGALLON = <any> 'PRICE_PER_GALLON',
        EARNCARDHOLDERREWARD = <any> 'EARN_CARDHOLDER_REWARD',
        TRANLIFECYCLE = <any> 'TRAN_LIFE_CYCLE',
        MULTICLEARINGSEQ = <any> 'MULTI_CLEARING_SEQ',
        MULTICLEARINGFINALCOMPLETIONID = <any> 'MULTI_CLEARING_FINAL_COMPLETION_ID',
        POSENTRYCODE = <any> 'POS_ENTRY_CODE',
        PROCESSINGCODE = <any> 'PROCESSING_CODE',
        INTERCHANGERATEDESCRIPTOR = <any> 'INTERCHANGE_RATE_DESCRIPTOR',
        TERMINALTYPE = <any> 'TERMINAL_TYPE',
        SETTLEMENTINDICATOR = <any> 'SETTLEMENT_INDICATOR',
        CARDPRESENT = <any> 'CARD_PRESENT',
        CARDHOLDERPRESENT = <any> 'CARD_HOLDER_PRESENT',
        TRANORIGIN = <any> 'TRAN_ORIGIN',
        FINDORIGINALFINDER = <any> 'FIND_ORIGINAL_FINDER',
        MANUALNOTE = <any> 'MANUAL_NOTE',
        POSTDATEMODIFICATION = <any> 'POST_DATE_MODIFICATION',
        CLEARINGRECORDHASH = <any> 'CLEARING_RECORD_HASH',
        CLEARINGRAWRECORDHASH = <any> 'CLEARING_RAW_RECORD_HASH',
        CLEARINGRECORDFILENAME = <any> 'CLEARING_RECORD_FILE_NAME',
        CLEARINGRECORDSEQUENCENUMBER = <any> 'CLEARING_RECORD_SEQUENCE_NUMBER',
        TOKENELAPSEDTIMETOLIVEFORANLUK = <any> 'TOKEN_ELAPSED_TIME_TO_LIVE_FOR_AN_LUK',
        TOKENCOUNTOFTRANSACTIONFORANLUK = <any> 'TOKEN_COUNT_OF_TRANSACTION_FOR_AN_LUK',
        TOKENCUMULATIVETOTALTRANSACTIONAMOUNTFORANLUK = <any> 'TOKEN_CUMULATIVE_TOTAL_TRANSACTION_AMOUNT_FOR_AN_LUK',
        INCREMENTALCUMULATIVEAMOUNT = <any> 'INCREMENTAL_CUMULATIVE_AMOUNT',
        FINALINCREMENTALAUTH = <any> 'FINAL_INCREMENTAL_AUTH',
        NETWORKFEESMODEL = <any> 'NETWORK_FEES_MODEL',
        ECOMMERCESECURITYLEVELINDICATOR = <any> 'ECOMMERCE_SECURITY_LEVEL_INDICATOR',
        PAYMENTCHANNEL = <any> 'PAYMENT_CHANNEL',
        PAYMENTINSTRUMENT = <any> 'PAYMENT_INSTRUMENT',
        PAYMENTACCOUNTREFERENCE = <any> 'PAYMENT_ACCOUNT_REFERENCE',
        PINPRESENT = <any> 'PIN_PRESENT',
        TERMINALPARTIALAPPROVALCAPABLE = <any> 'TERMINAL_PARTIAL_APPROVAL_CAPABLE',
        STIPREASONCODE = <any> 'STIP_REASON_CODE',
        STIPEXTENDEDREASONCODE = <any> 'STIP_EXTENDED_REASON_CODE',
        ISRECURRING = <any> 'IS_RECURRING',
        ISINSTALLMENT = <any> 'IS_INSTALLMENT',
        TRANSACTIONINTEGRITYCLASS = <any> 'TRANSACTION_INTEGRITY_CLASS',
        DYNAMICCVVATC = <any> 'DYNAMIC_CVV_ATC',
        STANDINAPPROVEDBY = <any> 'STANDIN_APPROVED_BY',
        STANDINBY = <any> 'STANDIN_BY',
        ORIGINALCURRENCYCODE = <any> 'ORIGINAL_CURRENCY_CODE',
        DYNAMICCURRENCYCONVERSION = <any> 'DYNAMIC_CURRENCY_CONVERSION',
        CARDHOLDERBILLINGCONVERSIONRATE = <any> 'CARDHOLDER_BILLING_CONVERSION_RATE',
        CARDHOLDERBILLINGCONVERSIONDATE = <any> 'CARDHOLDER_BILLING_CONVERSION_DATE',
        ISITSTIPAPPROVAL = <any> 'IS_IT_STIP_APPROVAL',
        ECOMMERCEAUTHENTICATIONDATA = <any> 'ECOMMERCE_AUTHENTICATION_DATA',
        CAVVRESULTCODE = <any> 'CAVV_RESULT_CODE',
        NETWORKTRANSACTIONAMOUNTDE4 = <any> 'NETWORK_TRANSACTION_AMOUNT_DE_4',
        NETWORKSETTLEMENTAMOUNTDE5 = <any> 'NETWORK_SETTLEMENT_AMOUNT_DE_5',
        NETWORKCARDHOLDERBILLINGAMOUNTDE6 = <any> 'NETWORK_CARDHOLDER_BILLING_AMOUNT_DE_6',
        NETWORKFEEAMOUNTDE28 = <any> 'NETWORK_FEE_AMOUNT_DE_28',
        NETWORKCASHBACKAMOUNTOTHERDE54 = <any> 'NETWORK_CASHBACK_AMOUNT_OTHER_DE_54',
        NETWORKREPLACEMENTAMOUNTOTHERDE61 = <any> 'NETWORK_REPLACEMENT_AMOUNT_OTHER_DE_61',
        NETWORKREPLACEMENTAMOUNTDE95 = <any> 'NETWORK_REPLACEMENT_AMOUNT_DE_95',
        ADVICEDETAILCODE = <any> 'ADVICE_DETAIL_CODE',
        ASYNCREQUESTTOKEN = <any> 'ASYNC_REQUEST_TOKEN',
        TXNMCC = <any> 'TXN_MCC',
        EXTRAFIELDS = <any> 'EXTRA_FIELDS',
        SURCHARGEFREEATMNETWORK = <any> 'SURCHARGE_FREE_ATM_NETWORK',
        NETWORKPRODUCTID = <any> 'NETWORK_PRODUCT_ID',
        NETWORKPROGRAMID = <any> 'NETWORK_PROGRAM_ID',
        NETWORKSPENDQUALIFIER = <any> 'NETWORK_SPEND_QUALIFIER',
        THREEDSCAVVVERSION = <any> 'THREE_DS_CAVV_VERSION',
        THREEDSMESSAGEVERSION = <any> 'THREE_DS_MESSAGE_VERSION',
        THREEDSAUTHENTICATIONMETHOD = <any> 'THREE_DS_AUTHENTICATION_METHOD',
        THREEDSAUTHENTICATIONSTATUS = <any> 'THREE_DS_AUTHENTICATION_STATUS',
        THREEDSACQUIREREXEMPTION = <any> 'THREE_DS_ACQUIRER_EXEMPTION',
        MOTOINDICATOR = <any> 'MOTO_INDICATOR',
        PREAUTHTIMELIMIT = <any> 'PREAUTH_TIME_LIMIT',
        AUTHORIZATIONSOURCECODE = <any> 'AUTHORIZATION_SOURCE_CODE',
        OCTUNIQUETRANSACTIONREFERENCENUMBER = <any> 'OCT_UNIQUE_TRANSACTION_REFERENCE_NUMBER',
        ISFUNDINGTRANSACTION = <any> 'IS_FUNDING_TRANSACTION',
        CARDHOLDERSETTLEMENTCONVERSIONRATE = <any> 'CARDHOLDER_SETTLEMENT_CONVERSION_RATE',
        SETTLEMENTCURRENCYCODE = <any> 'SETTLEMENT_CURRENCY_CODE',
        ENHANCEDDATATOKEN = <any> 'ENHANCED_DATA_TOKEN',
        DDEARLYPAYELIGIBLE = <any> 'DD_EARLY_PAY_ELIGIBLE',
        DDEARLYPAYSETTLEMENTDATE = <any> 'DD_EARLY_PAY_SETTLEMENT_DATE',
        CURRENCYCONVERSIONASSESSMENT = <any> 'CURRENCY_CONVERSION_ASSESSMENT',
        THREEDSISSUEREXEMPTION = <any> 'THREE_DS_ISSUER_EXEMPTION',
        MERCHANTTAXID = <any> 'MERCHANT_TAX_ID',
        MERCHANTORIGINCOUNTRYCODE = <any> 'MERCHANT_ORIGIN_COUNTRY_CODE',
        NETWORKACCOUNTINTELLIGENCESCORE = <any> 'NETWORK_ACCOUNT_INTELLIGENCE_SCORE',
        NETWORKASSIGNEDID = <any> 'NETWORK_ASSIGNED_ID',
        REALTIMEFEETYPE = <any> 'REAL_TIME_FEE_TYPE',
        OCTTYPE = <any> 'OCT_TYPE',
        ONELEGOUT = <any> 'ONE_LEG_OUT',
        ATCVALUE = <any> 'ATC_VALUE',
        ATCDISCREPANCYVALUE = <any> 'ATC_DISCREPANCY_VALUE',
        ATCDISCREPANCYINDICATOR = <any> 'ATC_DISCREPANCY_INDICATOR',
        ISAINDICATOR = <any> 'ISA_INDICATOR',
        ACCOUNTIDENTIFICATION1 = <any> 'ACCOUNT_IDENTIFICATION_1',
        INSTALLMENTPAYMENTFREQUENCY = <any> 'INSTALLMENT_PAYMENT_FREQUENCY',
        INSTALLMENTPAYMENTFIRSTINSTALLMENTDATE = <any> 'INSTALLMENT_PAYMENT_FIRST_INSTALLMENT_DATE',
        INSTALLMENTPAYMENTTOTALAMOUNTFUNDED = <any> 'INSTALLMENT_PAYMENT_TOTAL_AMOUNT_FUNDED',
        INSTALLMENTPAYMENTPAYMENTTYPE = <any> 'INSTALLMENT_PAYMENT_PAYMENT_TYPE',
        DWTDEVICEID = <any> 'DWT_DEVICE_ID',
        DWTDEVICENUMBER = <any> 'DWT_DEVICE_NUMBER',
        DWTDEVICELOCATION = <any> 'DWT_DEVICE_LOCATION',
        DWTDEVICEIPADDRESS = <any> 'DWT_DEVICE_IP_ADDRESS',
        DWTWALLETPROVIDERACCOUNTEMAILADDRESS = <any> 'DWT_WALLET_PROVIDER_ACCOUNT_EMAIL_ADDRESS',
        DWTTRUSTEDTOKENDAFINDICATOR = <any> 'DWT_TRUSTED_TOKEN_DAF_INDICATOR',
        DWTTRUSTEDTOKENAUTHMETHODA = <any> 'DWT_TRUSTED_TOKEN_AUTH_METHOD_A',
        DWTTRUSTEDTOKENAUTHMETHODB = <any> 'DWT_TRUSTED_TOKEN_AUTH_METHOD_B',
        DWTTRUSTEDTOKENBOUNDDEVICEINDEX = <any> 'DWT_TRUSTED_TOKEN_BOUND_DEVICE_INDEX',
        DWTTRUSTEDTOKENAPPLICATIONTYPE = <any> 'DWT_TRUSTED_TOKEN_APPLICATION_TYPE',
        DWTTRUSTEDTOKENUSERIDENTIFIER = <any> 'DWT_TRUSTED_TOKEN_USER_IDENTIFIER',
        DWTTRUSTEDTOKENAUTHAMOUNT = <any> 'DWT_TRUSTED_TOKEN_AUTH_AMOUNT',
        DWTTOKENVERIFICATIONRESULTCODE = <any> 'DWT_TOKEN_VERIFICATION_RESULT_CODE',
        DWTTOKENAUTHORIZATIONMESSAGEFORECOMM = <any> 'DWT_TOKEN_AUTHORIZATION_MESSAGE_FOR_ECOMM',
        SPECIALCONDITIONINDICATOR = <any> 'SPECIAL_CONDITION_INDICATOR',
        OCTAFTMERCHANTSTREETADDRESS = <any> 'OCT_AFT_MERCHANT_STREET_ADDRESS',
        OCTAFTACQUIRERNAME = <any> 'OCT_AFT_ACQUIRER_NAME',
        OCTAFTACQUIRERSTREETADDRESS = <any> 'OCT_AFT_ACQUIRER_STREET_ADDRESS',
        OCTAFTACQUIRERCITY = <any> 'OCT_AFT_ACQUIRER_CITY',
        OCTAFTACQUIRERSTATE = <any> 'OCT_AFT_ACQUIRER_STATE',
        OCTAFTACQUIRERPOSTALCODE = <any> 'OCT_AFT_ACQUIRER_POSTAL_CODE',
        OCTAFTACQUIRERCOUNTRYCODE = <any> 'OCT_AFT_ACQUIRER_COUNTRY_CODE'
    }
}

/**
 * 
 * @export
 * @interface TranlogTokenWithInjectableDomainDataToPublishToTrancacheAndWebhookQueue
 */
export interface TranlogTokenWithInjectableDomainDataToPublishToTrancacheAndWebhookQueue {
    /**
     * 
     * @type {string}
     * @memberof TranlogTokenWithInjectableDomainDataToPublishToTrancacheAndWebhookQueue
     */
    tranlogToken: string;
    /**
     * 
     * @type {PullFromCardTransferResponse}
     * @memberof TranlogTokenWithInjectableDomainDataToPublishToTrancacheAndWebhookQueue
     */
    pullFromCard?: PullFromCardTransferResponse;
    /**
     * 
     * @type {DepositDepositResponse}
     * @memberof TranlogTokenWithInjectableDomainDataToPublishToTrancacheAndWebhookQueue
     */
    directDeposit?: DepositDepositResponse;
}

/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    international?: boolean;
    /**
     * address verification
     * @type {InternalAddressVerificationRequest}
     * @memberof Transaction
     */
    addressVerification?: InternalAddressVerificationRequest;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    isInternational?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    network: Transaction.NetworkEnum;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    issuerCountry?: string;
}

/**
 * @export
 * @namespace Transaction
 */
export namespace Transaction {
    /**
     * @export
     * @enum {string}
     */
    export enum NetworkEnum {
        MASTERCARD = <any> 'MASTERCARD',
        DISCOVER = <any> 'DISCOVER',
        PULSE = <any> 'PULSE',
        VISA = <any> 'VISA'
    }
}

/**
 * 
 * @export
 * @interface TransactionCachePayloadNullificationModel
 */
export interface TransactionCachePayloadNullificationModel {
    /**
     * 
     * @type {Array<number>}
     * @memberof TransactionCachePayloadNullificationModel
     */
    tokens: Array<number>;
}

/**
 * 
 * @export
 * @interface TransactionCardAcceptor
 */
export interface TransactionCardAcceptor {
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    mid?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    mcc?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    networkMid?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionCardAcceptor
     */
    mccGroups?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    merchantTaxId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    countryCode?: string;
    /**
     * 
     * @type {TerminalModel}
     * @memberof TransactionCardAcceptor
     */
    poi?: TerminalModel;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    paymentFacilitatorId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    independentSalesOrganizationId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    subMerchantId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    networkAssignedId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    countryOfOrigin?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    transferServiceProviderName?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    paymentFacilitatorName?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptor
     */
    customerServicePhone?: string;
}

/**
 * 
 * @export
 * @interface TransactionCardAcceptorViewModelV1
 */
export interface TransactionCardAcceptorViewModelV1 {
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    mid?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    mcc?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    networkMid?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    mccGroups?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    country?: string;
    /**
     * 
     * @type {TerminalModel}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    poi?: TerminalModel;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    networkAssignedId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionCardAcceptorViewModelV1
     */
    countryOfOrigin?: string;
}

/**
 * 
 * @export
 * @interface TransactionControls
 */
export interface TransactionControls {
    /**
     * 50 char max (default = accept_us_only)
     * @type {string}
     * @memberof TransactionControls
     */
    acceptedCountriesToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    alwaysRequirePin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    alwaysRequireIcc?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    allowGpaAuth?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    requireCardNotPresentCardSecurityCode?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    allowMccGroupAuthorizationControls?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    allowFirstPinSetViaFinancialTransaction?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    ignoreCardSuspendedState?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    allowChipFallback?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    allowNetworkLoad?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    allowNetworkLoadCardActivation?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    allowQuasiCash?: boolean;
    /**
     * 36 char max
     * @type {string}
     * @memberof TransactionControls
     */
    quasiCashExemptMerchantGroupToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    enablePartialAuthApproval?: boolean;
    /**
     * 
     * @type {AvsControls}
     * @memberof TransactionControls
     */
    addressVerification?: AvsControls;
    /**
     * 
     * @type {string}
     * @memberof TransactionControls
     */
    notificationLanguage?: string;
    /**
     * 
     * @type {StrongCustomerAuthenticationLimits}
     * @memberof TransactionControls
     */
    strongCustomerAuthenticationLimits?: StrongCustomerAuthenticationLimits;
    /**
     * 
     * @type {string}
     * @memberof TransactionControls
     */
    quasiCashExemptMids?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionControls
     */
    enableCreditService?: boolean;
}

/**
 * 
 * @export
 * @interface TransactionMetadata
 */
export interface TransactionMetadata {
    /**
     * 
     * @type {string}
     * @memberof TransactionMetadata
     */
    transactionCategory?: TransactionMetadata.TransactionCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionMetadata
     */
    paymentChannel?: TransactionMetadata.PaymentChannelEnum;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionMetadata
     */
    crossBorderTransaction?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TransactionMetadata
     */
    authorizationLifeCycle?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionMetadata
     */
    isLodgingAutoRental?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionMetadata
     */
    isDeferredAuthorization?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof TransactionMetadata
     */
    lodgingAutoRentalStartDate?: Date;
    /**
     * 
     * @type {Transit}
     * @memberof TransactionMetadata
     */
    transit?: Transit;
    /**
     * 
     * @type {Airline}
     * @memberof TransactionMetadata
     */
    airline?: Airline;
    /**
     * 
     * @type {string}
     * @memberof TransactionMetadata
     */
    motoIndicator?: TransactionMetadata.MotoIndicatorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionMetadata
     */
    oneLegOut?: boolean;
}

/**
 * @export
 * @namespace TransactionMetadata
 */
export namespace TransactionMetadata {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionCategoryEnum {
        RETAILSALE = <any> 'RETAIL_SALE',
        BILLPAY = <any> 'BILL_PAY',
        HOTEL = <any> 'HOTEL',
        HEALTHCARE = <any> 'HEALTH_CARE',
        RESTAURANT = <any> 'RESTAURANT',
        AUTORENTAL = <any> 'AUTO_RENTAL',
        AIRLINE = <any> 'AIRLINE',
        PAYMENT = <any> 'PAYMENT',
        HOSPITALIZATIONCOLLEGE = <any> 'HOSPITALIZATION_COLLEGE',
        PHONEMAILECOMMERCE = <any> 'PHONE_MAIL_ECOMMERCE',
        ATM = <any> 'ATM',
        TRANSIT = <any> 'TRANSIT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentChannelEnum {
        OTHER = <any> 'OTHER',
        ATM = <any> 'ATM',
        ECOMMERCE = <any> 'ECOMMERCE',
        MAIL = <any> 'MAIL',
        PHONE = <any> 'PHONE',
        MOTO = <any> 'MOTO'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MotoIndicatorEnum {
        UNKNOWN = <any> 'UNKNOWN',
        MANUAL = <any> 'MANUAL',
        RECURRING = <any> 'RECURRING',
        INSTALLMENT = <any> 'INSTALLMENT',
        OTHERS = <any> 'OTHERS'
    }
}

/**
 * 
 * @export
 * @interface TransactionModel
 */
export interface TransactionModel {
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    identifier?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    userToken?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    businessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    actingUserToken: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    cardToken?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    cardProductToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionModel
     */
    isPreauthorization?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    type: TransactionModel.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    state: TransactionModel.StateEnum;
    /**
     * 
     * @type {number}
     * @memberof TransactionModel
     */
    duration?: number;
    /**
     * 
     * @type {Date}
     * @memberof TransactionModel
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TransactionModel
     */
    userTransactionTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TransactionModel
     */
    settlementDate?: Date;
    /**
     * 
     * @type {number}
     * @memberof TransactionModel
     */
    requestAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionModel
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionModel
     */
    cashBackAmount?: number;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof TransactionModel
     */
    currencyConversion?: CurrencyConversion;
    /**
     * 
     * @type {number}
     * @memberof TransactionModel
     */
    issuerInterchangeAmount?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    currencyCode?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    approvalCode?: string;
    /**
     * 
     * @type {Response}
     * @memberof TransactionModel
     */
    response?: Response;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    precedingRelatedTransactionToken?: string;
    /**
     * 
     * @type {PrecedingTransaction}
     * @memberof TransactionModel
     */
    precedingTransaction?: PrecedingTransaction;
    /**
     * 
     * @type {number}
     * @memberof TransactionModel
     */
    amountToBeReleased?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TransactionModel
     */
    incrementalAuthorizationTransactionTokens?: Array<string>;
    /**
     * 
     * @type {MerchantResponseModel}
     * @memberof TransactionModel
     */
    merchant?: MerchantResponseModel;
    /**
     * 
     * @type {StoreResponseModel}
     * @memberof TransactionModel
     */
    store?: StoreResponseModel;
    /**
     * 
     * @type {TransactionCardAcceptor}
     * @memberof TransactionModel
     */
    cardAcceptor?: TransactionCardAcceptor;
    /**
     * 
     * @type {CardholderBalance}
     * @memberof TransactionModel
     */
    gpa?: CardholderBalance;
    /**
     * 
     * @type {CardResponse}
     * @memberof TransactionModel
     */
    card?: CardResponse;
    /**
     * 
     * @type {GpaReturns}
     * @memberof TransactionModel
     */
    gpaOrderUnload?: GpaReturns;
    /**
     * 
     * @type {GpaResponse}
     * @memberof TransactionModel
     */
    gpaOrder?: GpaResponse;
    /**
     * 
     * @type {ProgramTransferResponse}
     * @memberof TransactionModel
     */
    programTransfer?: ProgramTransferResponse;
    /**
     * 
     * @type {FeeTransferResponse}
     * @memberof TransactionModel
     */
    feeTransfer?: FeeTransferResponse;
    /**
     * 
     * @type {PeerTransferResponse}
     * @memberof TransactionModel
     */
    peerTransfer?: PeerTransferResponse;
    /**
     * 
     * @type {Array<MsaOrderResponse>}
     * @memberof TransactionModel
     */
    msaOrders?: Array<MsaOrderResponse>;
    /**
     * 
     * @type {MsaReturns}
     * @memberof TransactionModel
     */
    msaOrderUnload?: MsaReturns;
    /**
     * 
     * @type {Array<OfferOrderResponse>}
     * @memberof TransactionModel
     */
    offerOrders?: Array<OfferOrderResponse>;
    /**
     * 
     * @type {AutoReloadModel}
     * @memberof TransactionModel
     */
    autoReload?: AutoReloadModel;
    /**
     * 
     * @type {DepositDepositResponse}
     * @memberof TransactionModel
     */
    directDeposit?: DepositDepositResponse;
    /**
     * 
     * @type {PullFromCardTransferResponse}
     * @memberof TransactionModel
     */
    pullFromCard?: PullFromCardTransferResponse;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    polarity?: TransactionModel.PolarityEnum;
    /**
     * 
     * @type {RealTimeFeeGroup}
     * @memberof TransactionModel
     */
    realTimeFeeGroup?: RealTimeFeeGroup;
    /**
     * 
     * @type {Fee}
     * @memberof TransactionModel
     */
    fee?: Fee;
    /**
     * 
     * @type {ChargebackResponse}
     * @memberof TransactionModel
     */
    chargeback?: ChargebackResponse;
    /**
     * 
     * @type {DisputeModel}
     * @memberof TransactionModel
     */
    dispute?: DisputeModel;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    subnetwork?: string;
    /**
     * 
     * @type {NetworkMetadata}
     * @memberof TransactionModel
     */
    networkMetadata?: NetworkMetadata;
    /**
     * 
     * @type {number}
     * @memberof TransactionModel
     */
    acquirerFeeAmount?: number;
    /**
     * 
     * @type {Array<NetworkFeeModel>}
     * @memberof TransactionModel
     */
    fees?: Array<NetworkFeeModel>;
    /**
     * 
     * @type {DigitalWalletToken}
     * @memberof TransactionModel
     */
    digitalWalletToken?: DigitalWalletToken;
    /**
     * 
     * @type {CardholderMetadata}
     * @memberof TransactionModel
     */
    user?: CardholderMetadata;
    /**
     * 
     * @type {BusinessMetadata}
     * @memberof TransactionModel
     */
    business?: BusinessMetadata;
    /**
     * 
     * @type {Acquirer}
     * @memberof TransactionModel
     */
    acquirer?: Acquirer;
    /**
     * 
     * @type {FraudView}
     * @memberof TransactionModel
     */
    fraud?: FraudView;
    /**
     * 
     * @type {Pos}
     * @memberof TransactionModel
     */
    pos?: Pos;
    /**
     * 
     * @type {AddressVerificationModel}
     * @memberof TransactionModel
     */
    addressVerification?: AddressVerificationModel;
    /**
     * 
     * @type {CardSecurityCodeVerification}
     * @memberof TransactionModel
     */
    cardSecurityCodeVerification?: CardSecurityCodeVerification;
    /**
     * 
     * @type {TransactionMetadata}
     * @memberof TransactionModel
     */
    transactionMetadata?: TransactionMetadata;
    /**
     * 
     * @type {OriginalCredit}
     * @memberof TransactionModel
     */
    originalCredit?: OriginalCredit;
    /**
     * 
     * @type {AccountFunding}
     * @memberof TransactionModel
     */
    accountFunding?: AccountFunding;
    /**
     * 
     * @type {UserCardHolderResponse}
     * @memberof TransactionModel
     */
    cardHolderModel?: UserCardHolderResponse;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    standinApprovedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    standinBy?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    standinReason?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    networkReferenceId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    acquirerReferenceId?: string;
    /**
     * 
     * @type {CardholderAuthenticationData}
     * @memberof TransactionModel
     */
    cardholderAuthenticationData?: CardholderAuthenticationData;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TransactionModel
     */
    transactionAttributes?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    clearingRecordSequenceNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    issuerReceivedTime?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    issuerPaymentNode?: string;
    /**
     * 
     * @type {Program}
     * @memberof TransactionModel
     */
    program?: Program;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    batchNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    fromAccount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    multiClearingSequenceNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    multiClearingSequenceCount?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    isaIndicator?: TransactionModel.IsaIndicatorEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    enhancedDataToken?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    adviceReasonCode?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    adviceReasonDetails?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    bankTransferToken?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    interchangeRateDescriptor?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionModel
     */
    realTimeFeeType?: string;
    /**
     * 
     * @type {ATCInformationModel}
     * @memberof TransactionModel
     */
    atcInformation?: ATCInformationModel;
}

/**
 * @export
 * @namespace TransactionModel
 */
export namespace TransactionModel {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        GpaCredit = <any> 'gpa.credit',
        GpaCreditPending = <any> 'gpa.credit.pending',
        GpaCreditPendingReversal = <any> 'gpa.credit.pending.reversal',
        GpaCreditReversal = <any> 'gpa.credit.reversal',
        GpaCreditNetworkload = <any> 'gpa.credit.networkload',
        GpaCreditNetworkloadReversal = <any> 'gpa.credit.networkload.reversal',
        GpaDebitNetworkload = <any> 'gpa.debit.networkload',
        GpaDebit = <any> 'gpa.debit',
        GpaDebitPending = <any> 'gpa.debit.pending',
        GpaDebitPendingReversal = <any> 'gpa.debit.pending.reversal',
        GpaGrant = <any> 'gpa.grant',
        GpaCreditIssueroperator = <any> 'gpa.credit.issueroperator',
        GpaDebitIssueroperator = <any> 'gpa.debit.issueroperator',
        GpaCreditChargeback = <any> 'gpa.credit.chargeback',
        GpaCreditChargebackReversal = <any> 'gpa.credit.chargeback.reversal',
        GpaCreditBillpayment = <any> 'gpa.credit.billpayment',
        GpaCreditAuthorizationBillpayment = <any> 'gpa.credit.authorization.billpayment',
        GpaCreditAuthorizationBillpaymentReversal = <any> 'gpa.credit.authorization.billpayment.reversal',
        MsaCreditPending = <any> 'msa.credit.pending',
        MsaCreditPendingReversal = <any> 'msa.credit.pending.reversal',
        MsaCreditReversal = <any> 'msa.credit.reversal',
        MsaCredit = <any> 'msa.credit',
        MsaDebitPending = <any> 'msa.debit.pending',
        MsaDebitPendingReversal = <any> 'msa.debit.pending.reversal',
        MsaDebit = <any> 'msa.debit',
        MsaCreditChargeback = <any> 'msa.credit.chargeback',
        MsaCreditChargebackReversal = <any> 'msa.credit.chargeback.reversal',
        Authorization = <any> 'authorization',
        AuthorizationAdvice = <any> 'authorization.advice',
        AuthorizationReversal = <any> 'authorization.reversal',
        AuthorizationClearing = <any> 'authorization.clearing',
        AuthorizationReversalIssuerexpiration = <any> 'authorization.reversal.issuerexpiration',
        DisputeCredit = <any> 'dispute.credit',
        DisputeDebit = <any> 'dispute.debit',
        AuthorizationClearingChargeback = <any> 'authorization.clearing.chargeback',
        AuthorizationClearingChargebackReversal = <any> 'authorization.clearing.chargeback.reversal',
        Refund = <any> 'refund',
        PindebitAtmWithdrawal = <any> 'pindebit.atm.withdrawal',
        PindebitBalanceinquiry = <any> 'pindebit.balanceinquiry',
        PindebitCashback = <any> 'pindebit.cashback',
        Pindebit = <any> 'pindebit',
        ProgramreserveCredit = <any> 'programreserve.credit',
        ProgramreserveDebit = <any> 'programreserve.debit',
        FeeChargePending = <any> 'fee.charge.pending',
        FeeCharge = <any> 'fee.charge',
        FeeChargePendingRefund = <any> 'fee.charge.pending.refund',
        FundsExpire = <any> 'funds.expire',
        RewardEarn = <any> 'reward.earn',
        TransferPeer = <any> 'transfer.peer',
        TransferFee = <any> 'transfer.fee',
        AccountFundingAuthorization = <any> 'account.funding.authorization',
        AccountFundingAuthorizationReversal = <any> 'account.funding.authorization.reversal',
        AccountFundingAuthorizationClearing = <any> 'account.funding.authorization.clearing',
        AccountFundingAuthPlusCapture = <any> 'account.funding.auth_plus_capture',
        AccountFundingAuthPlusCaptureReversal = <any> 'account.funding.auth_plus_capture.reversal',
        AccountCredit = <any> 'account.credit',
        AccountDebit = <any> 'account.debit',
        Balanceinquiry = <any> 'balanceinquiry',
        AuthorizationAtmWithdrawal = <any> 'authorization.atm.withdrawal',
        AuthorizationClearingAtmWithdrawal = <any> 'authorization.clearing.atm.withdrawal',
        AuthorizationCashback = <any> 'authorization.cashback',
        AuthorizationClearingCashback = <any> 'authorization.clearing.cashback',
        TransferProgram = <any> 'transfer.program',
        AuthorizationQuasiCash = <any> 'authorization.quasi.cash',
        AuthorizationClearingQuasiCash = <any> 'authorization.clearing.quasi.cash',
        AuthorizationIncremental = <any> 'authorization.incremental',
        GpaCreditAuthorization = <any> 'gpa.credit.authorization',
        GpaCreditAuthorizationReversal = <any> 'gpa.credit.authorization.reversal',
        GpaDebitAuthorization = <any> 'gpa.debit.authorization',
        GpaDebitReversal = <any> 'gpa.debit.reversal',
        OriginalCreditAuthorization = <any> 'original.credit.authorization',
        OriginalCreditAuthorizationReversal = <any> 'original.credit.authorization.reversal',
        OriginalCreditAuthorizationClearing = <any> 'original.credit.authorization.clearing',
        OriginalCreditAuthPlusCapture = <any> 'original.credit.auth_plus_capture',
        OriginalCreditAuthPlusCaptureReversal = <any> 'original.credit.auth_plus_capture.reversal',
        RefundAuthorization = <any> 'refund.authorization',
        RefundAuthorizationAdvice = <any> 'refund.authorization.advice',
        RefundAuthorizationClearing = <any> 'refund.authorization.clearing',
        RefundAuthorizationReversal = <any> 'refund.authorization.reversal',
        TokenActivationRequest = <any> 'token.activation-request',
        TokenAdvice = <any> 'token.advice',
        PindebitAuthorization = <any> 'pindebit.authorization',
        PindebitAuthorizationClearing = <any> 'pindebit.authorization.clearing',
        PindebitAuthorizationReversal = <any> 'pindebit.authorization.reversal',
        PindebitAuthorizationReversalIssuerexpiration = <any> 'pindebit.authorization.reversal.issuerexpiration',
        AuthorizationStandin = <any> 'authorization.standin',
        AuthorizationClearingChargebackCompleted = <any> 'authorization.clearing.chargeback.completed',
        AuthorizationClearingChargebackProvisionalCredit = <any> 'authorization.clearing.chargeback.provisional.credit',
        AuthorizationClearingChargebackProvisionalDebit = <any> 'authorization.clearing.chargeback.provisional.debit',
        AuthorizationClearingChargebackWriteoff = <any> 'authorization.clearing.chargeback.writeoff',
        DirectdepositCredit = <any> 'directdeposit.credit',
        DirectdepositCreditPending = <any> 'directdeposit.credit.pending',
        DirectdepositCreditReject = <any> 'directdeposit.credit.reject',
        DirectdepositCreditPendingReversal = <any> 'directdeposit.credit.pending.reversal',
        DirectdepositCreditReversal = <any> 'directdeposit.credit.reversal',
        DirectdepositDebit = <any> 'directdeposit.debit',
        DirectdepositDebitPending = <any> 'directdeposit.debit.pending',
        DirectdepositDebitReject = <any> 'directdeposit.debit.reject',
        DirectdepositDebitReversal = <any> 'directdeposit.debit.reversal',
        DirectdepositDebitPendingReversal = <any> 'directdeposit.debit.pending.reversal',
        FeeChargeReversal = <any> 'fee.charge.reversal',
        PindebitChargeback = <any> 'pindebit.chargeback',
        PindebitChargebackCompleted = <any> 'pindebit.chargeback.completed',
        PindebitChargebackProvisionalCredit = <any> 'pindebit.chargeback.provisional.credit',
        PindebitChargebackProvisionalDebit = <any> 'pindebit.chargeback.provisional.debit',
        PindebitChargebackReversal = <any> 'pindebit.chargeback.reversal',
        PindebitChargebackWriteoff = <any> 'pindebit.chargeback.writeoff',
        PindebitCreditAdjustment = <any> 'pindebit.credit.adjustment',
        PindebitQuasicash = <any> 'pindebit.quasicash',
        PindebitQuasiCash = <any> 'pindebit.quasi.cash',
        PindebitRefund = <any> 'pindebit.refund',
        PindebitRefundReversal = <any> 'pindebit.refund.reversal',
        PindebitReversal = <any> 'pindebit.reversal',
        PindebitTransfer = <any> 'pindebit.transfer',
        PushtocardDebit = <any> 'pushtocard.debit',
        PushtocardReversal = <any> 'pushtocard.reversal',
        CreditAdjustment = <any> 'credit.adjustment',
        DebitAdjustment = <any> 'debit.adjustment',
        Unknown = <any> 'unknown'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        PENDING = <any> 'PENDING',
        CLEARED = <any> 'CLEARED',
        COMPLETION = <any> 'COMPLETION',
        DECLINED = <any> 'DECLINED',
        ERROR = <any> 'ERROR'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PolarityEnum {
        CREDIT = <any> 'CREDIT',
        DEBIT = <any> 'DEBIT',
        PENDINGCREDIT = <any> 'PENDING_CREDIT',
        PENDINGDEBIT = <any> 'PENDING_DEBIT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum IsaIndicatorEnum {
        MULTICURRENCY = <any> 'MULTI_CURRENCY',
        SINGLECURRENCY = <any> 'SINGLE_CURRENCY',
        REBATECANCELLED = <any> 'REBATE_CANCELLED',
        MULTICURRENCYNONUSCOUNTRIES = <any> 'MULTI_CURRENCY_NON_US_COUNTRIES',
        SINGLECURRENCYPAIDBYISSUER = <any> 'SINGLE_CURRENCY_PAID_BY_ISSUER',
        NOCHARGEASSESSED = <any> 'NO_CHARGE_ASSESSED'
    }
}

/**
 * 
 * @export
 * @interface TransactionModelListResponse
 */
export interface TransactionModelListResponse {
    /**
     * 
     * @type {number}
     * @memberof TransactionModelListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionModelListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionModelListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionModelListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<TransactionModel>}
     * @memberof TransactionModelListResponse
     */
    data?: Array<TransactionModel>;
}

/**
 * 
 * @export
 * @interface TransactionOptions
 */
export interface TransactionOptions {
    /**
     * 
     * @type {string}
     * @memberof TransactionOptions
     */
    additionalData?: string;
    /**
     * 
     * @type {number}
     * @memberof TransactionOptions
     */
    databaseTransactionTimeout?: number;
    /**
     * 
     * @type {number}
     * @memberof TransactionOptions
     */
    transactionTimeoutThresholdSeconds?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionOptions
     */
    preAuthTimeLimit?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionOptions
     */
    sendExpirationDate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionOptions
     */
    sendTrackData?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TransactionOptions
     */
    cardExpirationDateYymm?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOptions
     */
    encryptionKeyId?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionOptions
     */
    transactionToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionOptions
     */
    isAsync?: boolean;
}

/**
 * 
 * @export
 * @interface TransactionUpdateModel
 */
export interface TransactionUpdateModel {
    /**
     * 
     * @type {string}
     * @memberof TransactionUpdateModel
     */
    state?: TransactionUpdateModel.StateEnum;
}

/**
 * @export
 * @namespace TransactionUpdateModel
 */
export namespace TransactionUpdateModel {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        PENDING = <any> 'PENDING',
        CLEARED = <any> 'CLEARED',
        COMPLETION = <any> 'COMPLETION',
        DECLINED = <any> 'DECLINED',
        ERROR = <any> 'ERROR',
        ALL = <any> 'ALL'
    }
}

/**
 * 
 * @export
 * @interface Transit
 */
export interface Transit {
    /**
     * 
     * @type {string}
     * @memberof Transit
     */
    transactionType?: Transit.TransactionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Transit
     */
    transportationMode?: Transit.TransportationModeEnum;
}

/**
 * @export
 * @namespace Transit
 */
export namespace Transit {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionTypeEnum {
        PREFUNDED = <any> 'PRE_FUNDED',
        REALTIMEAUTHORIZED = <any> 'REAL_TIME_AUTHORIZED',
        POSTAUTHORIZEDAGGREGATED = <any> 'POST_AUTHORIZED_AGGREGATED',
        AUTHORIZEDAGGREGATEDSPLITCLEARING = <any> 'AUTHORIZED_AGGREGATED_SPLIT_CLEARING',
        OTHER = <any> 'OTHER',
        DEBITRECOVERY = <any> 'DEBIT_RECOVERY'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TransportationModeEnum {
        BUS = <any> 'BUS',
        TRAIN = <any> 'TRAIN',
        WATERBORNEVEHICLE = <any> 'WATER_BORNE_VEHICLE',
        TOLL = <any> 'TOLL',
        PARKING = <any> 'PARKING',
        TAXI = <any> 'TAXI',
        PARATRANSIT = <any> 'PARA_TRANSIT',
        SELFDRIVEVEHICLE = <any> 'SELF_DRIVE_VEHICLE',
        COACH = <any> 'COACH',
        LOCOMOTIVE = <any> 'LOCOMOTIVE',
        POWEREDMOTORVEHICLE = <any> 'POWERED_MOTOR_VEHICLE',
        TRAILER = <any> 'TRAILER',
        INTERCITY = <any> 'INTER_CITY',
        CABLECAR = <any> 'CABLE_CAR'
    }
}

/**
 * 
 * @export
 * @interface TriggeredRule
 */
export interface TriggeredRule {
    /**
     * 
     * @type {string}
     * @memberof TriggeredRule
     */
    ruleName?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof TriggeredRule
     */
    tags?: Array<Tag>;
    /**
     * 
     * @type {boolean}
     * @memberof TriggeredRule
     */
    alert?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TriggeredRule
     */
    entityType?: string;
    /**
     * 
     * @type {string}
     * @memberof TriggeredRule
     */
    acgLevel?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TriggeredRule
     */
    suppressAlert?: boolean;
}

/**
 * 
 * @export
 * @interface UnloadRequestModel
 */
export interface UnloadRequestModel {
    /**
     * 
     * @type {string}
     * @memberof UnloadRequestModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof UnloadRequestModel
     */
    originalOrderToken: string;
    /**
     * 
     * @type {number}
     * @memberof UnloadRequestModel
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof UnloadRequestModel
     */
    tags?: string;
    /**
     * 
     * @type {string}
     * @memberof UnloadRequestModel
     */
    memo?: string;
    /**
     * 
     * @type {string}
     * @memberof UnloadRequestModel
     */
    fundingSourceAddressToken?: string;
}

/**
 * 
 * @export
 * @interface UpdateBusinessCheckRequestRequest
 */
export interface UpdateBusinessCheckRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessCheckRequestRequest
     */
    checkType: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessCheckRequestRequest
     */
    checkName: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessCheckRequestRequest
     */
    checkValue: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessCheckRequestRequest
     */
    checkStatus: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessCheckRequestRequest
     */
    userEmail: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessCheckRequestRequest
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBusinessCheckRequestRequest
     */
    kybToken?: string;
}

/**
 * 
 * @export
 * @interface UpdateSystemHealth
 */
export interface UpdateSystemHealth {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateSystemHealth
     */
    forceUnavailable: boolean;
}

/**
 * 
 * @export
 * @interface UserAssociation
 */
export interface UserAssociation {
    /**
     * 
     * @type {boolean}
     * @memberof UserAssociation
     */
    singleInventoryUser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserAssociation
     */
    singleInventoryUserToken?: string;
}

/**
 * 
 * @export
 * @interface UserCardHolderListResponse
 */
export interface UserCardHolderListResponse {
    /**
     * 
     * @type {number}
     * @memberof UserCardHolderListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof UserCardHolderListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof UserCardHolderListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserCardHolderListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<CardHolderModel>}
     * @memberof UserCardHolderListResponse
     */
    data?: Array<CardHolderModel>;
}

/**
 * 
 * @export
 * @interface UserCardHolderResponse
 */
export interface UserCardHolderResponse {
    /**
     * 
     * @type {Authentication}
     * @memberof UserCardHolderResponse
     */
    authentication?: Authentication;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    token?: string;
    /**
     * Default is true
     * @type {boolean}
     * @memberof UserCardHolderResponse
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    honorific?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    gender?: UserCardHolderResponse.GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    middleName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    birthDate?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    notes?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    parentToken?: string;
    /**
     * Default is false
     * @type {boolean}
     * @memberof UserCardHolderResponse
     */
    usesParentAccount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    ssn?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCardHolderResponse
     */
    corporateCardHolder?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    passportNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    idCardNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    nationality?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    company?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    ipAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    password?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof UserCardHolderResponse
     */
    createdTime: Date;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     * @type {Date}
     * @memberof UserCardHolderResponse
     */
    lastModifiedTime: Date;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    businessToken?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UserCardHolderResponse
     */
    metadata?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    accountHolderGroupToken?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    status?: UserCardHolderResponse.StatusEnum;
    /**
     * 
     * @type {Array<IdentificationResponseModel>}
     * @memberof UserCardHolderResponse
     */
    identifications?: Array<IdentificationResponseModel>;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    idCardExpirationDate?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderResponse
     */
    passportExpirationDate?: string;
}

/**
 * @export
 * @namespace UserCardHolderResponse
 */
export namespace UserCardHolderResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        F = <any> 'F',
        M = <any> 'M'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        UNVERIFIED = <any> 'UNVERIFIED',
        LIMITED = <any> 'LIMITED',
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        CLOSED = <any> 'CLOSED'
    }
}

/**
 * 
 * @export
 * @interface UserCardHolderSearchModel
 */
export interface UserCardHolderSearchModel {
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderSearchModel
     */
    ssn?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderSearchModel
     */
    dda?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderSearchModel
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderSearchModel
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderSearchModel
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderSearchModel
     */
    email?: string;
}

/**
 * 
 * @export
 * @interface UserCardHolderUpdateModel
 */
export interface UserCardHolderUpdateModel {
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    token?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCardHolderUpdateModel
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    notes?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    ipAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    phone?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UserCardHolderUpdateModel
     */
    metadata?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    accountHolderGroupToken?: string;
    /**
     * 
     * @type {Array<IdentificationRequestModel>}
     * @memberof UserCardHolderUpdateModel
     */
    identifications?: Array<IdentificationRequestModel>;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    honorific?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    gender?: UserCardHolderUpdateModel.GenderEnum;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    middleName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    address1?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    address2?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    birthDate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCardHolderUpdateModel
     */
    corporateCardHolder?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    ssn?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    passportNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    passportExpirationDate?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    idCardNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    idCardExpirationDate?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    nationality?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    company?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    parentToken?: string;
    /**
     * Default is false
     * @type {boolean}
     * @memberof UserCardHolderUpdateModel
     */
    usesParentAccount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCardHolderUpdateModel
     */
    postalCode?: string;
}

/**
 * @export
 * @namespace UserCardHolderUpdateModel
 */
export namespace UserCardHolderUpdateModel {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        F = <any> 'F',
        M = <any> 'M'
    }
}

/**
 * 
 * @export
 * @interface UserStipBalanceRequest
 */
export interface UserStipBalanceRequest {
    /**
     * 
     * @type {string}
     * @memberof UserStipBalanceRequest
     */
    userToken: string;
    /**
     * 
     * @type {string}
     * @memberof UserStipBalanceRequest
     */
    isoCurrencyCode: string;
    /**
     * 
     * @type {Date}
     * @memberof UserStipBalanceRequest
     */
    effectiveTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof UserStipBalanceRequest
     */
    cachedBalance: number;
}

/**
 * 
 * @export
 * @interface UserStipBalanceResponse
 */
export interface UserStipBalanceResponse {
    /**
     * 
     * @type {number}
     * @memberof UserStipBalanceResponse
     */
    latestBalance?: number;
}

/**
 * 
 * @export
 * @interface UserTransitionListResponse
 */
export interface UserTransitionListResponse {
    /**
     * 
     * @type {number}
     * @memberof UserTransitionListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof UserTransitionListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof UserTransitionListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserTransitionListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<UserTransitionResponse>}
     * @memberof UserTransitionListResponse
     */
    data?: Array<UserTransitionResponse>;
}

/**
 * 
 * @export
 * @interface UserTransitionRequest
 */
export interface UserTransitionRequest {
    /**
     * 
     * @type {string}
     * @memberof UserTransitionRequest
     */
    idempotentHash?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTransitionRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTransitionRequest
     */
    status: UserTransitionRequest.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserTransitionRequest
     */
    reasonCode: UserTransitionRequest.ReasonCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserTransitionRequest
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTransitionRequest
     */
    channel: UserTransitionRequest.ChannelEnum;
    /**
     * 
     * @type {string}
     * @memberof UserTransitionRequest
     */
    userToken: string;
}

/**
 * @export
 * @namespace UserTransitionRequest
 */
export namespace UserTransitionRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        UNVERIFIED = <any> 'UNVERIFIED',
        LIMITED = <any> 'LIMITED',
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        CLOSED = <any> 'CLOSED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonCodeEnum {
        _00 = <any> '00',
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _06 = <any> '06',
        _07 = <any> '07',
        _08 = <any> '08',
        _09 = <any> '09',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _13 = <any> '13',
        _14 = <any> '14',
        _15 = <any> '15',
        _16 = <any> '16',
        _17 = <any> '17',
        _18 = <any> '18',
        _19 = <any> '19',
        _20 = <any> '20',
        _21 = <any> '21',
        _22 = <any> '22',
        _23 = <any> '23',
        _24 = <any> '24',
        _25 = <any> '25',
        _26 = <any> '26',
        _27 = <any> '27',
        _28 = <any> '28',
        _29 = <any> '29',
        _30 = <any> '30',
        _31 = <any> '31'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        IVR = <any> 'IVR',
        FRAUD = <any> 'FRAUD',
        ADMIN = <any> 'ADMIN',
        SYSTEM = <any> 'SYSTEM'
    }
}

/**
 * 
 * @export
 * @interface UserTransitionResponse
 */
export interface UserTransitionResponse {
    /**
     * 
     * @type {string}
     * @memberof UserTransitionResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof UserTransitionResponse
     */
    status: UserTransitionResponse.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserTransitionResponse
     */
    reasonCode: UserTransitionResponse.ReasonCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserTransitionResponse
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTransitionResponse
     */
    channel: UserTransitionResponse.ChannelEnum;
    /**
     * 
     * @type {Date}
     * @memberof UserTransitionResponse
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UserTransitionResponse
     */
    lastModifiedTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof UserTransitionResponse
     */
    userToken?: string;
}

/**
 * @export
 * @namespace UserTransitionResponse
 */
export namespace UserTransitionResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        UNVERIFIED = <any> 'UNVERIFIED',
        LIMITED = <any> 'LIMITED',
        ACTIVE = <any> 'ACTIVE',
        SUSPENDED = <any> 'SUSPENDED',
        CLOSED = <any> 'CLOSED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ReasonCodeEnum {
        _00 = <any> '00',
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _06 = <any> '06',
        _07 = <any> '07',
        _08 = <any> '08',
        _09 = <any> '09',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _13 = <any> '13',
        _14 = <any> '14',
        _15 = <any> '15',
        _16 = <any> '16',
        _17 = <any> '17',
        _18 = <any> '18',
        _19 = <any> '19',
        _20 = <any> '20',
        _21 = <any> '21',
        _22 = <any> '22',
        _23 = <any> '23',
        _24 = <any> '24',
        _25 = <any> '25',
        _26 = <any> '26',
        _27 = <any> '27',
        _28 = <any> '28',
        _29 = <any> '29',
        _30 = <any> '30',
        _31 = <any> '31'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChannelEnum {
        API = <any> 'API',
        IVR = <any> 'IVR',
        FRAUD = <any> 'FRAUD',
        ADMIN = <any> 'ADMIN',
        SYSTEM = <any> 'SYSTEM'
    }
}

/**
 * 
 * @export
 * @interface UserValidationRequest
 */
export interface UserValidationRequest {
    /**
     * yyyy-MM-dd
     * @type {Date}
     * @memberof UserValidationRequest
     */
    birthDate?: Date;
    /**
     * Phone #
     * @type {string}
     * @memberof UserValidationRequest
     */
    phone?: string;
    /**
     * Last four digits of SSN
     * @type {string}
     * @memberof UserValidationRequest
     */
    ssn?: string;
    /**
     * Six-char random name postfix
     * @type {string}
     * @memberof UserValidationRequest
     */
    randomNameLine1Postfix?: string;
}

/**
 * 
 * @export
 * @interface UserValidationResponse
 */
export interface UserValidationResponse {
    /**
     * yyyy-MM-dd
     * @type {boolean}
     * @memberof UserValidationResponse
     */
    birthDate: boolean;
    /**
     * 10 char max, phone number
     * @type {boolean}
     * @memberof UserValidationResponse
     */
    phone: boolean;
    /**
     * Last four digits of SSN
     * @type {boolean}
     * @memberof UserValidationResponse
     */
    ssn: boolean;
    /**
     * Six-char random name postfix
     * @type {boolean}
     * @memberof UserValidationResponse
     */
    randomNameLine1Postfix: boolean;
}

/**
 * 
 * @export
 * @interface ValidationsRequest
 */
export interface ValidationsRequest {
    /**
     * 
     * @type {UserValidationRequest}
     * @memberof ValidationsRequest
     */
    user?: UserValidationRequest;
}

/**
 * 
 * @export
 * @interface ValidationsResponse
 */
export interface ValidationsResponse {
    /**
     * 
     * @type {UserValidationResponse}
     * @memberof ValidationsResponse
     */
    user: UserValidationResponse;
}

/**
 * 
 * @export
 * @interface VelocityCache
 */
export interface VelocityCache {
    /**
     * 
     * @type {number}
     * @memberof VelocityCache
     */
    cardHolderId?: number;
    /**
     * 
     * @type {number}
     * @memberof VelocityCache
     */
    velocityControlId?: number;
    /**
     * 
     * @type {number}
     * @memberof VelocityCache
     */
    usedAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof VelocityCache
     */
    usageCount?: number;
    /**
     * 
     * @type {number}
     * @memberof VelocityCache
     */
    maxId?: number;
    /**
     * 
     * @type {Date}
     * @memberof VelocityCache
     */
    windowStartTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof VelocityCache
     */
    vcSignature?: string;
    /**
     * 
     * @type {Date}
     * @memberof VelocityCache
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof VelocityCache
     */
    lastModifiedTime?: Date;
}

/**
 * 
 * @export
 * @interface VelocityControlBalanceListResponse
 */
export interface VelocityControlBalanceListResponse {
    /**
     * 
     * @type {number}
     * @memberof VelocityControlBalanceListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlBalanceListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlBalanceListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlBalanceListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<VelocityControlBalanceResponse>}
     * @memberof VelocityControlBalanceListResponse
     */
    data?: Array<VelocityControlBalanceResponse>;
}

/**
 * 
 * @export
 * @interface VelocityControlBalanceResponse
 */
export interface VelocityControlBalanceResponse {
    /**
     * 
     * @type {string}
     * @memberof VelocityControlBalanceResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlBalanceResponse
     */
    name?: string;
    /**
     * 
     * @type {SpendControlAssociation}
     * @memberof VelocityControlBalanceResponse
     */
    association?: SpendControlAssociation;
    /**
     * 
     * @type {MerchantScope}
     * @memberof VelocityControlBalanceResponse
     */
    merchantScope?: MerchantScope;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlBalanceResponse
     */
    usageLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlBalanceResponse
     */
    approvalsOnly?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlBalanceResponse
     */
    includePurchases?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlBalanceResponse
     */
    includeWithdrawals?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlBalanceResponse
     */
    includeTransfers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlBalanceResponse
     */
    includeCashback?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlBalanceResponse
     */
    includeCredits?: boolean;
    /**
     * 
     * @type {MoneyInTransaction}
     * @memberof VelocityControlBalanceResponse
     */
    moneyInTransaction?: MoneyInTransaction;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlBalanceResponse
     */
    currencyCode: string;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlBalanceResponse
     */
    amountLimit: number;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlBalanceResponse
     */
    velocityWindow: VelocityControlBalanceResponse.VelocityWindowEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlBalanceResponse
     */
    active?: boolean;
    /**
     * Available balance
     * @type {Available}
     * @memberof VelocityControlBalanceResponse
     */
    available: Available;
}

/**
 * @export
 * @namespace VelocityControlBalanceResponse
 */
export namespace VelocityControlBalanceResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum VelocityWindowEnum {
        DAY = <any> 'DAY',
        WEEK = <any> 'WEEK',
        MONTH = <any> 'MONTH',
        LIFETIME = <any> 'LIFETIME',
        TRANSACTION = <any> 'TRANSACTION'
    }
}

/**
 * 
 * @export
 * @interface VelocityControlCheckRequest
 */
export interface VelocityControlCheckRequest {
    /**
     * 
     * @type {InternalCardProduct}
     * @memberof VelocityControlCheckRequest
     */
    cardProduct: InternalCardProduct;
    /**
     * 
     * @type {InternalTransactionDataModel}
     * @memberof VelocityControlCheckRequest
     */
    transaction: InternalTransactionDataModel;
    /**
     * 
     * @type {InternalUser}
     * @memberof VelocityControlCheckRequest
     */
    cardHolder: InternalUser;
    /**
     * 
     * @type {InternalCard}
     * @memberof VelocityControlCheckRequest
     */
    card?: InternalCard;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof VelocityControlCheckRequest
     */
    context?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlCheckRequest
     */
    writeCache?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlCheckRequest
     */
    debug?: boolean;
}

/**
 * 
 * @export
 * @interface VelocityControlCheckResponse
 */
export interface VelocityControlCheckResponse {
    /**
     * 
     * @type {VelocityControlCheckRequest}
     * @memberof VelocityControlCheckResponse
     */
    velocityControlCheckRequest?: VelocityControlCheckRequest;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlCheckResponse
     */
    velocityCheckName?: string;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlCheckResponse
     */
    balance?: number;
    /**
     * 
     * @type {Response}
     * @memberof VelocityControlCheckResponse
     */
    response?: Response;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof VelocityControlCheckResponse
     */
    context?: { [key: string]: string; };
    /**
     * 
     * @type {Array<VelocityCache>}
     * @memberof VelocityControlCheckResponse
     */
    caches?: Array<VelocityCache>;
}

/**
 * 
 * @export
 * @interface VelocityControlListResponse
 */
export interface VelocityControlListResponse {
    /**
     * 
     * @type {number}
     * @memberof VelocityControlListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<VelocityControlResponse>}
     * @memberof VelocityControlListResponse
     */
    data?: Array<VelocityControlResponse>;
}

/**
 * 
 * @export
 * @interface VelocityControlRequest
 */
export interface VelocityControlRequest {
    /**
     * 
     * @type {string}
     * @memberof VelocityControlRequest
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlRequest
     */
    name?: string;
    /**
     * 
     * @type {SpendControlAssociation}
     * @memberof VelocityControlRequest
     */
    association?: SpendControlAssociation;
    /**
     * 
     * @type {MerchantScope}
     * @memberof VelocityControlRequest
     */
    merchantScope?: MerchantScope;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlRequest
     */
    usageLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlRequest
     */
    approvalsOnly?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlRequest
     */
    includePurchases?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlRequest
     */
    includeWithdrawals?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlRequest
     */
    includeTransfers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlRequest
     */
    includeCashback?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlRequest
     */
    includeCredits?: boolean;
    /**
     * 
     * @type {MoneyInTransaction}
     * @memberof VelocityControlRequest
     */
    moneyInTransaction?: MoneyInTransaction;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlRequest
     */
    currencyCode: string;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlRequest
     */
    amountLimit: number;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlRequest
     */
    velocityWindow: VelocityControlRequest.VelocityWindowEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlRequest
     */
    active?: boolean;
}

/**
 * @export
 * @namespace VelocityControlRequest
 */
export namespace VelocityControlRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum VelocityWindowEnum {
        DAY = <any> 'DAY',
        WEEK = <any> 'WEEK',
        MONTH = <any> 'MONTH',
        LIFETIME = <any> 'LIFETIME',
        TRANSACTION = <any> 'TRANSACTION'
    }
}

/**
 * 
 * @export
 * @interface VelocityControlResponse
 */
export interface VelocityControlResponse {
    /**
     * 
     * @type {string}
     * @memberof VelocityControlResponse
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlResponse
     */
    name?: string;
    /**
     * 
     * @type {SpendControlAssociation}
     * @memberof VelocityControlResponse
     */
    association?: SpendControlAssociation;
    /**
     * 
     * @type {MerchantScope}
     * @memberof VelocityControlResponse
     */
    merchantScope?: MerchantScope;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlResponse
     */
    usageLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlResponse
     */
    approvalsOnly?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlResponse
     */
    includePurchases?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlResponse
     */
    includeWithdrawals?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlResponse
     */
    includeTransfers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlResponse
     */
    includeCashback?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlResponse
     */
    includeCredits?: boolean;
    /**
     * 
     * @type {MoneyInTransaction}
     * @memberof VelocityControlResponse
     */
    moneyInTransaction?: MoneyInTransaction;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlResponse
     */
    currencyCode: string;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlResponse
     */
    amountLimit: number;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlResponse
     */
    velocityWindow: VelocityControlResponse.VelocityWindowEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlResponse
     */
    active?: boolean;
}

/**
 * @export
 * @namespace VelocityControlResponse
 */
export namespace VelocityControlResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum VelocityWindowEnum {
        DAY = <any> 'DAY',
        WEEK = <any> 'WEEK',
        MONTH = <any> 'MONTH',
        LIFETIME = <any> 'LIFETIME',
        TRANSACTION = <any> 'TRANSACTION'
    }
}

/**
 * 
 * @export
 * @interface VelocityControlUpdateRequest
 */
export interface VelocityControlUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof VelocityControlUpdateRequest
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlUpdateRequest
     */
    name?: string;
    /**
     * 
     * @type {SpendControlAssociation}
     * @memberof VelocityControlUpdateRequest
     */
    association?: SpendControlAssociation;
    /**
     * 
     * @type {MerchantScope}
     * @memberof VelocityControlUpdateRequest
     */
    merchantScope?: MerchantScope;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlUpdateRequest
     */
    usageLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlUpdateRequest
     */
    approvalsOnly?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlUpdateRequest
     */
    includePurchases?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlUpdateRequest
     */
    includeWithdrawals?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlUpdateRequest
     */
    includeTransfers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlUpdateRequest
     */
    includeCashback?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlUpdateRequest
     */
    includeCredits?: boolean;
    /**
     * 
     * @type {MoneyInTransaction}
     * @memberof VelocityControlUpdateRequest
     */
    moneyInTransaction?: MoneyInTransaction;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlUpdateRequest
     */
    currencyCode?: string;
    /**
     * 
     * @type {number}
     * @memberof VelocityControlUpdateRequest
     */
    amountLimit?: number;
    /**
     * 
     * @type {string}
     * @memberof VelocityControlUpdateRequest
     */
    velocityWindow?: VelocityControlUpdateRequest.VelocityWindowEnum;
    /**
     * 
     * @type {boolean}
     * @memberof VelocityControlUpdateRequest
     */
    active?: boolean;
}

/**
 * @export
 * @namespace VelocityControlUpdateRequest
 */
export namespace VelocityControlUpdateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum VelocityWindowEnum {
        DAY = <any> 'DAY',
        WEEK = <any> 'WEEK',
        MONTH = <any> 'MONTH',
        QUARTER = <any> 'QUARTER',
        YEAR = <any> 'YEAR',
        LIFETIME = <any> 'LIFETIME',
        TRANSACTION = <any> 'TRANSACTION'
    }
}

/**
 * 
 * @export
 * @interface WalletProviderCardOnFile
 */
export interface WalletProviderCardOnFile {
    /**
     * 
     * @type {boolean}
     * @memberof WalletProviderCardOnFile
     */
    enabled?: boolean;
    /**
     * 
     * @type {DigitalWalletTokenAddressVerification}
     * @memberof WalletProviderCardOnFile
     */
    addressVerification?: DigitalWalletTokenAddressVerification;
}

/**
 * 
 * @export
 * @interface WalletProviderProfile
 */
export interface WalletProviderProfile {
    /**
     * 
     * @type {Account}
     * @memberof WalletProviderProfile
     */
    account?: Account;
    /**
     * 
     * @type {RiskAssessment}
     * @memberof WalletProviderProfile
     */
    riskAssessment?: RiskAssessment;
    /**
     * 
     * @type {string}
     * @memberof WalletProviderProfile
     */
    deviceScore?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletProviderProfile
     */
    panSource?: string;
    /**
     * 
     * @type {string}
     * @memberof WalletProviderProfile
     */
    reasonCode?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WalletProviderProfile
     */
    recommendationReasons?: Array<string>;
}

/**
 * 
 * @export
 * @interface WebPushProvisioning
 */
export interface WebPushProvisioning {
    /**
     * 
     * @type {string}
     * @memberof WebPushProvisioning
     */
    wppApplePartnerId?: string;
    /**
     * 
     * @type {string}
     * @memberof WebPushProvisioning
     */
    wppAppleCardTemplateId?: string;
    /**
     * 
     * @type {string}
     * @memberof WebPushProvisioning
     */
    wppGooglePiaid?: string;
}

/**
 * 
 * @export
 * @interface WebPushProvisioningApplePayJWSHeader
 */
export interface WebPushProvisioningApplePayJWSHeader {
    /**
     * The ID for the JWS Public Key of the key pair used to generate signature.
     * @type {string}
     * @memberof WebPushProvisioningApplePayJWSHeader
     */
    kid: string;
}

/**
 * 
 * @export
 * @interface WebPushProvisioningApplePayJWSModel
 */
export interface WebPushProvisioningApplePayJWSModel {
    /**
     * 
     * @type {WebPushProvisioningApplePayJWSHeader}
     * @memberof WebPushProvisioningApplePayJWSModel
     */
    header: WebPushProvisioningApplePayJWSHeader;
    /**
     * JWS Protected Headers, contains the Header Parameters that are integrity protected by the JWS Signature.
     * @type {string}
     * @memberof WebPushProvisioningApplePayJWSModel
     */
    _protected: string;
    /**
     * JWS payload which includes the message to be sent.
     * @type {string}
     * @memberof WebPushProvisioningApplePayJWSModel
     */
    payload: string;
    /**
     * JWS Signature
     * @type {string}
     * @memberof WebPushProvisioningApplePayJWSModel
     */
    signature: string;
}

/**
 * 
 * @export
 * @interface WebPushProvisioningApplePayJWTResponse
 */
export interface WebPushProvisioningApplePayJWTResponse {
    /**
     * 
     * @type {WebPushProvisioningApplePayJWSModel}
     * @memberof WebPushProvisioningApplePayJWTResponse
     */
    jws: WebPushProvisioningApplePayJWSModel;
    /**
     * Unique state associated with the token. MQ will return a UUID here.
     * @type {string}
     * @memberof WebPushProvisioningApplePayJWTResponse
     */
    state: string;
}

/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * Valid URL
     * @type {string}
     * @memberof Webhook
     */
    endpoint: string;
    /**
     * Authentication username
     * @type {string}
     * @memberof Webhook
     */
    username: string;
    /**
     * Authentication password
     * @type {string}
     * @memberof Webhook
     */
    password: string;
    /**
     * Authentication secret
     * @type {string}
     * @memberof Webhook
     */
    secret?: string;
}

/**
 * 
 * @export
 * @interface WebhookBaseModel
 */
export interface WebhookBaseModel {
    /**
     * 
     * @type {string}
     * @memberof WebhookBaseModel
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookBaseModel
     */
    active?: boolean;
    /**
     * 
     * @type {WebhookConfigModel}
     * @memberof WebhookBaseModel
     */
    config: WebhookConfigModel;
    /**
     * An array of event types
     * @type {Array<string>}
     * @memberof WebhookBaseModel
     */
    events: Array<string>;
}

/**
 * 
 * @export
 * @interface WebhookConfigModel
 */
export interface WebhookConfigModel {
    /**
     * Must be HTTPS
     * @type {string}
     * @memberof WebhookConfigModel
     */
    url: string;
    /**
     * Must contain upper and lowercase letters, numbers, and symbols
     * @type {string}
     * @memberof WebhookConfigModel
     */
    secret?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookConfigModel
     */
    basicAuthUsername: string;
    /**
     * Required if URL is present; must contain upper and lowercase letters, numbers, and symbols
     * @type {string}
     * @memberof WebhookConfigModel
     */
    basicAuthPassword: string;
    /**
     * Custom headers to be passed along with request
     * @type {{ [key: string]: string; }}
     * @memberof WebhookConfigModel
     */
    customHeader?: { [key: string]: string; };
    /**
     * Use MTLS for webhook
     * @type {boolean}
     * @memberof WebhookConfigModel
     */
    useMtls?: boolean;
}

/**
 * 
 * @export
 * @interface WebhookPingModel
 */
export interface WebhookPingModel {
    /**
     * 
     * @type {Array<EchoPingRequest>}
     * @memberof WebhookPingModel
     */
    pings: Array<EchoPingRequest>;
}

/**
 * 
 * @export
 * @interface WebhookRequestModel
 */
export interface WebhookRequestModel {
    /**
     * 
     * @type {string}
     * @memberof WebhookRequestModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookRequestModel
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookRequestModel
     */
    active?: boolean;
    /**
     * 
     * @type {WebhookConfigModel}
     * @memberof WebhookRequestModel
     */
    config: WebhookConfigModel;
    /**
     * An array of event types
     * @type {Array<string>}
     * @memberof WebhookRequestModel
     */
    events: Array<string>;
}

/**
 * 
 * @export
 * @interface WebhookResponseModel
 */
export interface WebhookResponseModel {
    /**
     * 
     * @type {string}
     * @memberof WebhookResponseModel
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookResponseModel
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookResponseModel
     */
    active?: boolean;
    /**
     * 
     * @type {WebhookConfigModel}
     * @memberof WebhookResponseModel
     */
    config: WebhookConfigModel;
    /**
     * An array of event types
     * @type {Array<string>}
     * @memberof WebhookResponseModel
     */
    events: Array<string>;
    /**
     * 
     * @type {Date}
     * @memberof WebhookResponseModel
     */
    createdTime?: Date;
    /**
     * 
     * @type {Date}
     * @memberof WebhookResponseModel
     */
    lastModifiedTime?: Date;
}

/**
 * 
 * @export
 * @interface WebhookResponseModelListResponse
 */
export interface WebhookResponseModelListResponse {
    /**
     * 
     * @type {number}
     * @memberof WebhookResponseModelListResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhookResponseModelListResponse
     */
    startIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof WebhookResponseModelListResponse
     */
    endIndex?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookResponseModelListResponse
     */
    isMore?: boolean;
    /**
     * 
     * @type {Array<WebhookResponseModel>}
     * @memberof WebhookResponseModelListResponse
     */
    data?: Array<WebhookResponseModel>;
}

/**
 * 
 * @export
 * @interface WebhookUpdateCustomHeaderRequest
 */
export interface WebhookUpdateCustomHeaderRequest {
    /**
     * Custom headers to be passed along with request
     * @type {{ [key: string]: string; }}
     * @memberof WebhookUpdateCustomHeaderRequest
     */
    customHeader?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface WithdrawalRequestModel
 */
export interface WithdrawalRequestModel {
    /**
     * 
     * @type {string}
     * @memberof WithdrawalRequestModel
     */
    accountType?: WithdrawalRequestModel.AccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalRequestModel
     */
    cardToken: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalRequestModel
     */
    pin?: string;
    /**
     * 
     * @type {string}
     * @memberof WithdrawalRequestModel
     */
    mid: string;
    /**
     * 
     * @type {number}
     * @memberof WithdrawalRequestModel
     */
    amount: number;
    /**
     * 
     * @type {CardAcceptorModel}
     * @memberof WithdrawalRequestModel
     */
    cardAcceptor?: CardAcceptorModel;
    /**
     * 
     * @type {Webhook}
     * @memberof WithdrawalRequestModel
     */
    webhook?: Webhook;
}

/**
 * @export
 * @namespace WithdrawalRequestModel
 */
export namespace WithdrawalRequestModel {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountTypeEnum {
        Checking = <any> 'checking',
        Savings = <any> 'savings',
        Credit = <any> 'credit'
    }
}

/**
 * 
 * @export
 * @interface XpayPushTokenizeRequestData
 */
export interface XpayPushTokenizeRequestData {
    /**
     * 
     * @type {string}
     * @memberof XpayPushTokenizeRequestData
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof XpayPushTokenizeRequestData
     */
    lastDigits?: string;
    /**
     * 
     * @type {string}
     * @memberof XpayPushTokenizeRequestData
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof XpayPushTokenizeRequestData
     */
    tokenServiceProvider?: string;
    /**
     * 
     * @type {string}
     * @memberof XpayPushTokenizeRequestData
     */
    extraProvisionPayload?: string;
    /**
     * 
     * @type {string}
     * @memberof XpayPushTokenizeRequestData
     */
    cardType?: string;
}


/**
 * AcceptedCountriesApi - fetch parameter creator
 * @export
 */
export const AcceptedCountriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all accepted countries
         * @param {number} [count] Number of accepted countries to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [name] Name
         * @param {boolean} [whitelist] Whitelist
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcceptedcountries(count?: number, startIndex?: number, name?: string, whitelist?: boolean, searchType?: string, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/acceptedcountries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (whitelist !== undefined) {
                localVarQueryParameter['whitelist'] = whitelist;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific accepted country
         * @param {string} token Accepted country token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcceptedcountriesToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getAcceptedcountriesToken.');
            }
            const localVarPath = `/acceptedcountries/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AcceptedCountriesApi - functional programming interface
 * @export
 */
export const AcceptedCountriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all accepted countries
         * @param {number} [count] Number of accepted countries to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [name] Name
         * @param {boolean} [whitelist] Whitelist
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcceptedcountries(count?: number, startIndex?: number, name?: string, whitelist?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AcceptedCountriesListResponse> {
            const localVarFetchArgs = AcceptedCountriesApiFetchParamCreator(configuration).getAcceptedcountries(count, startIndex, name, whitelist, searchType, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific accepted country
         * @param {string} token Accepted country token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcceptedcountriesToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AcceptedCountriesModel> {
            const localVarFetchArgs = AcceptedCountriesApiFetchParamCreator(configuration).getAcceptedcountriesToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AcceptedCountriesApi - factory interface
 * @export
 */
export const AcceptedCountriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all accepted countries
         * @param {number} [count] Number of accepted countries to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [name] Name
         * @param {boolean} [whitelist] Whitelist
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcceptedcountries(count?: number, startIndex?: number, name?: string, whitelist?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: any) {
            return AcceptedCountriesApiFp(configuration).getAcceptedcountries(count, startIndex, name, whitelist, searchType, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific accepted country
         * @param {string} token Accepted country token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcceptedcountriesToken(token: string, fields?: string, options?: any) {
            return AcceptedCountriesApiFp(configuration).getAcceptedcountriesToken(token, fields, options)(fetch, basePath);
        },
    };
};

/**
 * AcceptedCountriesApi - object-oriented interface
 * @export
 * @class AcceptedCountriesApi
 * @extends {BaseAPI}
 */
export class AcceptedCountriesApi extends BaseAPI {
    /**
     * 
     * @summary Lists all accepted countries
     * @param {number} [count] Number of accepted countries to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [name] Name
     * @param {boolean} [whitelist] Whitelist
     * @param {string} [searchType] Search type
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcceptedCountriesApi
     */
    public getAcceptedcountries(count?: number, startIndex?: number, name?: string, whitelist?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: any) {
        return AcceptedCountriesApiFp(this.configuration).getAcceptedcountries(count, startIndex, name, whitelist, searchType, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific accepted country
     * @param {string} token Accepted country token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AcceptedCountriesApi
     */
    public getAcceptedcountriesToken(token: string, fields?: string, options?: any) {
        return AcceptedCountriesApiFp(this.configuration).getAcceptedcountriesToken(token, fields, options)(this.fetch, this.basePath);
    }

}

/**
 * AccountHolderGroupsApi - fetch parameter creator
 * @export
 */
export const AccountHolderGroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists account holder groups
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountholdergroups(count?: number, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/accountholdergroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific account holder group object
         * @param {string} token Account holder group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountholdergroupsToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getAccountholdergroupsToken.');
            }
            const localVarPath = `/accountholdergroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an account holder group object
         * @param {AccountHolderGroupRequest} body Account holder group object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountholdergroups(body: AccountHolderGroupRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postAccountholdergroups.');
            }
            const localVarPath = `/accountholdergroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AccountHolderGroupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an account holder group object
         * @param {AccountHolderGroupUpdateRequest} body Account holder group update object
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccountholdergroupsToken(body: AccountHolderGroupUpdateRequest, token: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putAccountholdergroupsToken.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putAccountholdergroupsToken.');
            }
            const localVarPath = `/accountholdergroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AccountHolderGroupUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountHolderGroupsApi - functional programming interface
 * @export
 */
export const AccountHolderGroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists account holder groups
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountholdergroups(count?: number, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountHolderGroupListResponse> {
            const localVarFetchArgs = AccountHolderGroupsApiFetchParamCreator(configuration).getAccountholdergroups(count, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific account holder group object
         * @param {string} token Account holder group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountholdergroupsToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountHolderGroupResponse> {
            const localVarFetchArgs = AccountHolderGroupsApiFetchParamCreator(configuration).getAccountholdergroupsToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates an account holder group object
         * @param {AccountHolderGroupRequest} body Account holder group object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountholdergroups(body: AccountHolderGroupRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountHolderGroupResponse> {
            const localVarFetchArgs = AccountHolderGroupsApiFetchParamCreator(configuration).postAccountholdergroups(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an account holder group object
         * @param {AccountHolderGroupUpdateRequest} body Account holder group update object
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccountholdergroupsToken(body: AccountHolderGroupUpdateRequest, token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountHolderGroupResponse> {
            const localVarFetchArgs = AccountHolderGroupsApiFetchParamCreator(configuration).putAccountholdergroupsToken(body, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountHolderGroupsApi - factory interface
 * @export
 */
export const AccountHolderGroupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists account holder groups
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountholdergroups(count?: number, startIndex?: number, sortBy?: string, options?: any) {
            return AccountHolderGroupsApiFp(configuration).getAccountholdergroups(count, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific account holder group object
         * @param {string} token Account holder group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountholdergroupsToken(token: string, options?: any) {
            return AccountHolderGroupsApiFp(configuration).getAccountholdergroupsToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates an account holder group object
         * @param {AccountHolderGroupRequest} body Account holder group object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountholdergroups(body: AccountHolderGroupRequest, options?: any) {
            return AccountHolderGroupsApiFp(configuration).postAccountholdergroups(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an account holder group object
         * @param {AccountHolderGroupUpdateRequest} body Account holder group update object
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccountholdergroupsToken(body: AccountHolderGroupUpdateRequest, token: string, options?: any) {
            return AccountHolderGroupsApiFp(configuration).putAccountholdergroupsToken(body, token, options)(fetch, basePath);
        },
    };
};

/**
 * AccountHolderGroupsApi - object-oriented interface
 * @export
 * @class AccountHolderGroupsApi
 * @extends {BaseAPI}
 */
export class AccountHolderGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Lists account holder groups
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountHolderGroupsApi
     */
    public getAccountholdergroups(count?: number, startIndex?: number, sortBy?: string, options?: any) {
        return AccountHolderGroupsApiFp(this.configuration).getAccountholdergroups(count, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific account holder group object
     * @param {string} token Account holder group token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountHolderGroupsApi
     */
    public getAccountholdergroupsToken(token: string, options?: any) {
        return AccountHolderGroupsApiFp(this.configuration).getAccountholdergroupsToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates an account holder group object
     * @param {AccountHolderGroupRequest} body Account holder group object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountHolderGroupsApi
     */
    public postAccountholdergroups(body: AccountHolderGroupRequest, options?: any) {
        return AccountHolderGroupsApiFp(this.configuration).postAccountholdergroups(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an account holder group object
     * @param {AccountHolderGroupUpdateRequest} body Account holder group update object
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountHolderGroupsApi
     */
    public putAccountholdergroupsToken(body: AccountHolderGroupUpdateRequest, token: string, options?: any) {
        return AccountHolderGroupsApiFp(this.configuration).putAccountholdergroupsToken(body, token, options)(this.fetch, this.basePath);
    }

}

/**
 * AuthControlsApi - fetch parameter creator
 * @export
 */
export const AuthControlsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all global auth control exceptions for the program
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/authcontrols`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cardProduct !== undefined) {
                localVarQueryParameter['card_product'] = cardProduct;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all auth control exempted MIDs for the program
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsExemptmids(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/authcontrols/exemptmids`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cardProduct !== undefined) {
                localVarQueryParameter['card_product'] = cardProduct;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific auth control exemptmids
         * @param {string} token Auth control token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsExemptmidsToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getAuthcontrolsExemptmidsToken.');
            }
            const localVarPath = `/authcontrols/exemptmids/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific auth control exception
         * @param {string} token Auth control token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getAuthcontrolsToken.');
            }
            const localVarPath = `/authcontrols/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an auth control exception
         * @param {AuthControlRequest} body Auth control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthcontrols(body: AuthControlRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postAuthcontrols.');
            }
            const localVarPath = `/authcontrols`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthControlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an auth control for exempting MIDs
         * @param {AuthControlExemptMidsRequest} body Auth control exempt MID object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthcontrolsExemptmids(body: AuthControlExemptMidsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postAuthcontrolsExemptmids.');
            }
            const localVarPath = `/authcontrols/exemptmids`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthControlExemptMidsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the status an auth control exemptmids
         * @param {string} token Auth control token
         * @param {AuthControlExemptMidsUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthcontrolsExemptmidsToken(token: string, body?: AuthControlExemptMidsUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putAuthcontrolsExemptmidsToken.');
            }
            const localVarPath = `/authcontrols/exemptmids/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthControlExemptMidsUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an auth control exception
         * @param {string} token Auth control token
         * @param {AuthControlUpdateRequest} body Auth control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthcontrolsToken(token: string, body: AuthControlUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putAuthcontrolsToken.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putAuthcontrolsToken.');
            }
            const localVarPath = `/authcontrols/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthControlUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControlsApi - functional programming interface
 * @export
 */
export const AuthControlsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all global auth control exceptions for the program
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthControlListResponse> {
            const localVarFetchArgs = AuthControlsApiFetchParamCreator(configuration).getAuthcontrols(cardProduct, user, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all auth control exempted MIDs for the program
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsExemptmids(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthControlExemptMidsListResponse> {
            const localVarFetchArgs = AuthControlsApiFetchParamCreator(configuration).getAuthcontrolsExemptmids(cardProduct, user, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific auth control exemptmids
         * @param {string} token Auth control token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsExemptmidsToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthControlExemptMidsResponse> {
            const localVarFetchArgs = AuthControlsApiFetchParamCreator(configuration).getAuthcontrolsExemptmidsToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific auth control exception
         * @param {string} token Auth control token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthControlResponse> {
            const localVarFetchArgs = AuthControlsApiFetchParamCreator(configuration).getAuthcontrolsToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates an auth control exception
         * @param {AuthControlRequest} body Auth control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthcontrols(body: AuthControlRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthControlResponse> {
            const localVarFetchArgs = AuthControlsApiFetchParamCreator(configuration).postAuthcontrols(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates an auth control for exempting MIDs
         * @param {AuthControlExemptMidsRequest} body Auth control exempt MID object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthcontrolsExemptmids(body: AuthControlExemptMidsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthControlExemptMidsResponse> {
            const localVarFetchArgs = AuthControlsApiFetchParamCreator(configuration).postAuthcontrolsExemptmids(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the status an auth control exemptmids
         * @param {string} token Auth control token
         * @param {AuthControlExemptMidsUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthcontrolsExemptmidsToken(token: string, body?: AuthControlExemptMidsUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthControlsApiFetchParamCreator(configuration).putAuthcontrolsExemptmidsToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an auth control exception
         * @param {string} token Auth control token
         * @param {AuthControlUpdateRequest} body Auth control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthcontrolsToken(token: string, body: AuthControlUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthControlResponse> {
            const localVarFetchArgs = AuthControlsApiFetchParamCreator(configuration).putAuthcontrolsToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthControlsApi - factory interface
 * @export
 */
export const AuthControlsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all global auth control exceptions for the program
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return AuthControlsApiFp(configuration).getAuthcontrols(cardProduct, user, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all auth control exempted MIDs for the program
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsExemptmids(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return AuthControlsApiFp(configuration).getAuthcontrolsExemptmids(cardProduct, user, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific auth control exemptmids
         * @param {string} token Auth control token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsExemptmidsToken(token: string, options?: any) {
            return AuthControlsApiFp(configuration).getAuthcontrolsExemptmidsToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific auth control exception
         * @param {string} token Auth control token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsToken(token: string, fields?: string, options?: any) {
            return AuthControlsApiFp(configuration).getAuthcontrolsToken(token, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates an auth control exception
         * @param {AuthControlRequest} body Auth control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthcontrols(body: AuthControlRequest, options?: any) {
            return AuthControlsApiFp(configuration).postAuthcontrols(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates an auth control for exempting MIDs
         * @param {AuthControlExemptMidsRequest} body Auth control exempt MID object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthcontrolsExemptmids(body: AuthControlExemptMidsRequest, options?: any) {
            return AuthControlsApiFp(configuration).postAuthcontrolsExemptmids(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the status an auth control exemptmids
         * @param {string} token Auth control token
         * @param {AuthControlExemptMidsUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthcontrolsExemptmidsToken(token: string, body?: AuthControlExemptMidsUpdateRequest, options?: any) {
            return AuthControlsApiFp(configuration).putAuthcontrolsExemptmidsToken(token, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an auth control exception
         * @param {string} token Auth control token
         * @param {AuthControlUpdateRequest} body Auth control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthcontrolsToken(token: string, body: AuthControlUpdateRequest, options?: any) {
            return AuthControlsApiFp(configuration).putAuthcontrolsToken(token, body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthControlsApi - object-oriented interface
 * @export
 * @class AuthControlsApi
 * @extends {BaseAPI}
 */
export class AuthControlsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all global auth control exceptions for the program
     * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
     * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControlsApi
     */
    public getAuthcontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return AuthControlsApiFp(this.configuration).getAuthcontrols(cardProduct, user, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all auth control exempted MIDs for the program
     * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
     * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControlsApi
     */
    public getAuthcontrolsExemptmids(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return AuthControlsApiFp(this.configuration).getAuthcontrolsExemptmids(cardProduct, user, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific auth control exemptmids
     * @param {string} token Auth control token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControlsApi
     */
    public getAuthcontrolsExemptmidsToken(token: string, options?: any) {
        return AuthControlsApiFp(this.configuration).getAuthcontrolsExemptmidsToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific auth control exception
     * @param {string} token Auth control token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControlsApi
     */
    public getAuthcontrolsToken(token: string, fields?: string, options?: any) {
        return AuthControlsApiFp(this.configuration).getAuthcontrolsToken(token, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates an auth control exception
     * @param {AuthControlRequest} body Auth control object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControlsApi
     */
    public postAuthcontrols(body: AuthControlRequest, options?: any) {
        return AuthControlsApiFp(this.configuration).postAuthcontrols(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates an auth control for exempting MIDs
     * @param {AuthControlExemptMidsRequest} body Auth control exempt MID object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControlsApi
     */
    public postAuthcontrolsExemptmids(body: AuthControlExemptMidsRequest, options?: any) {
        return AuthControlsApiFp(this.configuration).postAuthcontrolsExemptmids(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the status an auth control exemptmids
     * @param {string} token Auth control token
     * @param {AuthControlExemptMidsUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControlsApi
     */
    public putAuthcontrolsExemptmidsToken(token: string, body?: AuthControlExemptMidsUpdateRequest, options?: any) {
        return AuthControlsApiFp(this.configuration).putAuthcontrolsExemptmidsToken(token, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an auth control exception
     * @param {string} token Auth control token
     * @param {AuthControlUpdateRequest} body Auth control object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControlsApi
     */
    public putAuthcontrolsToken(token: string, body: AuthControlUpdateRequest, options?: any) {
        return AuthControlsApiFp(this.configuration).putAuthcontrolsToken(token, body, options)(this.fetch, this.basePath);
    }

}

/**
 * AutoReloadsApi - fetch parameter creator
 * @export
 */
export const AutoReloadsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all auto reloads for the program
         * @param {string} [cardProduct] Card product token
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoreloads(cardProduct?: string, userToken?: string, businessToken?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/autoreloads`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cardProduct !== undefined) {
                localVarQueryParameter['card_product'] = cardProduct;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific auto reload object
         * @param {string} token Auto reload token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoreloadsToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getAutoreloadsToken.');
            }
            const localVarPath = `/autoreloads/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an auto reload object
         * @param {AutoReloadModel} body Auto reload object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAutoreloads(body: AutoReloadModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postAutoreloads.');
            }
            const localVarPath = `/autoreloads`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutoReloadModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific auto reload object
         * @param {AutoReloadUpdateModel} body Auto reload object
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAutoreloadsToken(body: AutoReloadUpdateModel, token: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putAutoreloadsToken.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putAutoreloadsToken.');
            }
            const localVarPath = `/autoreloads/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutoReloadUpdateModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoReloadsApi - functional programming interface
 * @export
 */
export const AutoReloadsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all auto reloads for the program
         * @param {string} [cardProduct] Card product token
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoreloads(cardProduct?: string, userToken?: string, businessToken?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoReloadListResponse> {
            const localVarFetchArgs = AutoReloadsApiFetchParamCreator(configuration).getAutoreloads(cardProduct, userToken, businessToken, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific auto reload object
         * @param {string} token Auto reload token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoreloadsToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoReloadResponseModel> {
            const localVarFetchArgs = AutoReloadsApiFetchParamCreator(configuration).getAutoreloadsToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates an auto reload object
         * @param {AutoReloadModel} body Auto reload object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAutoreloads(body: AutoReloadModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoReloadResponseModel> {
            const localVarFetchArgs = AutoReloadsApiFetchParamCreator(configuration).postAutoreloads(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific auto reload object
         * @param {AutoReloadUpdateModel} body Auto reload object
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAutoreloadsToken(body: AutoReloadUpdateModel, token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoReloadResponseModel> {
            const localVarFetchArgs = AutoReloadsApiFetchParamCreator(configuration).putAutoreloadsToken(body, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AutoReloadsApi - factory interface
 * @export
 */
export const AutoReloadsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all auto reloads for the program
         * @param {string} [cardProduct] Card product token
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoreloads(cardProduct?: string, userToken?: string, businessToken?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return AutoReloadsApiFp(configuration).getAutoreloads(cardProduct, userToken, businessToken, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific auto reload object
         * @param {string} token Auto reload token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoreloadsToken(token: string, fields?: string, options?: any) {
            return AutoReloadsApiFp(configuration).getAutoreloadsToken(token, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates an auto reload object
         * @param {AutoReloadModel} body Auto reload object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAutoreloads(body: AutoReloadModel, options?: any) {
            return AutoReloadsApiFp(configuration).postAutoreloads(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific auto reload object
         * @param {AutoReloadUpdateModel} body Auto reload object
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAutoreloadsToken(body: AutoReloadUpdateModel, token: string, options?: any) {
            return AutoReloadsApiFp(configuration).putAutoreloadsToken(body, token, options)(fetch, basePath);
        },
    };
};

/**
 * AutoReloadsApi - object-oriented interface
 * @export
 * @class AutoReloadsApi
 * @extends {BaseAPI}
 */
export class AutoReloadsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all auto reloads for the program
     * @param {string} [cardProduct] Card product token
     * @param {string} [userToken] User token
     * @param {string} [businessToken] Business token
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoReloadsApi
     */
    public getAutoreloads(cardProduct?: string, userToken?: string, businessToken?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return AutoReloadsApiFp(this.configuration).getAutoreloads(cardProduct, userToken, businessToken, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific auto reload object
     * @param {string} token Auto reload token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoReloadsApi
     */
    public getAutoreloadsToken(token: string, fields?: string, options?: any) {
        return AutoReloadsApiFp(this.configuration).getAutoreloadsToken(token, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates an auto reload object
     * @param {AutoReloadModel} body Auto reload object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoReloadsApi
     */
    public postAutoreloads(body: AutoReloadModel, options?: any) {
        return AutoReloadsApiFp(this.configuration).postAutoreloads(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific auto reload object
     * @param {AutoReloadUpdateModel} body Auto reload object
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoReloadsApi
     */
    public putAutoreloadsToken(body: AutoReloadUpdateModel, token: string, options?: any) {
        return AutoReloadsApiFp(this.configuration).putAutoreloadsToken(body, token, options)(this.fetch, this.basePath);
    }

}

/**
 * BankTransfersApi - fetch parameter creator
 * @export
 */
export const BankTransfersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all bank transfers
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [fundingSourceToken] Funding source token
         * @param {string} [statuses] A comma-delimited list of bank transfer status(s)
         * @param {string} [sortBy] Sort order
         * @param {string} [expand] Object to expand
         * @param {string} [fundingSourceType] Funding source type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAch(count?: number, startIndex?: number, userToken?: string, businessToken?: string, fundingSourceToken?: string, statuses?: string, sortBy?: string, expand?: string, fundingSourceType?: string, options: any = {}): FetchArgs {
            const localVarPath = `/banktransfers/ach`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (fundingSourceToken !== undefined) {
                localVarQueryParameter['funding_source_token'] = fundingSourceToken;
            }

            if (statuses !== undefined) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (fundingSourceType !== undefined) {
                localVarQueryParameter['funding_source_type'] = fundingSourceType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a bank transfer entry
         * @param {string} token Bank transfer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAchToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getBanktransfersAchToken.');
            }
            const localVarPath = `/banktransfers/ach/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all bank transfer transitions
         * @param {number} [count] Number of bank transfer transitions to retrieve
         * @param {string} [token] Bank transfer transition token
         * @param {string} [bankTransferToken] Bank transfer token
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [statuses] Comma-delimited list of bank transfer states to display e.g. PENDING | PROCESSING | SUBMITTED | RETURNED |  COMPLETED | CANCELLED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAchTransitions(count?: number, token?: string, bankTransferToken?: string, startIndex?: number, sortBy?: string, statuses?: string, options: any = {}): FetchArgs {
            const localVarPath = `/banktransfers/ach/transitions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (bankTransferToken !== undefined) {
                localVarQueryParameter['bank_transfer_token'] = bankTransferToken;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (statuses !== undefined) {
                localVarQueryParameter['statuses'] = statuses;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Applies a provisional credit to a bank transfer
         * @param {EarlyFundsRequestModel} body Early funds request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplyProvisionalCreditToBankTransfer(body: EarlyFundsRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postApplyProvisionalCreditToBankTransfer.');
            }
            const localVarPath = `/banktransfers/ach/earlyfunds`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EarlyFundsRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an ACH bank transfer
         * @param {BankTransferRequestModel} body Create bank transfer request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBanktransfersAch(body: BankTransferRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postBanktransfersAch.');
            }
            const localVarPath = `/banktransfers/ach`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BankTransferRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an ACH bank transfer transition
         * @param {BankTransferTransitionRequestModel} body Create bank transfer transition request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBanktransfersAchTransitions(body: BankTransferTransitionRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postBanktransfersAchTransitions.');
            }
            const localVarPath = `/banktransfers/ach/transitions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BankTransferTransitionRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankTransfersApi - functional programming interface
 * @export
 */
export const BankTransfersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all bank transfers
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [fundingSourceToken] Funding source token
         * @param {string} [statuses] A comma-delimited list of bank transfer status(s)
         * @param {string} [sortBy] Sort order
         * @param {string} [expand] Object to expand
         * @param {string} [fundingSourceType] Funding source type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAch(count?: number, startIndex?: number, userToken?: string, businessToken?: string, fundingSourceToken?: string, statuses?: string, sortBy?: string, expand?: string, fundingSourceType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankTransferListResponse> {
            const localVarFetchArgs = BankTransfersApiFetchParamCreator(configuration).getBanktransfersAch(count, startIndex, userToken, businessToken, fundingSourceToken, statuses, sortBy, expand, fundingSourceType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a bank transfer entry
         * @param {string} token Bank transfer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAchToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankTransferResponseModel> {
            const localVarFetchArgs = BankTransfersApiFetchParamCreator(configuration).getBanktransfersAchToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all bank transfer transitions
         * @param {number} [count] Number of bank transfer transitions to retrieve
         * @param {string} [token] Bank transfer transition token
         * @param {string} [bankTransferToken] Bank transfer token
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [statuses] Comma-delimited list of bank transfer states to display e.g. PENDING | PROCESSING | SUBMITTED | RETURNED |  COMPLETED | CANCELLED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAchTransitions(count?: number, token?: string, bankTransferToken?: string, startIndex?: number, sortBy?: string, statuses?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankTransferTransitionListResponse> {
            const localVarFetchArgs = BankTransfersApiFetchParamCreator(configuration).getBanktransfersAchTransitions(count, token, bankTransferToken, startIndex, sortBy, statuses, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Applies a provisional credit to a bank transfer
         * @param {EarlyFundsRequestModel} body Early funds request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplyProvisionalCreditToBankTransfer(body: EarlyFundsRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankTransferResponseModel> {
            const localVarFetchArgs = BankTransfersApiFetchParamCreator(configuration).postApplyProvisionalCreditToBankTransfer(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates an ACH bank transfer
         * @param {BankTransferRequestModel} body Create bank transfer request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBanktransfersAch(body: BankTransferRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankTransferResponseModel> {
            const localVarFetchArgs = BankTransfersApiFetchParamCreator(configuration).postBanktransfersAch(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates an ACH bank transfer transition
         * @param {BankTransferTransitionRequestModel} body Create bank transfer transition request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBanktransfersAchTransitions(body: BankTransferTransitionRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BankTransferTransitionResponseModel> {
            const localVarFetchArgs = BankTransfersApiFetchParamCreator(configuration).postBanktransfersAchTransitions(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BankTransfersApi - factory interface
 * @export
 */
export const BankTransfersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all bank transfers
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [fundingSourceToken] Funding source token
         * @param {string} [statuses] A comma-delimited list of bank transfer status(s)
         * @param {string} [sortBy] Sort order
         * @param {string} [expand] Object to expand
         * @param {string} [fundingSourceType] Funding source type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAch(count?: number, startIndex?: number, userToken?: string, businessToken?: string, fundingSourceToken?: string, statuses?: string, sortBy?: string, expand?: string, fundingSourceType?: string, options?: any) {
            return BankTransfersApiFp(configuration).getBanktransfersAch(count, startIndex, userToken, businessToken, fundingSourceToken, statuses, sortBy, expand, fundingSourceType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a bank transfer entry
         * @param {string} token Bank transfer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAchToken(token: string, options?: any) {
            return BankTransfersApiFp(configuration).getBanktransfersAchToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all bank transfer transitions
         * @param {number} [count] Number of bank transfer transitions to retrieve
         * @param {string} [token] Bank transfer transition token
         * @param {string} [bankTransferToken] Bank transfer token
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [statuses] Comma-delimited list of bank transfer states to display e.g. PENDING | PROCESSING | SUBMITTED | RETURNED |  COMPLETED | CANCELLED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAchTransitions(count?: number, token?: string, bankTransferToken?: string, startIndex?: number, sortBy?: string, statuses?: string, options?: any) {
            return BankTransfersApiFp(configuration).getBanktransfersAchTransitions(count, token, bankTransferToken, startIndex, sortBy, statuses, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Applies a provisional credit to a bank transfer
         * @param {EarlyFundsRequestModel} body Early funds request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplyProvisionalCreditToBankTransfer(body: EarlyFundsRequestModel, options?: any) {
            return BankTransfersApiFp(configuration).postApplyProvisionalCreditToBankTransfer(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates an ACH bank transfer
         * @param {BankTransferRequestModel} body Create bank transfer request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBanktransfersAch(body: BankTransferRequestModel, options?: any) {
            return BankTransfersApiFp(configuration).postBanktransfersAch(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates an ACH bank transfer transition
         * @param {BankTransferTransitionRequestModel} body Create bank transfer transition request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBanktransfersAchTransitions(body: BankTransferTransitionRequestModel, options?: any) {
            return BankTransfersApiFp(configuration).postBanktransfersAchTransitions(body, options)(fetch, basePath);
        },
    };
};

/**
 * BankTransfersApi - object-oriented interface
 * @export
 * @class BankTransfersApi
 * @extends {BaseAPI}
 */
export class BankTransfersApi extends BaseAPI {
    /**
     * 
     * @summary Lists all bank transfers
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [userToken] User token
     * @param {string} [businessToken] Business token
     * @param {string} [fundingSourceToken] Funding source token
     * @param {string} [statuses] A comma-delimited list of bank transfer status(s)
     * @param {string} [sortBy] Sort order
     * @param {string} [expand] Object to expand
     * @param {string} [fundingSourceType] Funding source type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransfersApi
     */
    public getBanktransfersAch(count?: number, startIndex?: number, userToken?: string, businessToken?: string, fundingSourceToken?: string, statuses?: string, sortBy?: string, expand?: string, fundingSourceType?: string, options?: any) {
        return BankTransfersApiFp(this.configuration).getBanktransfersAch(count, startIndex, userToken, businessToken, fundingSourceToken, statuses, sortBy, expand, fundingSourceType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a bank transfer entry
     * @param {string} token Bank transfer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransfersApi
     */
    public getBanktransfersAchToken(token: string, options?: any) {
        return BankTransfersApiFp(this.configuration).getBanktransfersAchToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all bank transfer transitions
     * @param {number} [count] Number of bank transfer transitions to retrieve
     * @param {string} [token] Bank transfer transition token
     * @param {string} [bankTransferToken] Bank transfer token
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {string} [statuses] Comma-delimited list of bank transfer states to display e.g. PENDING | PROCESSING | SUBMITTED | RETURNED |  COMPLETED | CANCELLED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransfersApi
     */
    public getBanktransfersAchTransitions(count?: number, token?: string, bankTransferToken?: string, startIndex?: number, sortBy?: string, statuses?: string, options?: any) {
        return BankTransfersApiFp(this.configuration).getBanktransfersAchTransitions(count, token, bankTransferToken, startIndex, sortBy, statuses, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Applies a provisional credit to a bank transfer
     * @param {EarlyFundsRequestModel} body Early funds request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransfersApi
     */
    public postApplyProvisionalCreditToBankTransfer(body: EarlyFundsRequestModel, options?: any) {
        return BankTransfersApiFp(this.configuration).postApplyProvisionalCreditToBankTransfer(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates an ACH bank transfer
     * @param {BankTransferRequestModel} body Create bank transfer request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransfersApi
     */
    public postBanktransfersAch(body: BankTransferRequestModel, options?: any) {
        return BankTransfersApiFp(this.configuration).postBanktransfersAch(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates an ACH bank transfer transition
     * @param {BankTransferTransitionRequestModel} body Create bank transfer transition request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankTransfersApi
     */
    public postBanktransfersAchTransitions(body: BankTransferTransitionRequestModel, options?: any) {
        return BankTransfersApiFp(this.configuration).postBanktransfersAchTransitions(body, options)(this.fetch, this.basePath);
    }

}

/**
 * BulkIssuancesApi - fetch parameter creator
 * @export
 */
export const BulkIssuancesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all bulk issuance requests
         * @param {number} [count] Number of requests to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkissuances(count?: number, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/bulkissuances`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a bulk issuance request
         * @param {string} token Bulk issuance token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkissuancesToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getBulkissuancesToken.');
            }
            const localVarPath = `/bulkissuances/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a bulk issuance request for cards
         * @param {BulkIssuanceRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBulkissuances(body?: BulkIssuanceRequest, options: any = {}): FetchArgs {
            const localVarPath = `/bulkissuances`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkIssuanceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BulkIssuancesApi - functional programming interface
 * @export
 */
export const BulkIssuancesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all bulk issuance requests
         * @param {number} [count] Number of requests to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkissuances(count?: number, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BulkCardOrderListResponse> {
            const localVarFetchArgs = BulkIssuancesApiFetchParamCreator(configuration).getBulkissuances(count, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a bulk issuance request
         * @param {string} token Bulk issuance token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkissuancesToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BulkIssuanceResponse> {
            const localVarFetchArgs = BulkIssuancesApiFetchParamCreator(configuration).getBulkissuancesToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a bulk issuance request for cards
         * @param {BulkIssuanceRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBulkissuances(body?: BulkIssuanceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BulkIssuanceResponse> {
            const localVarFetchArgs = BulkIssuancesApiFetchParamCreator(configuration).postBulkissuances(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BulkIssuancesApi - factory interface
 * @export
 */
export const BulkIssuancesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all bulk issuance requests
         * @param {number} [count] Number of requests to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkissuances(count?: number, startIndex?: number, sortBy?: string, options?: any) {
            return BulkIssuancesApiFp(configuration).getBulkissuances(count, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a bulk issuance request
         * @param {string} token Bulk issuance token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkissuancesToken(token: string, options?: any) {
            return BulkIssuancesApiFp(configuration).getBulkissuancesToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a bulk issuance request for cards
         * @param {BulkIssuanceRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBulkissuances(body?: BulkIssuanceRequest, options?: any) {
            return BulkIssuancesApiFp(configuration).postBulkissuances(body, options)(fetch, basePath);
        },
    };
};

/**
 * BulkIssuancesApi - object-oriented interface
 * @export
 * @class BulkIssuancesApi
 * @extends {BaseAPI}
 */
export class BulkIssuancesApi extends BaseAPI {
    /**
     * 
     * @summary Lists all bulk issuance requests
     * @param {number} [count] Number of requests to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkIssuancesApi
     */
    public getBulkissuances(count?: number, startIndex?: number, sortBy?: string, options?: any) {
        return BulkIssuancesApiFp(this.configuration).getBulkissuances(count, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a bulk issuance request
     * @param {string} token Bulk issuance token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkIssuancesApi
     */
    public getBulkissuancesToken(token: string, options?: any) {
        return BulkIssuancesApiFp(this.configuration).getBulkissuancesToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a bulk issuance request for cards
     * @param {BulkIssuanceRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkIssuancesApi
     */
    public postBulkissuances(body?: BulkIssuanceRequest, options?: any) {
        return BulkIssuancesApiFp(this.configuration).postBulkissuances(body, options)(this.fetch, this.basePath);
    }

}

/**
 * BusinessTransitionsApi - fetch parameter creator
 * @export
 */
export const BusinessTransitionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns transitions for a given business
         * @param {string} businessToken Business token
         * @param {number} [count] Number of business transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesstransitionsBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'businessToken' is not null or undefined
            if (businessToken === null || businessToken === undefined) {
                throw new RequiredError('businessToken','Required parameter businessToken was null or undefined when calling getBusinesstransitionsBusinessBusinesstoken.');
            }
            const localVarPath = `/businesstransitions/business/{business_token}`
                .replace(`{${"business_token"}}`, encodeURIComponent(String(businessToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a business transition
         * @param {string} token Transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesstransitionsToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getBusinesstransitionsToken.');
            }
            const localVarPath = `/businesstransitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a business transition
         * @param {BusinessTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinesstransitions(body?: BusinessTransitionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/businesstransitions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BusinessTransitionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BusinessTransitionsApi - functional programming interface
 * @export
 */
export const BusinessTransitionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns transitions for a given business
         * @param {string} businessToken Business token
         * @param {number} [count] Number of business transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesstransitionsBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessTransitionListResponse> {
            const localVarFetchArgs = BusinessTransitionsApiFetchParamCreator(configuration).getBusinesstransitionsBusinessBusinesstoken(businessToken, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a business transition
         * @param {string} token Transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesstransitionsToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessTransitionResponse> {
            const localVarFetchArgs = BusinessTransitionsApiFetchParamCreator(configuration).getBusinesstransitionsToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a business transition
         * @param {BusinessTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinesstransitions(body?: BusinessTransitionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessTransitionResponse> {
            const localVarFetchArgs = BusinessTransitionsApiFetchParamCreator(configuration).postBusinesstransitions(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BusinessTransitionsApi - factory interface
 * @export
 */
export const BusinessTransitionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns transitions for a given business
         * @param {string} businessToken Business token
         * @param {number} [count] Number of business transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesstransitionsBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return BusinessTransitionsApiFp(configuration).getBusinesstransitionsBusinessBusinesstoken(businessToken, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a business transition
         * @param {string} token Transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesstransitionsToken(token: string, fields?: string, options?: any) {
            return BusinessTransitionsApiFp(configuration).getBusinesstransitionsToken(token, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a business transition
         * @param {BusinessTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinesstransitions(body?: BusinessTransitionRequest, options?: any) {
            return BusinessTransitionsApiFp(configuration).postBusinesstransitions(body, options)(fetch, basePath);
        },
    };
};

/**
 * BusinessTransitionsApi - object-oriented interface
 * @export
 * @class BusinessTransitionsApi
 * @extends {BaseAPI}
 */
export class BusinessTransitionsApi extends BaseAPI {
    /**
     * 
     * @summary Returns transitions for a given business
     * @param {string} businessToken Business token
     * @param {number} [count] Number of business transitions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessTransitionsApi
     */
    public getBusinesstransitionsBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return BusinessTransitionsApiFp(this.configuration).getBusinesstransitionsBusinessBusinesstoken(businessToken, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a business transition
     * @param {string} token Transition token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessTransitionsApi
     */
    public getBusinesstransitionsToken(token: string, fields?: string, options?: any) {
        return BusinessTransitionsApiFp(this.configuration).getBusinesstransitionsToken(token, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a business transition
     * @param {BusinessTransitionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessTransitionsApi
     */
    public postBusinesstransitions(body?: BusinessTransitionRequest, options?: any) {
        return BusinessTransitionsApiFp(this.configuration).postBusinesstransitions(body, options)(this.fetch, this.basePath);
    }

}

/**
 * BusinessesApi - fetch parameter creator
 * @export
 */
export const BusinessesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all businesses
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [businessNameDba] Business name DBA
         * @param {string} [businessNameLegal] Business name legal
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesses(count?: number, startIndex?: number, businessNameDba?: string, businessNameLegal?: string, searchType?: string, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/businesses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (businessNameDba !== undefined) {
                localVarQueryParameter['business_name_dba'] = businessNameDba;
            }

            if (businessNameLegal !== undefined) {
                localVarQueryParameter['business_name_legal'] = businessNameLegal;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all children of a parent business
         * @param {string} parentToken Token of parent business
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'parentToken' is not null or undefined
            if (parentToken === null || parentToken === undefined) {
                throw new RequiredError('parentToken','Required parameter parentToken was null or undefined when calling getBusinessesParenttokenChildren.');
            }
            const localVarPath = `/businesses/{parent_token}/children`
                .replace(`{${"parent_token"}}`, encodeURIComponent(String(parentToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific business
         * @param {string} token Business token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getBusinessesToken.');
            }
            const localVarPath = `/businesses/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists business notes
         * @param {string} token Business token
         * @param {number} [startIndex] Start index
         * @param {number} [count] Number of notes to retrieve
         * @param {string} [createdBy] Created by
         * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
         * @param {boolean} [includePrivate] Include private notes and private fields in note response
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getBusinessesTokenNotes.');
            }
            const localVarPath = `/businesses/{token}/notes`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (createdByUserRole !== undefined) {
                localVarQueryParameter['created_by_user_role'] = createdByUserRole;
            }

            if (includePrivate !== undefined) {
                localVarQueryParameter['include_private'] = includePrivate;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific business proprietor's SSN
         * @param {string} token Business token
         * @param {boolean} [fullSsn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesTokenSsn(token: string, fullSsn?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getBusinessesTokenSsn.');
            }
            const localVarPath = `/businesses/{token}/ssn`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fullSsn !== undefined) {
                localVarQueryParameter['full_ssn'] = fullSsn;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a business
         * @param {BusinessCardholder} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinesses(body?: BusinessCardholder, options: any = {}): FetchArgs {
            const localVarPath = `/businesses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BusinessCardholder" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific business
         * @param {DDARequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinessesLookup(body?: DDARequest, options: any = {}): FetchArgs {
            const localVarPath = `/businesses/lookup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DDARequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a note for a business
         * @param {string} token Business token
         * @param {CardholderNoteRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinessesTokenNotes(token: string, body?: CardholderNoteRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling postBusinessesTokenNotes.');
            }
            const localVarPath = `/businesses/{token}/notes`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardholderNoteRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific business
         * @param {string} token Business token
         * @param {BusinessCardHolderUpdate} body Business object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBusinessesToken(token: string, body: BusinessCardHolderUpdate, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putBusinessesToken.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putBusinessesToken.');
            }
            const localVarPath = `/businesses/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BusinessCardHolderUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific note for a business
         * @param {string} token Business token
         * @param {string} notesToken Notes token
         * @param {CardholderNoteUpdateRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBusinessesTokenNotesNotestoken(token: string, notesToken: string, body?: CardholderNoteUpdateRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putBusinessesTokenNotesNotestoken.');
            }
            // verify required parameter 'notesToken' is not null or undefined
            if (notesToken === null || notesToken === undefined) {
                throw new RequiredError('notesToken','Required parameter notesToken was null or undefined when calling putBusinessesTokenNotesNotestoken.');
            }
            const localVarPath = `/businesses/{token}/notes/{notes_token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"notes_token"}}`, encodeURIComponent(String(notesToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardholderNoteUpdateRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BusinessesApi - functional programming interface
 * @export
 */
export const BusinessesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all businesses
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [businessNameDba] Business name DBA
         * @param {string} [businessNameLegal] Business name legal
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesses(count?: number, startIndex?: number, businessNameDba?: string, businessNameLegal?: string, searchType?: string, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessCardHolderListResponse> {
            const localVarFetchArgs = BusinessesApiFetchParamCreator(configuration).getBusinesses(count, startIndex, businessNameDba, businessNameLegal, searchType, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all children of a parent business
         * @param {string} parentToken Token of parent business
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessUserCardHolderListResponse> {
            const localVarFetchArgs = BusinessesApiFetchParamCreator(configuration).getBusinessesParenttokenChildren(parentToken, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific business
         * @param {string} token Business token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessCardHolderResponse> {
            const localVarFetchArgs = BusinessesApiFetchParamCreator(configuration).getBusinessesToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists business notes
         * @param {string} token Business token
         * @param {number} [startIndex] Start index
         * @param {number} [count] Number of notes to retrieve
         * @param {string} [createdBy] Created by
         * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
         * @param {boolean} [includePrivate] Include private notes and private fields in note response
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardHolderNoteListResponse> {
            const localVarFetchArgs = BusinessesApiFetchParamCreator(configuration).getBusinessesTokenNotes(token, startIndex, count, createdBy, createdByUserRole, includePrivate, searchType, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific business proprietor's SSN
         * @param {string} token Business token
         * @param {boolean} [fullSsn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesTokenSsn(token: string, fullSsn?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SsnResponseModel> {
            const localVarFetchArgs = BusinessesApiFetchParamCreator(configuration).getBusinessesTokenSsn(token, fullSsn, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a business
         * @param {BusinessCardholder} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinesses(body?: BusinessCardholder, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessCardHolderResponse> {
            const localVarFetchArgs = BusinessesApiFetchParamCreator(configuration).postBusinesses(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific business
         * @param {DDARequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinessesLookup(body?: DDARequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessCardholder> {
            const localVarFetchArgs = BusinessesApiFetchParamCreator(configuration).postBusinessesLookup(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a note for a business
         * @param {string} token Business token
         * @param {CardholderNoteRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinessesTokenNotes(token: string, body?: CardholderNoteRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardholderNoteResponseModel> {
            const localVarFetchArgs = BusinessesApiFetchParamCreator(configuration).postBusinessesTokenNotes(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific business
         * @param {string} token Business token
         * @param {BusinessCardHolderUpdate} body Business object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBusinessesToken(token: string, body: BusinessCardHolderUpdate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BusinessCardholder> {
            const localVarFetchArgs = BusinessesApiFetchParamCreator(configuration).putBusinessesToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific note for a business
         * @param {string} token Business token
         * @param {string} notesToken Notes token
         * @param {CardholderNoteUpdateRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBusinessesTokenNotesNotestoken(token: string, notesToken: string, body?: CardholderNoteUpdateRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardholderNoteResponseModel> {
            const localVarFetchArgs = BusinessesApiFetchParamCreator(configuration).putBusinessesTokenNotesNotestoken(token, notesToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BusinessesApi - factory interface
 * @export
 */
export const BusinessesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all businesses
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [businessNameDba] Business name DBA
         * @param {string} [businessNameLegal] Business name legal
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesses(count?: number, startIndex?: number, businessNameDba?: string, businessNameLegal?: string, searchType?: string, fields?: string, sortBy?: string, options?: any) {
            return BusinessesApiFp(configuration).getBusinesses(count, startIndex, businessNameDba, businessNameLegal, searchType, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all children of a parent business
         * @param {string} parentToken Token of parent business
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return BusinessesApiFp(configuration).getBusinessesParenttokenChildren(parentToken, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific business
         * @param {string} token Business token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesToken(token: string, fields?: string, options?: any) {
            return BusinessesApiFp(configuration).getBusinessesToken(token, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists business notes
         * @param {string} token Business token
         * @param {number} [startIndex] Start index
         * @param {number} [count] Number of notes to retrieve
         * @param {string} [createdBy] Created by
         * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
         * @param {boolean} [includePrivate] Include private notes and private fields in note response
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: any) {
            return BusinessesApiFp(configuration).getBusinessesTokenNotes(token, startIndex, count, createdBy, createdByUserRole, includePrivate, searchType, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific business proprietor's SSN
         * @param {string} token Business token
         * @param {boolean} [fullSsn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesTokenSsn(token: string, fullSsn?: boolean, options?: any) {
            return BusinessesApiFp(configuration).getBusinessesTokenSsn(token, fullSsn, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a business
         * @param {BusinessCardholder} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinesses(body?: BusinessCardholder, options?: any) {
            return BusinessesApiFp(configuration).postBusinesses(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific business
         * @param {DDARequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinessesLookup(body?: DDARequest, options?: any) {
            return BusinessesApiFp(configuration).postBusinessesLookup(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a note for a business
         * @param {string} token Business token
         * @param {CardholderNoteRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinessesTokenNotes(token: string, body?: CardholderNoteRequestModel, options?: any) {
            return BusinessesApiFp(configuration).postBusinessesTokenNotes(token, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific business
         * @param {string} token Business token
         * @param {BusinessCardHolderUpdate} body Business object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBusinessesToken(token: string, body: BusinessCardHolderUpdate, options?: any) {
            return BusinessesApiFp(configuration).putBusinessesToken(token, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific note for a business
         * @param {string} token Business token
         * @param {string} notesToken Notes token
         * @param {CardholderNoteUpdateRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBusinessesTokenNotesNotestoken(token: string, notesToken: string, body?: CardholderNoteUpdateRequestModel, options?: any) {
            return BusinessesApiFp(configuration).putBusinessesTokenNotesNotestoken(token, notesToken, body, options)(fetch, basePath);
        },
    };
};

/**
 * BusinessesApi - object-oriented interface
 * @export
 * @class BusinessesApi
 * @extends {BaseAPI}
 */
export class BusinessesApi extends BaseAPI {
    /**
     * 
     * @summary Lists all businesses
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [businessNameDba] Business name DBA
     * @param {string} [businessNameLegal] Business name legal
     * @param {string} [searchType] Search type
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessesApi
     */
    public getBusinesses(count?: number, startIndex?: number, businessNameDba?: string, businessNameLegal?: string, searchType?: string, fields?: string, sortBy?: string, options?: any) {
        return BusinessesApiFp(this.configuration).getBusinesses(count, startIndex, businessNameDba, businessNameLegal, searchType, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all children of a parent business
     * @param {string} parentToken Token of parent business
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessesApi
     */
    public getBusinessesParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return BusinessesApiFp(this.configuration).getBusinessesParenttokenChildren(parentToken, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific business
     * @param {string} token Business token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessesApi
     */
    public getBusinessesToken(token: string, fields?: string, options?: any) {
        return BusinessesApiFp(this.configuration).getBusinessesToken(token, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists business notes
     * @param {string} token Business token
     * @param {number} [startIndex] Start index
     * @param {number} [count] Number of notes to retrieve
     * @param {string} [createdBy] Created by
     * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
     * @param {boolean} [includePrivate] Include private notes and private fields in note response
     * @param {string} [searchType] Search type
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessesApi
     */
    public getBusinessesTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: any) {
        return BusinessesApiFp(this.configuration).getBusinessesTokenNotes(token, startIndex, count, createdBy, createdByUserRole, includePrivate, searchType, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific business proprietor's SSN
     * @param {string} token Business token
     * @param {boolean} [fullSsn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessesApi
     */
    public getBusinessesTokenSsn(token: string, fullSsn?: boolean, options?: any) {
        return BusinessesApiFp(this.configuration).getBusinessesTokenSsn(token, fullSsn, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a business
     * @param {BusinessCardholder} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessesApi
     */
    public postBusinesses(body?: BusinessCardholder, options?: any) {
        return BusinessesApiFp(this.configuration).postBusinesses(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific business
     * @param {DDARequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessesApi
     */
    public postBusinessesLookup(body?: DDARequest, options?: any) {
        return BusinessesApiFp(this.configuration).postBusinessesLookup(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a note for a business
     * @param {string} token Business token
     * @param {CardholderNoteRequestModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessesApi
     */
    public postBusinessesTokenNotes(token: string, body?: CardholderNoteRequestModel, options?: any) {
        return BusinessesApiFp(this.configuration).postBusinessesTokenNotes(token, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific business
     * @param {string} token Business token
     * @param {BusinessCardHolderUpdate} body Business object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessesApi
     */
    public putBusinessesToken(token: string, body: BusinessCardHolderUpdate, options?: any) {
        return BusinessesApiFp(this.configuration).putBusinessesToken(token, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific note for a business
     * @param {string} token Business token
     * @param {string} notesToken Notes token
     * @param {CardholderNoteUpdateRequestModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessesApi
     */
    public putBusinessesTokenNotesNotestoken(token: string, notesToken: string, body?: CardholderNoteUpdateRequestModel, options?: any) {
        return BusinessesApiFp(this.configuration).putBusinessesTokenNotesNotestoken(token, notesToken, body, options)(this.fetch, this.basePath);
    }

}

/**
 * CardProductsApi - fetch parameter creator
 * @export
 */
export const CardProductsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all card products
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardproducts(count?: number, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/cardproducts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific card product
         * @param {string} token Card product token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardproductsToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getCardproductsToken.');
            }
            const localVarPath = `/cardproducts/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a card product
         * @param {CardProductRequest} body Card product object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardproducts(body: CardProductRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postCardproducts.');
            }
            const localVarPath = `/cardproducts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardProductRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific card product
         * @param {string} token Card product token
         * @param {CardProductUpdateModel} body Card product object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCardproductsToken(token: string, body: CardProductUpdateModel, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putCardproductsToken.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putCardproductsToken.');
            }
            const localVarPath = `/cardproducts/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardProductUpdateModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardProductsApi - functional programming interface
 * @export
 */
export const CardProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all card products
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardproducts(count?: number, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardProductListResponse> {
            const localVarFetchArgs = CardProductsApiFetchParamCreator(configuration).getCardproducts(count, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific card product
         * @param {string} token Card product token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardproductsToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardProductResponse> {
            const localVarFetchArgs = CardProductsApiFetchParamCreator(configuration).getCardproductsToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a card product
         * @param {CardProductRequest} body Card product object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardproducts(body: CardProductRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardProductResponse> {
            const localVarFetchArgs = CardProductsApiFetchParamCreator(configuration).postCardproducts(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific card product
         * @param {string} token Card product token
         * @param {CardProductUpdateModel} body Card product object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCardproductsToken(token: string, body: CardProductUpdateModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardProductResponse> {
            const localVarFetchArgs = CardProductsApiFetchParamCreator(configuration).putCardproductsToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CardProductsApi - factory interface
 * @export
 */
export const CardProductsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all card products
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardproducts(count?: number, startIndex?: number, sortBy?: string, options?: any) {
            return CardProductsApiFp(configuration).getCardproducts(count, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific card product
         * @param {string} token Card product token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardproductsToken(token: string, options?: any) {
            return CardProductsApiFp(configuration).getCardproductsToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a card product
         * @param {CardProductRequest} body Card product object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardproducts(body: CardProductRequest, options?: any) {
            return CardProductsApiFp(configuration).postCardproducts(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific card product
         * @param {string} token Card product token
         * @param {CardProductUpdateModel} body Card product object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCardproductsToken(token: string, body: CardProductUpdateModel, options?: any) {
            return CardProductsApiFp(configuration).putCardproductsToken(token, body, options)(fetch, basePath);
        },
    };
};

/**
 * CardProductsApi - object-oriented interface
 * @export
 * @class CardProductsApi
 * @extends {BaseAPI}
 */
export class CardProductsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all card products
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardProductsApi
     */
    public getCardproducts(count?: number, startIndex?: number, sortBy?: string, options?: any) {
        return CardProductsApiFp(this.configuration).getCardproducts(count, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific card product
     * @param {string} token Card product token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardProductsApi
     */
    public getCardproductsToken(token: string, options?: any) {
        return CardProductsApiFp(this.configuration).getCardproductsToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a card product
     * @param {CardProductRequest} body Card product object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardProductsApi
     */
    public postCardproducts(body: CardProductRequest, options?: any) {
        return CardProductsApiFp(this.configuration).postCardproducts(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific card product
     * @param {string} token Card product token
     * @param {CardProductUpdateModel} body Card product object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardProductsApi
     */
    public putCardproductsToken(token: string, body: CardProductUpdateModel, options?: any) {
        return CardProductsApiFp(this.configuration).putCardproductsToken(token, body, options)(this.fetch, this.basePath);
    }

}

/**
 * CardTransitionsApi - fetch parameter creator
 * @export
 */
export const CardTransitionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all card transitions
         * @param {string} token Card token
         * @param {number} [count] Number of card transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardtransitionsCardToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getCardtransitionsCardToken.');
            }
            const localVarPath = `/cardtransitions/card/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a card transition object
         * @param {string} token Card transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardtransitionsToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getCardtransitionsToken.');
            }
            const localVarPath = `/cardtransitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a card transition object
         * @param {CardTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardtransitions(body?: CardTransitionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/cardtransitions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardTransitionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardTransitionsApi - functional programming interface
 * @export
 */
export const CardTransitionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all card transitions
         * @param {string} token Card token
         * @param {number} [count] Number of card transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardtransitionsCardToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardTransitionListResponse> {
            const localVarFetchArgs = CardTransitionsApiFetchParamCreator(configuration).getCardtransitionsCardToken(token, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a card transition object
         * @param {string} token Card transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardtransitionsToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardTransitionResponse> {
            const localVarFetchArgs = CardTransitionsApiFetchParamCreator(configuration).getCardtransitionsToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a card transition object
         * @param {CardTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardtransitions(body?: CardTransitionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardTransitionResponse> {
            const localVarFetchArgs = CardTransitionsApiFetchParamCreator(configuration).postCardtransitions(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CardTransitionsApi - factory interface
 * @export
 */
export const CardTransitionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all card transitions
         * @param {string} token Card token
         * @param {number} [count] Number of card transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardtransitionsCardToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return CardTransitionsApiFp(configuration).getCardtransitionsCardToken(token, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a card transition object
         * @param {string} token Card transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardtransitionsToken(token: string, fields?: string, options?: any) {
            return CardTransitionsApiFp(configuration).getCardtransitionsToken(token, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a card transition object
         * @param {CardTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardtransitions(body?: CardTransitionRequest, options?: any) {
            return CardTransitionsApiFp(configuration).postCardtransitions(body, options)(fetch, basePath);
        },
    };
};

/**
 * CardTransitionsApi - object-oriented interface
 * @export
 * @class CardTransitionsApi
 * @extends {BaseAPI}
 */
export class CardTransitionsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all card transitions
     * @param {string} token Card token
     * @param {number} [count] Number of card transitions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardTransitionsApi
     */
    public getCardtransitionsCardToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return CardTransitionsApiFp(this.configuration).getCardtransitionsCardToken(token, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a card transition object
     * @param {string} token Card transition token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardTransitionsApi
     */
    public getCardtransitionsToken(token: string, fields?: string, options?: any) {
        return CardTransitionsApiFp(this.configuration).getCardtransitionsToken(token, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a card transition object
     * @param {CardTransitionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardTransitionsApi
     */
    public postCardtransitions(body?: CardTransitionRequest, options?: any) {
        return CardTransitionsApiFp(this.configuration).postCardtransitions(body, options)(this.fetch, this.basePath);
    }

}

/**
 * CardholderBalancesApi - fetch parameter creator
 * @export
 */
export const CardholderBalancesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns account balances for a cardholder
         * @param {string} token User or Business token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getBalancesToken.');
            }
            const localVarPath = `/balances/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a merchant-specific account balance
         * @param {string} token User or Business token
         * @param {number} [count] Number of restrictions to retrieve
         * @param {number} [startIndex] Start index
         * @param {'name'} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesTokenMsas(token: string, count?: number, startIndex?: number, sortBy?: 'name', options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getBalancesTokenMsas.');
            }
            const localVarPath = `/balances/{token}/msas`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardholderBalancesApi - functional programming interface
 * @export
 */
export const CardholderBalancesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns account balances for a cardholder
         * @param {string} token User or Business token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardholderBalances> {
            const localVarFetchArgs = CardholderBalancesApiFetchParamCreator(configuration).getBalancesToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a merchant-specific account balance
         * @param {string} token User or Business token
         * @param {number} [count] Number of restrictions to retrieve
         * @param {number} [startIndex] Start index
         * @param {'name'} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesTokenMsas(token: string, count?: number, startIndex?: number, sortBy?: 'name', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardholderMsaBalance> {
            const localVarFetchArgs = CardholderBalancesApiFetchParamCreator(configuration).getBalancesTokenMsas(token, count, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CardholderBalancesApi - factory interface
 * @export
 */
export const CardholderBalancesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns account balances for a cardholder
         * @param {string} token User or Business token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesToken(token: string, options?: any) {
            return CardholderBalancesApiFp(configuration).getBalancesToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a merchant-specific account balance
         * @param {string} token User or Business token
         * @param {number} [count] Number of restrictions to retrieve
         * @param {number} [startIndex] Start index
         * @param {'name'} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesTokenMsas(token: string, count?: number, startIndex?: number, sortBy?: 'name', options?: any) {
            return CardholderBalancesApiFp(configuration).getBalancesTokenMsas(token, count, startIndex, sortBy, options)(fetch, basePath);
        },
    };
};

/**
 * CardholderBalancesApi - object-oriented interface
 * @export
 * @class CardholderBalancesApi
 * @extends {BaseAPI}
 */
export class CardholderBalancesApi extends BaseAPI {
    /**
     * 
     * @summary Returns account balances for a cardholder
     * @param {string} token User or Business token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardholderBalancesApi
     */
    public getBalancesToken(token: string, options?: any) {
        return CardholderBalancesApiFp(this.configuration).getBalancesToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a merchant-specific account balance
     * @param {string} token User or Business token
     * @param {number} [count] Number of restrictions to retrieve
     * @param {number} [startIndex] Start index
     * @param {'name'} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardholderBalancesApi
     */
    public getBalancesTokenMsas(token: string, count?: number, startIndex?: number, sortBy?: 'name', options?: any) {
        return CardholderBalancesApiFp(this.configuration).getBalancesTokenMsas(token, count, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

}

/**
 * CardsApi - fetch parameter creator
 * @export
 */
export const CardsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists cards by the last 4 digits
         * @param {string} lastFour Last four digits of card number
         * @param {number} [count] Number of cards to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCards(lastFour: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'lastFour' is not null or undefined
            if (lastFour === null || lastFour === undefined) {
                throw new RequiredError('lastFour','Required parameter lastFour was null or undefined when calling getCards.');
            }
            const localVarPath = `/cards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (lastFour !== undefined) {
                localVarQueryParameter['last_four'] = lastFour;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a card's metadata
         * @param {string} barcode Barcode
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsBarcodeBarcode(barcode: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'barcode' is not null or undefined
            if (barcode === null || barcode === undefined) {
                throw new RequiredError('barcode','Required parameter barcode was null or undefined when calling getCardsBarcodeBarcode.');
            }
            const localVarPath = `/cards/barcode/{barcode}`
                .replace(`{${"barcode"}}`, encodeURIComponent(String(barcode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific card - PAN visible
         * @param {string} cardHash Card Hash
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {boolean} [showCvvNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsCardHashShowpan(cardHash: string, fields?: string, showCvvNumber?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'cardHash' is not null or undefined
            if (cardHash === null || cardHash === undefined) {
                throw new RequiredError('cardHash','Required parameter cardHash was null or undefined when calling getCardsCardHashShowpan.');
            }
            const localVarPath = `/cards/{card_hash}/showpanbyhash`
                .replace(`{${"card_hash"}}`, encodeURIComponent(String(cardHash)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (showCvvNumber !== undefined) {
                localVarQueryParameter['show_cvv_number'] = showCvvNumber;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a merchant onboarding card
         * @param {string} merchantToken Merchant token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsMerchantMerchanttoken(merchantToken: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'merchantToken' is not null or undefined
            if (merchantToken === null || merchantToken === undefined) {
                throw new RequiredError('merchantToken','Required parameter merchantToken was null or undefined when calling getCardsMerchantMerchanttoken.');
            }
            const localVarPath = `/cards/merchant/{merchant_token}`
                .replace(`{${"merchant_token"}}`, encodeURIComponent(String(merchantToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific card - PAN visible
         * @param {string} merchantToken Merchant token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {boolean} [showCvvNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsMerchantMerchanttokenShowpan(merchantToken: string, fields?: string, showCvvNumber?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'merchantToken' is not null or undefined
            if (merchantToken === null || merchantToken === undefined) {
                throw new RequiredError('merchantToken','Required parameter merchantToken was null or undefined when calling getCardsMerchantMerchanttokenShowpan.');
            }
            const localVarPath = `/cards/merchant/{merchant_token}/showpan`
                .replace(`{${"merchant_token"}}`, encodeURIComponent(String(merchantToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (showCvvNumber !== undefined) {
                localVarQueryParameter['show_cvv_number'] = showCvvNumber;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific card
         * @param {string} token Card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [expand] Object to expand
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsToken(token: string, fields?: string, expand?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getCardsToken.');
            }
            const localVarPath = `/cards/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific card - PAN visible
         * @param {string} token Card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {boolean} [showCvvNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsTokenShowpan(token: string, fields?: string, showCvvNumber?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getCardsTokenShowpan.');
            }
            const localVarPath = `/cards/{token}/showpan`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (showCvvNumber !== undefined) {
                localVarQueryParameter['show_cvv_number'] = showCvvNumber;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all cards for a specific user
         * @param {string} token User token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsUserToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getCardsUserToken.');
            }
            const localVarPath = `/cards/user/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a card
         * @param {CardRequest} [body] 
         * @param {boolean} [showCvvNumber] Show CVV
         * @param {boolean} [showPan] Show PAN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCards(body?: CardRequest, showCvvNumber?: boolean, showPan?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/cards`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (showCvvNumber !== undefined) {
                localVarQueryParameter['show_cvv_number'] = showCvvNumber;
            }

            if (showPan !== undefined) {
                localVarQueryParameter['show_pan'] = showPan;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns user and card tokens for the specified PAN
         * @param {PanRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardsGetbypan(body?: PanRequest, options: any = {}): FetchArgs {
            const localVarPath = `/cards/getbypan`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PanRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a merchant onboarding card
         * @param {string} merchantToken Merchant token
         * @param {MerchantCardRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardsMerchantMerchanttoken(merchantToken: string, body?: MerchantCardRequest, options: any = {}): FetchArgs {
            // verify required parameter 'merchantToken' is not null or undefined
            if (merchantToken === null || merchantToken === undefined) {
                throw new RequiredError('merchantToken','Required parameter merchantToken was null or undefined when calling postCardsMerchantMerchanttoken.');
            }
            const localVarPath = `/cards/merchant/{merchant_token}`
                .replace(`{${"merchant_token"}}`, encodeURIComponent(String(merchantToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MerchantCardRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific card
         * @param {string} token Card token
         * @param {CardUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCardsToken(token: string, body?: CardUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putCardsToken.');
            }
            const localVarPath = `/cards/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardsApi - functional programming interface
 * @export
 */
export const CardsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists cards by the last 4 digits
         * @param {string} lastFour Last four digits of card number
         * @param {number} [count] Number of cards to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCards(lastFour: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardListResponse> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).getCards(lastFour, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a card's metadata
         * @param {string} barcode Barcode
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsBarcodeBarcode(barcode: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardResponse> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).getCardsBarcodeBarcode(barcode, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific card - PAN visible
         * @param {string} cardHash Card Hash
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {boolean} [showCvvNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsCardHashShowpan(cardHash: string, fields?: string, showCvvNumber?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardResponse> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).getCardsCardHashShowpan(cardHash, fields, showCvvNumber, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a merchant onboarding card
         * @param {string} merchantToken Merchant token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsMerchantMerchanttoken(merchantToken: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardResponse> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).getCardsMerchantMerchanttoken(merchantToken, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific card - PAN visible
         * @param {string} merchantToken Merchant token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {boolean} [showCvvNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsMerchantMerchanttokenShowpan(merchantToken: string, fields?: string, showCvvNumber?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardResponse> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).getCardsMerchantMerchanttokenShowpan(merchantToken, fields, showCvvNumber, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific card
         * @param {string} token Card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [expand] Object to expand
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsToken(token: string, fields?: string, expand?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardResponse> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).getCardsToken(token, fields, expand, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific card - PAN visible
         * @param {string} token Card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {boolean} [showCvvNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsTokenShowpan(token: string, fields?: string, showCvvNumber?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardResponse> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).getCardsTokenShowpan(token, fields, showCvvNumber, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all cards for a specific user
         * @param {string} token User token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsUserToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardListResponse> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).getCardsUserToken(token, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a card
         * @param {CardRequest} [body] 
         * @param {boolean} [showCvvNumber] Show CVV
         * @param {boolean} [showPan] Show PAN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCards(body?: CardRequest, showCvvNumber?: boolean, showPan?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardResponse> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).postCards(body, showCvvNumber, showPan, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns user and card tokens for the specified PAN
         * @param {PanRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardsGetbypan(body?: PanRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PanResponse> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).postCardsGetbypan(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a merchant onboarding card
         * @param {string} merchantToken Merchant token
         * @param {MerchantCardRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardsMerchantMerchanttoken(merchantToken: string, body?: MerchantCardRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardResponse> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).postCardsMerchantMerchanttoken(merchantToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific card
         * @param {string} token Card token
         * @param {CardUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCardsToken(token: string, body?: CardUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardResponse> {
            const localVarFetchArgs = CardsApiFetchParamCreator(configuration).putCardsToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CardsApi - factory interface
 * @export
 */
export const CardsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists cards by the last 4 digits
         * @param {string} lastFour Last four digits of card number
         * @param {number} [count] Number of cards to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCards(lastFour: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return CardsApiFp(configuration).getCards(lastFour, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a card's metadata
         * @param {string} barcode Barcode
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsBarcodeBarcode(barcode: string, fields?: string, options?: any) {
            return CardsApiFp(configuration).getCardsBarcodeBarcode(barcode, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific card - PAN visible
         * @param {string} cardHash Card Hash
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {boolean} [showCvvNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsCardHashShowpan(cardHash: string, fields?: string, showCvvNumber?: boolean, options?: any) {
            return CardsApiFp(configuration).getCardsCardHashShowpan(cardHash, fields, showCvvNumber, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a merchant onboarding card
         * @param {string} merchantToken Merchant token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsMerchantMerchanttoken(merchantToken: string, fields?: string, options?: any) {
            return CardsApiFp(configuration).getCardsMerchantMerchanttoken(merchantToken, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific card - PAN visible
         * @param {string} merchantToken Merchant token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {boolean} [showCvvNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsMerchantMerchanttokenShowpan(merchantToken: string, fields?: string, showCvvNumber?: boolean, options?: any) {
            return CardsApiFp(configuration).getCardsMerchantMerchanttokenShowpan(merchantToken, fields, showCvvNumber, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific card
         * @param {string} token Card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [expand] Object to expand
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsToken(token: string, fields?: string, expand?: string, options?: any) {
            return CardsApiFp(configuration).getCardsToken(token, fields, expand, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific card - PAN visible
         * @param {string} token Card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {boolean} [showCvvNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsTokenShowpan(token: string, fields?: string, showCvvNumber?: boolean, options?: any) {
            return CardsApiFp(configuration).getCardsTokenShowpan(token, fields, showCvvNumber, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all cards for a specific user
         * @param {string} token User token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsUserToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return CardsApiFp(configuration).getCardsUserToken(token, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a card
         * @param {CardRequest} [body] 
         * @param {boolean} [showCvvNumber] Show CVV
         * @param {boolean} [showPan] Show PAN
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCards(body?: CardRequest, showCvvNumber?: boolean, showPan?: boolean, options?: any) {
            return CardsApiFp(configuration).postCards(body, showCvvNumber, showPan, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns user and card tokens for the specified PAN
         * @param {PanRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardsGetbypan(body?: PanRequest, options?: any) {
            return CardsApiFp(configuration).postCardsGetbypan(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a merchant onboarding card
         * @param {string} merchantToken Merchant token
         * @param {MerchantCardRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardsMerchantMerchanttoken(merchantToken: string, body?: MerchantCardRequest, options?: any) {
            return CardsApiFp(configuration).postCardsMerchantMerchanttoken(merchantToken, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific card
         * @param {string} token Card token
         * @param {CardUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCardsToken(token: string, body?: CardUpdateRequest, options?: any) {
            return CardsApiFp(configuration).putCardsToken(token, body, options)(fetch, basePath);
        },
    };
};

/**
 * CardsApi - object-oriented interface
 * @export
 * @class CardsApi
 * @extends {BaseAPI}
 */
export class CardsApi extends BaseAPI {
    /**
     * 
     * @summary Lists cards by the last 4 digits
     * @param {string} lastFour Last four digits of card number
     * @param {number} [count] Number of cards to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public getCards(lastFour: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return CardsApiFp(this.configuration).getCards(lastFour, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a card's metadata
     * @param {string} barcode Barcode
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public getCardsBarcodeBarcode(barcode: string, fields?: string, options?: any) {
        return CardsApiFp(this.configuration).getCardsBarcodeBarcode(barcode, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific card - PAN visible
     * @param {string} cardHash Card Hash
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {boolean} [showCvvNumber] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public getCardsCardHashShowpan(cardHash: string, fields?: string, showCvvNumber?: boolean, options?: any) {
        return CardsApiFp(this.configuration).getCardsCardHashShowpan(cardHash, fields, showCvvNumber, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a merchant onboarding card
     * @param {string} merchantToken Merchant token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public getCardsMerchantMerchanttoken(merchantToken: string, fields?: string, options?: any) {
        return CardsApiFp(this.configuration).getCardsMerchantMerchanttoken(merchantToken, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific card - PAN visible
     * @param {string} merchantToken Merchant token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {boolean} [showCvvNumber] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public getCardsMerchantMerchanttokenShowpan(merchantToken: string, fields?: string, showCvvNumber?: boolean, options?: any) {
        return CardsApiFp(this.configuration).getCardsMerchantMerchanttokenShowpan(merchantToken, fields, showCvvNumber, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific card
     * @param {string} token Card token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [expand] Object to expand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public getCardsToken(token: string, fields?: string, expand?: string, options?: any) {
        return CardsApiFp(this.configuration).getCardsToken(token, fields, expand, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific card - PAN visible
     * @param {string} token Card token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {boolean} [showCvvNumber] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public getCardsTokenShowpan(token: string, fields?: string, showCvvNumber?: boolean, options?: any) {
        return CardsApiFp(this.configuration).getCardsTokenShowpan(token, fields, showCvvNumber, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all cards for a specific user
     * @param {string} token User token
     * @param {number} [count] Number of items to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public getCardsUserToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return CardsApiFp(this.configuration).getCardsUserToken(token, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a card
     * @param {CardRequest} [body] 
     * @param {boolean} [showCvvNumber] Show CVV
     * @param {boolean} [showPan] Show PAN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public postCards(body?: CardRequest, showCvvNumber?: boolean, showPan?: boolean, options?: any) {
        return CardsApiFp(this.configuration).postCards(body, showCvvNumber, showPan, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns user and card tokens for the specified PAN
     * @param {PanRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public postCardsGetbypan(body?: PanRequest, options?: any) {
        return CardsApiFp(this.configuration).postCardsGetbypan(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a merchant onboarding card
     * @param {string} merchantToken Merchant token
     * @param {MerchantCardRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public postCardsMerchantMerchanttoken(merchantToken: string, body?: MerchantCardRequest, options?: any) {
        return CardsApiFp(this.configuration).postCardsMerchantMerchanttoken(merchantToken, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific card
     * @param {string} token Card token
     * @param {CardUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardsApi
     */
    public putCardsToken(token: string, body?: CardUpdateRequest, options?: any) {
        return CardsApiFp(this.configuration).putCardsToken(token, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ChargebacksApi - fetch parameter creator
 * @export
 */
export const ChargebacksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all chargebacks
         * @param {number} [count] Number of chargebacks to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [networkReferenceId] Network reference ID
         * @param {string} [transactionToken] Transaction token
         * @param {string} [amount] Amount
         * @param {string} [states] Comma-delimited list of chargeback states to display e.g. INITIATED | REPRESENTMENT | PREARBITRATION | ARBITRATION | CASE_WON | CASE_LOST | NETWORK_REJECTED | WITHDRAWN | WRITTEN_OFF_ISSUER | WRITTEN_OFF_PROGRAM
         * @param {string} [sortBy] Sort order
         * @param {string} [networkCaseId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacks(count?: number, startIndex?: number, networkReferenceId?: string, transactionToken?: string, amount?: string, states?: string, sortBy?: string, networkCaseId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/chargebacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (networkReferenceId !== undefined) {
                localVarQueryParameter['network_reference_id'] = networkReferenceId;
            }

            if (transactionToken !== undefined) {
                localVarQueryParameter['transaction_token'] = transactionToken;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (states !== undefined) {
                localVarQueryParameter['states'] = states;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (networkCaseId !== undefined) {
                localVarQueryParameter['network_case_id'] = networkCaseId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all chargeback transitions that are related to a chargeback
         * @param {string} chargebackToken Chargeback token
         * @param {number} [count] Number of transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksChargebacktokenTransitions(chargebackToken: string, count?: number, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'chargebackToken' is not null or undefined
            if (chargebackToken === null || chargebackToken === undefined) {
                throw new RequiredError('chargebackToken','Required parameter chargebackToken was null or undefined when calling getChargebacksChargebacktokenTransitions.');
            }
            const localVarPath = `/chargebacks/{chargeback_token}/transitions`
                .replace(`{${"chargeback_token"}}`, encodeURIComponent(String(chargebackToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific chargeback
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getChargebacksToken.');
            }
            const localVarPath = `/chargebacks/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific chargeback transition
         * @param {string} token Chargeback transition token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksTransitionsToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getChargebacksTransitionsToken.');
            }
            const localVarPath = `/chargebacks/transitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a chargeback allocation acknowledgement
         * @param {ChargebackAllocationAckRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebackAllocationAcknowledgment(body?: ChargebackAllocationAckRequest, options: any = {}): FetchArgs {
            const localVarPath = `/chargebacks/allocationacknowledgement`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChargebackAllocationAckRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a chargeback
         * @param {ChargebackRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebacks(body?: ChargebackRequest, options: any = {}): FetchArgs {
            const localVarPath = `/chargebacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChargebackRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a chargeback transition
         * @param {ChargebackTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebacksTransitions(body?: ChargebackTransitionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/chargebacks/transitions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChargebackTransitionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates chargeback data
         * @param {string} token 
         * @param {ChargebackUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksToken(token: string, body?: ChargebackUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putChargebacksToken.');
            }
            const localVarPath = `/chargebacks/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChargebackUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grants provisional credit
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksTokenGrantprovisionalcredit(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putChargebacksTokenGrantprovisionalcredit.');
            }
            const localVarPath = `/chargebacks/{token}/grantprovisionalcredit`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reverses provisional credit
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksTokenReverseprovisionalcredit(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putChargebacksTokenReverseprovisionalcredit.');
            }
            const localVarPath = `/chargebacks/{token}/reverseprovisionalcredit`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChargebacksApi - functional programming interface
 * @export
 */
export const ChargebacksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all chargebacks
         * @param {number} [count] Number of chargebacks to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [networkReferenceId] Network reference ID
         * @param {string} [transactionToken] Transaction token
         * @param {string} [amount] Amount
         * @param {string} [states] Comma-delimited list of chargeback states to display e.g. INITIATED | REPRESENTMENT | PREARBITRATION | ARBITRATION | CASE_WON | CASE_LOST | NETWORK_REJECTED | WITHDRAWN | WRITTEN_OFF_ISSUER | WRITTEN_OFF_PROGRAM
         * @param {string} [sortBy] Sort order
         * @param {string} [networkCaseId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacks(count?: number, startIndex?: number, networkReferenceId?: string, transactionToken?: string, amount?: string, states?: string, sortBy?: string, networkCaseId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackListResponse> {
            const localVarFetchArgs = ChargebacksApiFetchParamCreator(configuration).getChargebacks(count, startIndex, networkReferenceId, transactionToken, amount, states, sortBy, networkCaseId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all chargeback transitions that are related to a chargeback
         * @param {string} chargebackToken Chargeback token
         * @param {number} [count] Number of transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksChargebacktokenTransitions(chargebackToken: string, count?: number, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackTransitionListResponse> {
            const localVarFetchArgs = ChargebacksApiFetchParamCreator(configuration).getChargebacksChargebacktokenTransitions(chargebackToken, count, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific chargeback
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackResponse> {
            const localVarFetchArgs = ChargebacksApiFetchParamCreator(configuration).getChargebacksToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific chargeback transition
         * @param {string} token Chargeback transition token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksTransitionsToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackTransitionResponse> {
            const localVarFetchArgs = ChargebacksApiFetchParamCreator(configuration).getChargebacksTransitionsToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a chargeback allocation acknowledgement
         * @param {ChargebackAllocationAckRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebackAllocationAcknowledgment(body?: ChargebackAllocationAckRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackResponse> {
            const localVarFetchArgs = ChargebacksApiFetchParamCreator(configuration).postChargebackAllocationAcknowledgment(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a chargeback
         * @param {ChargebackRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebacks(body?: ChargebackRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackResponse> {
            const localVarFetchArgs = ChargebacksApiFetchParamCreator(configuration).postChargebacks(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a chargeback transition
         * @param {ChargebackTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebacksTransitions(body?: ChargebackTransitionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackTransitionResponse> {
            const localVarFetchArgs = ChargebacksApiFetchParamCreator(configuration).postChargebacksTransitions(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates chargeback data
         * @param {string} token 
         * @param {ChargebackUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksToken(token: string, body?: ChargebackUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackResponse> {
            const localVarFetchArgs = ChargebacksApiFetchParamCreator(configuration).putChargebacksToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Grants provisional credit
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksTokenGrantprovisionalcredit(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackResponse> {
            const localVarFetchArgs = ChargebacksApiFetchParamCreator(configuration).putChargebacksTokenGrantprovisionalcredit(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Reverses provisional credit
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksTokenReverseprovisionalcredit(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChargebackResponse> {
            const localVarFetchArgs = ChargebacksApiFetchParamCreator(configuration).putChargebacksTokenReverseprovisionalcredit(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChargebacksApi - factory interface
 * @export
 */
export const ChargebacksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary List all chargebacks
         * @param {number} [count] Number of chargebacks to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [networkReferenceId] Network reference ID
         * @param {string} [transactionToken] Transaction token
         * @param {string} [amount] Amount
         * @param {string} [states] Comma-delimited list of chargeback states to display e.g. INITIATED | REPRESENTMENT | PREARBITRATION | ARBITRATION | CASE_WON | CASE_LOST | NETWORK_REJECTED | WITHDRAWN | WRITTEN_OFF_ISSUER | WRITTEN_OFF_PROGRAM
         * @param {string} [sortBy] Sort order
         * @param {string} [networkCaseId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacks(count?: number, startIndex?: number, networkReferenceId?: string, transactionToken?: string, amount?: string, states?: string, sortBy?: string, networkCaseId?: string, options?: any) {
            return ChargebacksApiFp(configuration).getChargebacks(count, startIndex, networkReferenceId, transactionToken, amount, states, sortBy, networkCaseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all chargeback transitions that are related to a chargeback
         * @param {string} chargebackToken Chargeback token
         * @param {number} [count] Number of transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksChargebacktokenTransitions(chargebackToken: string, count?: number, startIndex?: number, sortBy?: string, options?: any) {
            return ChargebacksApiFp(configuration).getChargebacksChargebacktokenTransitions(chargebackToken, count, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific chargeback
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksToken(token: string, options?: any) {
            return ChargebacksApiFp(configuration).getChargebacksToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific chargeback transition
         * @param {string} token Chargeback transition token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksTransitionsToken(token: string, options?: any) {
            return ChargebacksApiFp(configuration).getChargebacksTransitionsToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a chargeback allocation acknowledgement
         * @param {ChargebackAllocationAckRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebackAllocationAcknowledgment(body?: ChargebackAllocationAckRequest, options?: any) {
            return ChargebacksApiFp(configuration).postChargebackAllocationAcknowledgment(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a chargeback
         * @param {ChargebackRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebacks(body?: ChargebackRequest, options?: any) {
            return ChargebacksApiFp(configuration).postChargebacks(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a chargeback transition
         * @param {ChargebackTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebacksTransitions(body?: ChargebackTransitionRequest, options?: any) {
            return ChargebacksApiFp(configuration).postChargebacksTransitions(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates chargeback data
         * @param {string} token 
         * @param {ChargebackUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksToken(token: string, body?: ChargebackUpdateRequest, options?: any) {
            return ChargebacksApiFp(configuration).putChargebacksToken(token, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Grants provisional credit
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksTokenGrantprovisionalcredit(token: string, options?: any) {
            return ChargebacksApiFp(configuration).putChargebacksTokenGrantprovisionalcredit(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reverses provisional credit
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksTokenReverseprovisionalcredit(token: string, options?: any) {
            return ChargebacksApiFp(configuration).putChargebacksTokenReverseprovisionalcredit(token, options)(fetch, basePath);
        },
    };
};

/**
 * ChargebacksApi - object-oriented interface
 * @export
 * @class ChargebacksApi
 * @extends {BaseAPI}
 */
export class ChargebacksApi extends BaseAPI {
    /**
     * 
     * @summary List all chargebacks
     * @param {number} [count] Number of chargebacks to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [networkReferenceId] Network reference ID
     * @param {string} [transactionToken] Transaction token
     * @param {string} [amount] Amount
     * @param {string} [states] Comma-delimited list of chargeback states to display e.g. INITIATED | REPRESENTMENT | PREARBITRATION | ARBITRATION | CASE_WON | CASE_LOST | NETWORK_REJECTED | WITHDRAWN | WRITTEN_OFF_ISSUER | WRITTEN_OFF_PROGRAM
     * @param {string} [sortBy] Sort order
     * @param {string} [networkCaseId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public getChargebacks(count?: number, startIndex?: number, networkReferenceId?: string, transactionToken?: string, amount?: string, states?: string, sortBy?: string, networkCaseId?: string, options?: any) {
        return ChargebacksApiFp(this.configuration).getChargebacks(count, startIndex, networkReferenceId, transactionToken, amount, states, sortBy, networkCaseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all chargeback transitions that are related to a chargeback
     * @param {string} chargebackToken Chargeback token
     * @param {number} [count] Number of transitions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public getChargebacksChargebacktokenTransitions(chargebackToken: string, count?: number, startIndex?: number, sortBy?: string, options?: any) {
        return ChargebacksApiFp(this.configuration).getChargebacksChargebacktokenTransitions(chargebackToken, count, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific chargeback
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public getChargebacksToken(token: string, options?: any) {
        return ChargebacksApiFp(this.configuration).getChargebacksToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific chargeback transition
     * @param {string} token Chargeback transition token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public getChargebacksTransitionsToken(token: string, options?: any) {
        return ChargebacksApiFp(this.configuration).getChargebacksTransitionsToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a chargeback allocation acknowledgement
     * @param {ChargebackAllocationAckRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public postChargebackAllocationAcknowledgment(body?: ChargebackAllocationAckRequest, options?: any) {
        return ChargebacksApiFp(this.configuration).postChargebackAllocationAcknowledgment(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a chargeback
     * @param {ChargebackRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public postChargebacks(body?: ChargebackRequest, options?: any) {
        return ChargebacksApiFp(this.configuration).postChargebacks(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a chargeback transition
     * @param {ChargebackTransitionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public postChargebacksTransitions(body?: ChargebackTransitionRequest, options?: any) {
        return ChargebacksApiFp(this.configuration).postChargebacksTransitions(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates chargeback data
     * @param {string} token 
     * @param {ChargebackUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public putChargebacksToken(token: string, body?: ChargebackUpdateRequest, options?: any) {
        return ChargebacksApiFp(this.configuration).putChargebacksToken(token, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Grants provisional credit
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public putChargebacksTokenGrantprovisionalcredit(token: string, options?: any) {
        return ChargebacksApiFp(this.configuration).putChargebacksTokenGrantprovisionalcredit(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Reverses provisional credit
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargebacksApi
     */
    public putChargebacksTokenReverseprovisionalcredit(token: string, options?: any) {
        return ChargebacksApiFp(this.configuration).putChargebacksTokenReverseprovisionalcredit(token, options)(this.fetch, this.basePath);
    }

}

/**
 * CommandoModesApi - fetch parameter creator
 * @export
 */
export const CommandoModesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all commando mode control sets
         * @param {number} [count] Number of commando modes to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodes(count?: number, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/commandomodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all commando mode transitions related to a commando mode control set
         * @param {string} commandomodeToken Commando mode token
         * @param {number} [count] Number of transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesCommandomodetokenTransitions(commandomodeToken: string, count?: number, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'commandomodeToken' is not null or undefined
            if (commandomodeToken === null || commandomodeToken === undefined) {
                throw new RequiredError('commandomodeToken','Required parameter commandomodeToken was null or undefined when calling getCommandomodesCommandomodetokenTransitions.');
            }
            const localVarPath = `/commandomodes/{commandomode_token}/transitions`
                .replace(`{${"commandomode_token"}}`, encodeURIComponent(String(commandomodeToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific commando mode control set
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getCommandomodesToken.');
            }
            const localVarPath = `/commandomodes/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific commando mode transition
         * @param {string} token Commando mode transition token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesTransitionsToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getCommandomodesTransitionsToken.');
            }
            const localVarPath = `/commandomodes/transitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandoModesApi - functional programming interface
 * @export
 */
export const CommandoModesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all commando mode control sets
         * @param {number} [count] Number of commando modes to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodes(count?: number, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommandoModeListResponse> {
            const localVarFetchArgs = CommandoModesApiFetchParamCreator(configuration).getCommandomodes(count, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all commando mode transitions related to a commando mode control set
         * @param {string} commandomodeToken Commando mode token
         * @param {number} [count] Number of transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesCommandomodetokenTransitions(commandomodeToken: string, count?: number, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommandoModeTransitionListResponse> {
            const localVarFetchArgs = CommandoModesApiFetchParamCreator(configuration).getCommandomodesCommandomodetokenTransitions(commandomodeToken, count, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific commando mode control set
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommandoModeResponse> {
            const localVarFetchArgs = CommandoModesApiFetchParamCreator(configuration).getCommandomodesToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific commando mode transition
         * @param {string} token Commando mode transition token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesTransitionsToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommandoModeTransitionResponse> {
            const localVarFetchArgs = CommandoModesApiFetchParamCreator(configuration).getCommandomodesTransitionsToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CommandoModesApi - factory interface
 * @export
 */
export const CommandoModesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all commando mode control sets
         * @param {number} [count] Number of commando modes to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodes(count?: number, startIndex?: number, sortBy?: string, options?: any) {
            return CommandoModesApiFp(configuration).getCommandomodes(count, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all commando mode transitions related to a commando mode control set
         * @param {string} commandomodeToken Commando mode token
         * @param {number} [count] Number of transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesCommandomodetokenTransitions(commandomodeToken: string, count?: number, startIndex?: number, sortBy?: string, options?: any) {
            return CommandoModesApiFp(configuration).getCommandomodesCommandomodetokenTransitions(commandomodeToken, count, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific commando mode control set
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesToken(token: string, options?: any) {
            return CommandoModesApiFp(configuration).getCommandomodesToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific commando mode transition
         * @param {string} token Commando mode transition token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesTransitionsToken(token: string, options?: any) {
            return CommandoModesApiFp(configuration).getCommandomodesTransitionsToken(token, options)(fetch, basePath);
        },
    };
};

/**
 * CommandoModesApi - object-oriented interface
 * @export
 * @class CommandoModesApi
 * @extends {BaseAPI}
 */
export class CommandoModesApi extends BaseAPI {
    /**
     * 
     * @summary Lists all commando mode control sets
     * @param {number} [count] Number of commando modes to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandoModesApi
     */
    public getCommandomodes(count?: number, startIndex?: number, sortBy?: string, options?: any) {
        return CommandoModesApiFp(this.configuration).getCommandomodes(count, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all commando mode transitions related to a commando mode control set
     * @param {string} commandomodeToken Commando mode token
     * @param {number} [count] Number of transitions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandoModesApi
     */
    public getCommandomodesCommandomodetokenTransitions(commandomodeToken: string, count?: number, startIndex?: number, sortBy?: string, options?: any) {
        return CommandoModesApiFp(this.configuration).getCommandomodesCommandomodetokenTransitions(commandomodeToken, count, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific commando mode control set
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandoModesApi
     */
    public getCommandomodesToken(token: string, options?: any) {
        return CommandoModesApiFp(this.configuration).getCommandomodesToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific commando mode transition
     * @param {string} token Commando mode transition token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandoModesApi
     */
    public getCommandomodesTransitionsToken(token: string, options?: any) {
        return CommandoModesApiFp(this.configuration).getCommandomodesTransitionsToken(token, options)(this.fetch, this.basePath);
    }

}

/**
 * DigitalWalletProvisionRequestsApi - fetch parameter creator
 * @export
 */
export const DigitalWalletProvisionRequestsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Validates and creates Android-specific provisioning request data
         * @param {DigitalWalletAndroidPayProvisionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsAndroidpay(body?: DigitalWalletAndroidPayProvisionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/digitalwalletprovisionrequests/androidpay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DigitalWalletAndroidPayProvisionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validates Apple certificates and creates Apple-specific provisioning request data
         * @param {DigitalWalletApplePayProvisionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsApplepay(body?: DigitalWalletApplePayProvisionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/digitalwalletprovisionrequests/applepay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DigitalWalletApplePayProvisionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validates and creates Samsung-specific provisioning request data
         * @param {DigitalWalletSamsungPayProvisionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsSamsungpay(body?: DigitalWalletSamsungPayProvisionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/digitalwalletprovisionrequests/samsungpay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DigitalWalletSamsungPayProvisionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validates and creates a generic push provisioning request data for adding a card to a digital wallet that is not ApplePay, GooglePay or SamsungPay.
         * @param {DigitalWalletXPayProvisionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsXPay(body?: DigitalWalletXPayProvisionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/digitalwalletprovisionrequests/xpay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DigitalWalletXPayProvisionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DigitalWalletProvisionRequestsApi - functional programming interface
 * @export
 */
export const DigitalWalletProvisionRequestsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Validates and creates Android-specific provisioning request data
         * @param {DigitalWalletAndroidPayProvisionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsAndroidpay(body?: DigitalWalletAndroidPayProvisionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DigitalWalletAndroidPayProvisionResponse> {
            const localVarFetchArgs = DigitalWalletProvisionRequestsApiFetchParamCreator(configuration).postDigitalwalletprovisionrequestsAndroidpay(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Validates Apple certificates and creates Apple-specific provisioning request data
         * @param {DigitalWalletApplePayProvisionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsApplepay(body?: DigitalWalletApplePayProvisionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DigitalWalletApplePayProvisionResponse> {
            const localVarFetchArgs = DigitalWalletProvisionRequestsApiFetchParamCreator(configuration).postDigitalwalletprovisionrequestsApplepay(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Validates and creates Samsung-specific provisioning request data
         * @param {DigitalWalletSamsungPayProvisionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsSamsungpay(body?: DigitalWalletSamsungPayProvisionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DigitalWalletSamsungPayProvisionResponse> {
            const localVarFetchArgs = DigitalWalletProvisionRequestsApiFetchParamCreator(configuration).postDigitalwalletprovisionrequestsSamsungpay(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Validates and creates a generic push provisioning request data for adding a card to a digital wallet that is not ApplePay, GooglePay or SamsungPay.
         * @param {DigitalWalletXPayProvisionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsXPay(body?: DigitalWalletXPayProvisionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DigitalWalletXPayProvisionResponse> {
            const localVarFetchArgs = DigitalWalletProvisionRequestsApiFetchParamCreator(configuration).postDigitalwalletprovisionrequestsXPay(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DigitalWalletProvisionRequestsApi - factory interface
 * @export
 */
export const DigitalWalletProvisionRequestsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Validates and creates Android-specific provisioning request data
         * @param {DigitalWalletAndroidPayProvisionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsAndroidpay(body?: DigitalWalletAndroidPayProvisionRequest, options?: any) {
            return DigitalWalletProvisionRequestsApiFp(configuration).postDigitalwalletprovisionrequestsAndroidpay(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Validates Apple certificates and creates Apple-specific provisioning request data
         * @param {DigitalWalletApplePayProvisionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsApplepay(body?: DigitalWalletApplePayProvisionRequest, options?: any) {
            return DigitalWalletProvisionRequestsApiFp(configuration).postDigitalwalletprovisionrequestsApplepay(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Validates and creates Samsung-specific provisioning request data
         * @param {DigitalWalletSamsungPayProvisionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsSamsungpay(body?: DigitalWalletSamsungPayProvisionRequest, options?: any) {
            return DigitalWalletProvisionRequestsApiFp(configuration).postDigitalwalletprovisionrequestsSamsungpay(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Validates and creates a generic push provisioning request data for adding a card to a digital wallet that is not ApplePay, GooglePay or SamsungPay.
         * @param {DigitalWalletXPayProvisionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsXPay(body?: DigitalWalletXPayProvisionRequest, options?: any) {
            return DigitalWalletProvisionRequestsApiFp(configuration).postDigitalwalletprovisionrequestsXPay(body, options)(fetch, basePath);
        },
    };
};

/**
 * DigitalWalletProvisionRequestsApi - object-oriented interface
 * @export
 * @class DigitalWalletProvisionRequestsApi
 * @extends {BaseAPI}
 */
export class DigitalWalletProvisionRequestsApi extends BaseAPI {
    /**
     * 
     * @summary Validates and creates Android-specific provisioning request data
     * @param {DigitalWalletAndroidPayProvisionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DigitalWalletProvisionRequestsApi
     */
    public postDigitalwalletprovisionrequestsAndroidpay(body?: DigitalWalletAndroidPayProvisionRequest, options?: any) {
        return DigitalWalletProvisionRequestsApiFp(this.configuration).postDigitalwalletprovisionrequestsAndroidpay(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Validates Apple certificates and creates Apple-specific provisioning request data
     * @param {DigitalWalletApplePayProvisionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DigitalWalletProvisionRequestsApi
     */
    public postDigitalwalletprovisionrequestsApplepay(body?: DigitalWalletApplePayProvisionRequest, options?: any) {
        return DigitalWalletProvisionRequestsApiFp(this.configuration).postDigitalwalletprovisionrequestsApplepay(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Validates and creates Samsung-specific provisioning request data
     * @param {DigitalWalletSamsungPayProvisionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DigitalWalletProvisionRequestsApi
     */
    public postDigitalwalletprovisionrequestsSamsungpay(body?: DigitalWalletSamsungPayProvisionRequest, options?: any) {
        return DigitalWalletProvisionRequestsApiFp(this.configuration).postDigitalwalletprovisionrequestsSamsungpay(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Validates and creates a generic push provisioning request data for adding a card to a digital wallet that is not ApplePay, GooglePay or SamsungPay.
     * @param {DigitalWalletXPayProvisionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DigitalWalletProvisionRequestsApi
     */
    public postDigitalwalletprovisionrequestsXPay(body?: DigitalWalletXPayProvisionRequest, options?: any) {
        return DigitalWalletProvisionRequestsApiFp(this.configuration).postDigitalwalletprovisionrequestsXPay(body, options)(this.fetch, this.basePath);
    }

}

/**
 * DigitalWalletTokenTransitionsApi - fetch parameter creator
 * @export
 */
export const DigitalWalletTokenTransitionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all digital wallet token transitions
         * @param {string} token Digital wallet token
         * @param {number} [count] Number of digital wallet transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokentransitionsDigitalwallettokenToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getDigitalwallettokentransitionsDigitalwallettokenToken.');
            }
            const localVarPath = `/digitalwallettokentransitions/digitalwallettoken/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a digital wallet transition object
         * @param {string} token Digital wallet transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokentransitionsToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getDigitalwallettokentransitionsToken.');
            }
            const localVarPath = `/digitalwallettokentransitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a digital wallet token transition
         * @param {DigitalWalletTokenTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwallettokentransitions(body?: DigitalWalletTokenTransitionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/digitalwallettokentransitions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DigitalWalletTokenTransitionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DigitalWalletTokenTransitionsApi - functional programming interface
 * @export
 */
export const DigitalWalletTokenTransitionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all digital wallet token transitions
         * @param {string} token Digital wallet token
         * @param {number} [count] Number of digital wallet transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokentransitionsDigitalwallettokenToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DigitalWalletTokenTransitionListResponse> {
            const localVarFetchArgs = DigitalWalletTokenTransitionsApiFetchParamCreator(configuration).getDigitalwallettokentransitionsDigitalwallettokenToken(token, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a digital wallet transition object
         * @param {string} token Digital wallet transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokentransitionsToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DigitalWalletTokenTransitionResponse> {
            const localVarFetchArgs = DigitalWalletTokenTransitionsApiFetchParamCreator(configuration).getDigitalwallettokentransitionsToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a digital wallet token transition
         * @param {DigitalWalletTokenTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwallettokentransitions(body?: DigitalWalletTokenTransitionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DigitalWalletTokenTransitionResponse> {
            const localVarFetchArgs = DigitalWalletTokenTransitionsApiFetchParamCreator(configuration).postDigitalwallettokentransitions(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DigitalWalletTokenTransitionsApi - factory interface
 * @export
 */
export const DigitalWalletTokenTransitionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all digital wallet token transitions
         * @param {string} token Digital wallet token
         * @param {number} [count] Number of digital wallet transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokentransitionsDigitalwallettokenToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return DigitalWalletTokenTransitionsApiFp(configuration).getDigitalwallettokentransitionsDigitalwallettokenToken(token, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a digital wallet transition object
         * @param {string} token Digital wallet transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokentransitionsToken(token: string, fields?: string, options?: any) {
            return DigitalWalletTokenTransitionsApiFp(configuration).getDigitalwallettokentransitionsToken(token, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a digital wallet token transition
         * @param {DigitalWalletTokenTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwallettokentransitions(body?: DigitalWalletTokenTransitionRequest, options?: any) {
            return DigitalWalletTokenTransitionsApiFp(configuration).postDigitalwallettokentransitions(body, options)(fetch, basePath);
        },
    };
};

/**
 * DigitalWalletTokenTransitionsApi - object-oriented interface
 * @export
 * @class DigitalWalletTokenTransitionsApi
 * @extends {BaseAPI}
 */
export class DigitalWalletTokenTransitionsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all digital wallet token transitions
     * @param {string} token Digital wallet token
     * @param {number} [count] Number of digital wallet transitions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DigitalWalletTokenTransitionsApi
     */
    public getDigitalwallettokentransitionsDigitalwallettokenToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return DigitalWalletTokenTransitionsApiFp(this.configuration).getDigitalwallettokentransitionsDigitalwallettokenToken(token, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a digital wallet transition object
     * @param {string} token Digital wallet transition token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DigitalWalletTokenTransitionsApi
     */
    public getDigitalwallettokentransitionsToken(token: string, fields?: string, options?: any) {
        return DigitalWalletTokenTransitionsApiFp(this.configuration).getDigitalwallettokentransitionsToken(token, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a digital wallet token transition
     * @param {DigitalWalletTokenTransitionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DigitalWalletTokenTransitionsApi
     */
    public postDigitalwallettokentransitions(body?: DigitalWalletTokenTransitionRequest, options?: any) {
        return DigitalWalletTokenTransitionsApiFp(this.configuration).postDigitalwallettokentransitions(body, options)(this.fetch, this.basePath);
    }

}

/**
 * DigitalWalletTokensApi - fetch parameter creator
 * @export
 */
export const DigitalWalletTokensApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns digital wallet tokens
         * @param {number} [count] Number of digital wallet tokens to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {string} [startDate] Start date (yyyy-MM-dd)
         * @param {string} [endDate] End date (yyyy-MM-dd)
         * @param {string} [panReferenceId] PAN reference ID
         * @param {string} [tokenReferenceId] Token reference ID
         * @param {string} [correlationId] Correlation ID
         * @param {string} [tokenType] Comma-delimited list of digital wallet token types to display e.g. DEVICE_SECURE_ELEMENT | MERCHANT_CARD_ON_FILE | DEVICE_CLOUD_BASED | ECOMMERCE_DIGITAL_WALLET | PSEUDO_ACCOUNT
         * @param {string} [tokenRequestorName] Comma-delimited list of digital wallet token wallet providers to display e.g. APPLE_PAY | ANDROID_PAY| SAMSUNG_PAY | MICROSOFT_PAY | VISA_CHECKOUT | FACEBOOK | NETFLIX | UNKNOWN
         * @param {string} [state] Comma-delimited list of digital wallet token states to display e.g. REQUESTED | REQUEST_DECLINED | TERMINATED | SUSPENDED | ACTIVE
         * @param {'user'} [embed] Embed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokens(count?: number, startIndex?: number, fields?: string, sortBy?: string, startDate?: string, endDate?: string, panReferenceId?: string, tokenReferenceId?: string, correlationId?: string, tokenType?: string, tokenRequestorName?: string, state?: string, embed?: 'user', options: any = {}): FetchArgs {
            const localVarPath = `/digitalwallettokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (panReferenceId !== undefined) {
                localVarQueryParameter['pan_reference_id'] = panReferenceId;
            }

            if (tokenReferenceId !== undefined) {
                localVarQueryParameter['token_reference_id'] = tokenReferenceId;
            }

            if (correlationId !== undefined) {
                localVarQueryParameter['correlation_id'] = correlationId;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenRequestorName !== undefined) {
                localVarQueryParameter['token_requestor_name'] = tokenRequestorName;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (embed !== undefined) {
                localVarQueryParameter['embed'] = embed;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of digital wallet tokens for the specified card
         * @param {string} cardToken Card token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensCardCardtoken(cardToken: string, count?: number, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'cardToken' is not null or undefined
            if (cardToken === null || cardToken === undefined) {
                throw new RequiredError('cardToken','Required parameter cardToken was null or undefined when calling getDigitalwallettokensCardCardtoken.');
            }
            const localVarPath = `/digitalwallettokens/card/{card_token}`
                .replace(`{${"card_token"}}`, encodeURIComponent(String(cardToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific digital wallet token
         * @param {string} token Digital wallet token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getDigitalwallettokensToken.');
            }
            const localVarPath = `/digitalwallettokens/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific digital wallet token PAN visible
         * @param {string} token Digital wallet token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensTokenShowtokenpan(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getDigitalwallettokensTokenShowtokenpan.');
            }
            const localVarPath = `/digitalwallettokens/{token}/showtokenpan`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DigitalWalletTokensApi - functional programming interface
 * @export
 */
export const DigitalWalletTokensApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns digital wallet tokens
         * @param {number} [count] Number of digital wallet tokens to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {string} [startDate] Start date (yyyy-MM-dd)
         * @param {string} [endDate] End date (yyyy-MM-dd)
         * @param {string} [panReferenceId] PAN reference ID
         * @param {string} [tokenReferenceId] Token reference ID
         * @param {string} [correlationId] Correlation ID
         * @param {string} [tokenType] Comma-delimited list of digital wallet token types to display e.g. DEVICE_SECURE_ELEMENT | MERCHANT_CARD_ON_FILE | DEVICE_CLOUD_BASED | ECOMMERCE_DIGITAL_WALLET | PSEUDO_ACCOUNT
         * @param {string} [tokenRequestorName] Comma-delimited list of digital wallet token wallet providers to display e.g. APPLE_PAY | ANDROID_PAY| SAMSUNG_PAY | MICROSOFT_PAY | VISA_CHECKOUT | FACEBOOK | NETFLIX | UNKNOWN
         * @param {string} [state] Comma-delimited list of digital wallet token states to display e.g. REQUESTED | REQUEST_DECLINED | TERMINATED | SUSPENDED | ACTIVE
         * @param {'user'} [embed] Embed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokens(count?: number, startIndex?: number, fields?: string, sortBy?: string, startDate?: string, endDate?: string, panReferenceId?: string, tokenReferenceId?: string, correlationId?: string, tokenType?: string, tokenRequestorName?: string, state?: string, embed?: 'user', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DigitalWalletTokenListResponse> {
            const localVarFetchArgs = DigitalWalletTokensApiFetchParamCreator(configuration).getDigitalwallettokens(count, startIndex, fields, sortBy, startDate, endDate, panReferenceId, tokenReferenceId, correlationId, tokenType, tokenRequestorName, state, embed, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a list of digital wallet tokens for the specified card
         * @param {string} cardToken Card token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensCardCardtoken(cardToken: string, count?: number, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DigitalWalletTokenListResponse> {
            const localVarFetchArgs = DigitalWalletTokensApiFetchParamCreator(configuration).getDigitalwallettokensCardCardtoken(cardToken, count, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific digital wallet token
         * @param {string} token Digital wallet token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DigitalWalletToken> {
            const localVarFetchArgs = DigitalWalletTokensApiFetchParamCreator(configuration).getDigitalwallettokensToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific digital wallet token PAN visible
         * @param {string} token Digital wallet token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensTokenShowtokenpan(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DigitalWalletToken> {
            const localVarFetchArgs = DigitalWalletTokensApiFetchParamCreator(configuration).getDigitalwallettokensTokenShowtokenpan(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DigitalWalletTokensApi - factory interface
 * @export
 */
export const DigitalWalletTokensApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns digital wallet tokens
         * @param {number} [count] Number of digital wallet tokens to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {string} [startDate] Start date (yyyy-MM-dd)
         * @param {string} [endDate] End date (yyyy-MM-dd)
         * @param {string} [panReferenceId] PAN reference ID
         * @param {string} [tokenReferenceId] Token reference ID
         * @param {string} [correlationId] Correlation ID
         * @param {string} [tokenType] Comma-delimited list of digital wallet token types to display e.g. DEVICE_SECURE_ELEMENT | MERCHANT_CARD_ON_FILE | DEVICE_CLOUD_BASED | ECOMMERCE_DIGITAL_WALLET | PSEUDO_ACCOUNT
         * @param {string} [tokenRequestorName] Comma-delimited list of digital wallet token wallet providers to display e.g. APPLE_PAY | ANDROID_PAY| SAMSUNG_PAY | MICROSOFT_PAY | VISA_CHECKOUT | FACEBOOK | NETFLIX | UNKNOWN
         * @param {string} [state] Comma-delimited list of digital wallet token states to display e.g. REQUESTED | REQUEST_DECLINED | TERMINATED | SUSPENDED | ACTIVE
         * @param {'user'} [embed] Embed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokens(count?: number, startIndex?: number, fields?: string, sortBy?: string, startDate?: string, endDate?: string, panReferenceId?: string, tokenReferenceId?: string, correlationId?: string, tokenType?: string, tokenRequestorName?: string, state?: string, embed?: 'user', options?: any) {
            return DigitalWalletTokensApiFp(configuration).getDigitalwallettokens(count, startIndex, fields, sortBy, startDate, endDate, panReferenceId, tokenReferenceId, correlationId, tokenType, tokenRequestorName, state, embed, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a list of digital wallet tokens for the specified card
         * @param {string} cardToken Card token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensCardCardtoken(cardToken: string, count?: number, startIndex?: number, sortBy?: string, options?: any) {
            return DigitalWalletTokensApiFp(configuration).getDigitalwallettokensCardCardtoken(cardToken, count, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific digital wallet token
         * @param {string} token Digital wallet token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensToken(token: string, options?: any) {
            return DigitalWalletTokensApiFp(configuration).getDigitalwallettokensToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific digital wallet token PAN visible
         * @param {string} token Digital wallet token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensTokenShowtokenpan(token: string, options?: any) {
            return DigitalWalletTokensApiFp(configuration).getDigitalwallettokensTokenShowtokenpan(token, options)(fetch, basePath);
        },
    };
};

/**
 * DigitalWalletTokensApi - object-oriented interface
 * @export
 * @class DigitalWalletTokensApi
 * @extends {BaseAPI}
 */
export class DigitalWalletTokensApi extends BaseAPI {
    /**
     * 
     * @summary Returns digital wallet tokens
     * @param {number} [count] Number of digital wallet tokens to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {string} [startDate] Start date (yyyy-MM-dd)
     * @param {string} [endDate] End date (yyyy-MM-dd)
     * @param {string} [panReferenceId] PAN reference ID
     * @param {string} [tokenReferenceId] Token reference ID
     * @param {string} [correlationId] Correlation ID
     * @param {string} [tokenType] Comma-delimited list of digital wallet token types to display e.g. DEVICE_SECURE_ELEMENT | MERCHANT_CARD_ON_FILE | DEVICE_CLOUD_BASED | ECOMMERCE_DIGITAL_WALLET | PSEUDO_ACCOUNT
     * @param {string} [tokenRequestorName] Comma-delimited list of digital wallet token wallet providers to display e.g. APPLE_PAY | ANDROID_PAY| SAMSUNG_PAY | MICROSOFT_PAY | VISA_CHECKOUT | FACEBOOK | NETFLIX | UNKNOWN
     * @param {string} [state] Comma-delimited list of digital wallet token states to display e.g. REQUESTED | REQUEST_DECLINED | TERMINATED | SUSPENDED | ACTIVE
     * @param {'user'} [embed] Embed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DigitalWalletTokensApi
     */
    public getDigitalwallettokens(count?: number, startIndex?: number, fields?: string, sortBy?: string, startDate?: string, endDate?: string, panReferenceId?: string, tokenReferenceId?: string, correlationId?: string, tokenType?: string, tokenRequestorName?: string, state?: string, embed?: 'user', options?: any) {
        return DigitalWalletTokensApiFp(this.configuration).getDigitalwallettokens(count, startIndex, fields, sortBy, startDate, endDate, panReferenceId, tokenReferenceId, correlationId, tokenType, tokenRequestorName, state, embed, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a list of digital wallet tokens for the specified card
     * @param {string} cardToken Card token
     * @param {number} [count] Number of items to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DigitalWalletTokensApi
     */
    public getDigitalwallettokensCardCardtoken(cardToken: string, count?: number, startIndex?: number, sortBy?: string, options?: any) {
        return DigitalWalletTokensApiFp(this.configuration).getDigitalwallettokensCardCardtoken(cardToken, count, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific digital wallet token
     * @param {string} token Digital wallet token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DigitalWalletTokensApi
     */
    public getDigitalwallettokensToken(token: string, options?: any) {
        return DigitalWalletTokensApiFp(this.configuration).getDigitalwallettokensToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific digital wallet token PAN visible
     * @param {string} token Digital wallet token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DigitalWalletTokensApi
     */
    public getDigitalwallettokensTokenShowtokenpan(token: string, options?: any) {
        return DigitalWalletTokensApiFp(this.configuration).getDigitalwallettokensTokenShowtokenpan(token, options)(this.fetch, this.basePath);
    }

}

/**
 * DirectDepositAccountsApi - fetch parameter creator
 * @export
 */
export const DirectDepositAccountsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates new direct deposit account for cardholder.
         * @param {DirectDepositAccountRequest} body Create direct deposit account for cardholder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(body: DirectDepositAccountRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAccount.');
            }
            const localVarPath = `/depositaccounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DirectDepositAccountRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new transition for a direct deposit account.
         * @param {DirectDepositAccountTransitionRequest} body Create transition for direct deposit account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransition(body: DirectDepositAccountTransitionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTransition.');
            }
            const localVarPath = `/depositaccounts/transitions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DirectDepositAccountTransitionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get direct deposit account transition list for card holder.
         * @param {string} token Get CDD info for a specific DDA token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCDDInfo(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getCDDInfo.');
            }
            const localVarPath = `/depositaccounts/{token}/cdd`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get direct deposit account.
         * @param {string} token Get specific direct deposit account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectDepositAccount(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getDirectDepositAccount.');
            }
            const localVarPath = `/depositaccounts/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get direct deposit account transition.
         * @param {string} token Get specific direct deposit account transition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectDepositAccountTransition(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getDirectDepositAccountTransition.');
            }
            const localVarPath = `/depositaccounts/transitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get direct deposit account transition list for card holder.
         * @param {string} userToken Get direct deposit account transition list for user
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransitionList(userToken: string, count?: number, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userToken' is not null or undefined
            if (userToken === null || userToken === undefined) {
                throw new RequiredError('userToken','Required parameter userToken was null or undefined when calling getTransitionList.');
            }
            const localVarPath = `/depositaccounts/{user_token}/transitions`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all specific direct deposit accounts.
         * @param {string} token Get specific direct deposit account
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {'ACTIVE' | 'SUSPENDED' | 'TERMINATED' | 'UNSUPPORTED' | 'UNACTIVATED' | 'LIMITED'} [state] Direct deposit account status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDirectDepositAccounts(token: string, count?: number, startIndex?: number, sortBy?: string, state?: 'ACTIVE' | 'SUSPENDED' | 'TERMINATED' | 'UNSUPPORTED' | 'UNACTIVATED' | 'LIMITED', options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getUserDirectDepositAccounts.');
            }
            const localVarPath = `/depositaccounts/user/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User for Plain Text Account Number
         * @param {string} accountNumber Get user associated with direct deposit account number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserForDirectDepositAccount(accountNumber: string, options: any = {}): FetchArgs {
            // verify required parameter 'accountNumber' is not null or undefined
            if (accountNumber === null || accountNumber === undefined) {
                throw new RequiredError('accountNumber','Required parameter accountNumber was null or undefined when calling getUserForDirectDepositAccount.');
            }
            const localVarPath = `/depositaccounts/account/{account_number}/user`
                .replace(`{${"account_number"}}`, encodeURIComponent(String(accountNumber)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update direct deposit account.
         * @param {DepositAccountUpdateRequest} body Update direct deposit account
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(body: DepositAccountUpdateRequest, token: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling update.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling update.');
            }
            const localVarPath = `/depositaccounts/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DepositAccountUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update CDD answers for Direct Deposit Account
         * @param {CustomerDueDiligenceUpdateRequest} body Update CDD answers
         * @param {string} token 
         * @param {string} cddtoken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCDDInfo(body: CustomerDueDiligenceUpdateRequest, token: string, cddtoken: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCDDInfo.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling updateCDDInfo.');
            }
            // verify required parameter 'cddtoken' is not null or undefined
            if (cddtoken === null || cddtoken === undefined) {
                throw new RequiredError('cddtoken','Required parameter cddtoken was null or undefined when calling updateCDDInfo.');
            }
            const localVarPath = `/depositaccounts/{token}/cdd/{cddtoken}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"cddtoken"}}`, encodeURIComponent(String(cddtoken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomerDueDiligenceUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DirectDepositAccountsApi - functional programming interface
 * @export
 */
export const DirectDepositAccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates new direct deposit account for cardholder.
         * @param {DirectDepositAccountRequest} body Create direct deposit account for cardholder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(body: DirectDepositAccountRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectDepositAccountResponse> {
            const localVarFetchArgs = DirectDepositAccountsApiFetchParamCreator(configuration).createAccount(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates new transition for a direct deposit account.
         * @param {DirectDepositAccountTransitionRequest} body Create transition for direct deposit account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransition(body: DirectDepositAccountTransitionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectDepositAccountTransitionResponse> {
            const localVarFetchArgs = DirectDepositAccountsApiFetchParamCreator(configuration).createTransition(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get direct deposit account transition list for card holder.
         * @param {string} token Get CDD info for a specific DDA token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCDDInfo(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDueDiligenceResponse> {
            const localVarFetchArgs = DirectDepositAccountsApiFetchParamCreator(configuration).getCDDInfo(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get direct deposit account.
         * @param {string} token Get specific direct deposit account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectDepositAccount(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectDepositAccountResponse> {
            const localVarFetchArgs = DirectDepositAccountsApiFetchParamCreator(configuration).getDirectDepositAccount(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get direct deposit account transition.
         * @param {string} token Get specific direct deposit account transition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectDepositAccountTransition(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectDepositAccountTransitionResponse> {
            const localVarFetchArgs = DirectDepositAccountsApiFetchParamCreator(configuration).getDirectDepositAccountTransition(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get direct deposit account transition list for card holder.
         * @param {string} userToken Get direct deposit account transition list for user
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransitionList(userToken: string, count?: number, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectDepositAccountTransitionResponse> {
            const localVarFetchArgs = DirectDepositAccountsApiFetchParamCreator(configuration).getTransitionList(userToken, count, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary List all specific direct deposit accounts.
         * @param {string} token Get specific direct deposit account
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {'ACTIVE' | 'SUSPENDED' | 'TERMINATED' | 'UNSUPPORTED' | 'UNACTIVATED' | 'LIMITED'} [state] Direct deposit account status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDirectDepositAccounts(token: string, count?: number, startIndex?: number, sortBy?: string, state?: 'ACTIVE' | 'SUSPENDED' | 'TERMINATED' | 'UNSUPPORTED' | 'UNACTIVATED' | 'LIMITED', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectDepositAccountListResponse> {
            const localVarFetchArgs = DirectDepositAccountsApiFetchParamCreator(configuration).getUserDirectDepositAccounts(token, count, startIndex, sortBy, state, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get User for Plain Text Account Number
         * @param {string} accountNumber Get user associated with direct deposit account number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserForDirectDepositAccount(accountNumber: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectDepositAccountResponse> {
            const localVarFetchArgs = DirectDepositAccountsApiFetchParamCreator(configuration).getUserForDirectDepositAccount(accountNumber, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update direct deposit account.
         * @param {DepositAccountUpdateRequest} body Update direct deposit account
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(body: DepositAccountUpdateRequest, token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectDepositAccountResponse> {
            const localVarFetchArgs = DirectDepositAccountsApiFetchParamCreator(configuration).update(body, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update CDD answers for Direct Deposit Account
         * @param {CustomerDueDiligenceUpdateRequest} body Update CDD answers
         * @param {string} token 
         * @param {string} cddtoken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCDDInfo(body: CustomerDueDiligenceUpdateRequest, token: string, cddtoken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomerDueDiligenceResponse> {
            const localVarFetchArgs = DirectDepositAccountsApiFetchParamCreator(configuration).updateCDDInfo(body, token, cddtoken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DirectDepositAccountsApi - factory interface
 * @export
 */
export const DirectDepositAccountsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates new direct deposit account for cardholder.
         * @param {DirectDepositAccountRequest} body Create direct deposit account for cardholder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(body: DirectDepositAccountRequest, options?: any) {
            return DirectDepositAccountsApiFp(configuration).createAccount(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates new transition for a direct deposit account.
         * @param {DirectDepositAccountTransitionRequest} body Create transition for direct deposit account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransition(body: DirectDepositAccountTransitionRequest, options?: any) {
            return DirectDepositAccountsApiFp(configuration).createTransition(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get direct deposit account transition list for card holder.
         * @param {string} token Get CDD info for a specific DDA token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCDDInfo(token: string, options?: any) {
            return DirectDepositAccountsApiFp(configuration).getCDDInfo(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get direct deposit account.
         * @param {string} token Get specific direct deposit account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectDepositAccount(token: string, options?: any) {
            return DirectDepositAccountsApiFp(configuration).getDirectDepositAccount(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get direct deposit account transition.
         * @param {string} token Get specific direct deposit account transition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectDepositAccountTransition(token: string, options?: any) {
            return DirectDepositAccountsApiFp(configuration).getDirectDepositAccountTransition(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get direct deposit account transition list for card holder.
         * @param {string} userToken Get direct deposit account transition list for user
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransitionList(userToken: string, count?: number, startIndex?: number, sortBy?: string, options?: any) {
            return DirectDepositAccountsApiFp(configuration).getTransitionList(userToken, count, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all specific direct deposit accounts.
         * @param {string} token Get specific direct deposit account
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {'ACTIVE' | 'SUSPENDED' | 'TERMINATED' | 'UNSUPPORTED' | 'UNACTIVATED' | 'LIMITED'} [state] Direct deposit account status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDirectDepositAccounts(token: string, count?: number, startIndex?: number, sortBy?: string, state?: 'ACTIVE' | 'SUSPENDED' | 'TERMINATED' | 'UNSUPPORTED' | 'UNACTIVATED' | 'LIMITED', options?: any) {
            return DirectDepositAccountsApiFp(configuration).getUserDirectDepositAccounts(token, count, startIndex, sortBy, state, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get User for Plain Text Account Number
         * @param {string} accountNumber Get user associated with direct deposit account number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserForDirectDepositAccount(accountNumber: string, options?: any) {
            return DirectDepositAccountsApiFp(configuration).getUserForDirectDepositAccount(accountNumber, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update direct deposit account.
         * @param {DepositAccountUpdateRequest} body Update direct deposit account
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(body: DepositAccountUpdateRequest, token: string, options?: any) {
            return DirectDepositAccountsApiFp(configuration).update(body, token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update CDD answers for Direct Deposit Account
         * @param {CustomerDueDiligenceUpdateRequest} body Update CDD answers
         * @param {string} token 
         * @param {string} cddtoken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCDDInfo(body: CustomerDueDiligenceUpdateRequest, token: string, cddtoken: string, options?: any) {
            return DirectDepositAccountsApiFp(configuration).updateCDDInfo(body, token, cddtoken, options)(fetch, basePath);
        },
    };
};

/**
 * DirectDepositAccountsApi - object-oriented interface
 * @export
 * @class DirectDepositAccountsApi
 * @extends {BaseAPI}
 */
export class DirectDepositAccountsApi extends BaseAPI {
    /**
     * 
     * @summary Creates new direct deposit account for cardholder.
     * @param {DirectDepositAccountRequest} body Create direct deposit account for cardholder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositAccountsApi
     */
    public createAccount(body: DirectDepositAccountRequest, options?: any) {
        return DirectDepositAccountsApiFp(this.configuration).createAccount(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates new transition for a direct deposit account.
     * @param {DirectDepositAccountTransitionRequest} body Create transition for direct deposit account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositAccountsApi
     */
    public createTransition(body: DirectDepositAccountTransitionRequest, options?: any) {
        return DirectDepositAccountsApiFp(this.configuration).createTransition(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get direct deposit account transition list for card holder.
     * @param {string} token Get CDD info for a specific DDA token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositAccountsApi
     */
    public getCDDInfo(token: string, options?: any) {
        return DirectDepositAccountsApiFp(this.configuration).getCDDInfo(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get direct deposit account.
     * @param {string} token Get specific direct deposit account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositAccountsApi
     */
    public getDirectDepositAccount(token: string, options?: any) {
        return DirectDepositAccountsApiFp(this.configuration).getDirectDepositAccount(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get direct deposit account transition.
     * @param {string} token Get specific direct deposit account transition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositAccountsApi
     */
    public getDirectDepositAccountTransition(token: string, options?: any) {
        return DirectDepositAccountsApiFp(this.configuration).getDirectDepositAccountTransition(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get direct deposit account transition list for card holder.
     * @param {string} userToken Get direct deposit account transition list for user
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositAccountsApi
     */
    public getTransitionList(userToken: string, count?: number, startIndex?: number, sortBy?: string, options?: any) {
        return DirectDepositAccountsApiFp(this.configuration).getTransitionList(userToken, count, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary List all specific direct deposit accounts.
     * @param {string} token Get specific direct deposit account
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {'ACTIVE' | 'SUSPENDED' | 'TERMINATED' | 'UNSUPPORTED' | 'UNACTIVATED' | 'LIMITED'} [state] Direct deposit account status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositAccountsApi
     */
    public getUserDirectDepositAccounts(token: string, count?: number, startIndex?: number, sortBy?: string, state?: 'ACTIVE' | 'SUSPENDED' | 'TERMINATED' | 'UNSUPPORTED' | 'UNACTIVATED' | 'LIMITED', options?: any) {
        return DirectDepositAccountsApiFp(this.configuration).getUserDirectDepositAccounts(token, count, startIndex, sortBy, state, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get User for Plain Text Account Number
     * @param {string} accountNumber Get user associated with direct deposit account number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositAccountsApi
     */
    public getUserForDirectDepositAccount(accountNumber: string, options?: any) {
        return DirectDepositAccountsApiFp(this.configuration).getUserForDirectDepositAccount(accountNumber, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update direct deposit account.
     * @param {DepositAccountUpdateRequest} body Update direct deposit account
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositAccountsApi
     */
    public update(body: DepositAccountUpdateRequest, token: string, options?: any) {
        return DirectDepositAccountsApiFp(this.configuration).update(body, token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update CDD answers for Direct Deposit Account
     * @param {CustomerDueDiligenceUpdateRequest} body Update CDD answers
     * @param {string} token 
     * @param {string} cddtoken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositAccountsApi
     */
    public updateCDDInfo(body: CustomerDueDiligenceUpdateRequest, token: string, cddtoken: string, options?: any) {
        return DirectDepositAccountsApiFp(this.configuration).updateCDDInfo(body, token, cddtoken, options)(this.fetch, this.basePath);
    }

}

/**
 * DirectDepositsApi - fetch parameter creator
 * @export
 */
export const DirectDepositsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all direct deposits
         * @param {number} [count] Number of direct deposits to retrieve
         * @param {number} [startIndex] Start index
         * @param {boolean} [reversedAfterGracePeriod] Reversed after grace period
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {'PENDING' | 'APPLIED' | 'REVERSED' | 'REJECTED'} [directDepositState] Direct deposit state
         * @param {string} [startSettlementDate] Start settlement date
         * @param {string} [endSettlementDate] End settlement date
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdeposits(count?: number, startIndex?: number, reversedAfterGracePeriod?: boolean, userToken?: string, businessToken?: string, directDepositState?: 'PENDING' | 'APPLIED' | 'REVERSED' | 'REJECTED', startSettlementDate?: string, endSettlementDate?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/directdeposits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (reversedAfterGracePeriod !== undefined) {
                localVarQueryParameter['reversed_after_grace_period'] = reversedAfterGracePeriod;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (directDepositState !== undefined) {
                localVarQueryParameter['direct_deposit_state'] = directDepositState;
            }

            if (startSettlementDate !== undefined) {
                localVarQueryParameter['start_settlement_date'] = startSettlementDate;
            }

            if (endSettlementDate !== undefined) {
                localVarQueryParameter['end_settlement_date'] = endSettlementDate;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns an account and routing number which can be used for direct deposit
         * @param {string} userOrBusinessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'userOrBusinessToken' is not null or undefined
            if (userOrBusinessToken === null || userOrBusinessToken === undefined) {
                throw new RequiredError('userOrBusinessToken','Required parameter userOrBusinessToken was null or undefined when calling getDirectdepositsAccountsUserorbusinesstoken.');
            }
            const localVarPath = `/directdeposits/accounts/{user_or_business_token}`
                .replace(`{${"user_or_business_token"}}`, encodeURIComponent(String(userOrBusinessToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a direct deposit entry
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getDirectdepositsToken.');
            }
            const localVarPath = `/directdeposits/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of direct deposit transitions
         * @param {number} [count] Number of direct deposit transitions to retrieve
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [directDepositToken] Direct deposit token
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [states] Comma-delimited list of direct deposit states to display e.g. PENDING | REVERSED | APPLIED | REJECTED 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsTransitions(count?: number, userToken?: string, businessToken?: string, directDepositToken?: string, startIndex?: number, sortBy?: string, states?: string, options: any = {}): FetchArgs {
            const localVarPath = `/directdeposits/transitions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (directDepositToken !== undefined) {
                localVarQueryParameter['direct_deposit_token'] = directDepositToken;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (states !== undefined) {
                localVarQueryParameter['states'] = states;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a direct deposit transition
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsTransitionsToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getDirectdepositsTransitionsToken.');
            }
            const localVarPath = `/directdeposits/transitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a direct deposit transition
         * @param {DirectDepositTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectdepositsTransitions(body?: DirectDepositTransitionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/directdeposits/transitions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DirectDepositTransitionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific direct deposit account
         * @param {string} userOrBusinessToken User or business token
         * @param {DepositAccountUpdateRequest} body Deposit account update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, body: DepositAccountUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'userOrBusinessToken' is not null or undefined
            if (userOrBusinessToken === null || userOrBusinessToken === undefined) {
                throw new RequiredError('userOrBusinessToken','Required parameter userOrBusinessToken was null or undefined when calling putDirectdepositsAccountsUserorbusinesstoken.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putDirectdepositsAccountsUserorbusinesstoken.');
            }
            const localVarPath = `/directdeposits/accounts/{user_or_business_token}`
                .replace(`{${"user_or_business_token"}}`, encodeURIComponent(String(userOrBusinessToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DepositAccountUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DirectDepositsApi - functional programming interface
 * @export
 */
export const DirectDepositsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all direct deposits
         * @param {number} [count] Number of direct deposits to retrieve
         * @param {number} [startIndex] Start index
         * @param {boolean} [reversedAfterGracePeriod] Reversed after grace period
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {'PENDING' | 'APPLIED' | 'REVERSED' | 'REJECTED'} [directDepositState] Direct deposit state
         * @param {string} [startSettlementDate] Start settlement date
         * @param {string} [endSettlementDate] End settlement date
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdeposits(count?: number, startIndex?: number, reversedAfterGracePeriod?: boolean, userToken?: string, businessToken?: string, directDepositState?: 'PENDING' | 'APPLIED' | 'REVERSED' | 'REJECTED', startSettlementDate?: string, endSettlementDate?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectDepositListResponse> {
            const localVarFetchArgs = DirectDepositsApiFetchParamCreator(configuration).getDirectdeposits(count, startIndex, reversedAfterGracePeriod, userToken, businessToken, directDepositState, startSettlementDate, endSettlementDate, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns an account and routing number which can be used for direct deposit
         * @param {string} userOrBusinessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DepositAccountResponse> {
            const localVarFetchArgs = DirectDepositsApiFetchParamCreator(configuration).getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a direct deposit entry
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DepositDepositResponse> {
            const localVarFetchArgs = DirectDepositsApiFetchParamCreator(configuration).getDirectdepositsToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a list of direct deposit transitions
         * @param {number} [count] Number of direct deposit transitions to retrieve
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [directDepositToken] Direct deposit token
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [states] Comma-delimited list of direct deposit states to display e.g. PENDING | REVERSED | APPLIED | REJECTED 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsTransitions(count?: number, userToken?: string, businessToken?: string, directDepositToken?: string, startIndex?: number, sortBy?: string, states?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectDepositTransitionListResponse> {
            const localVarFetchArgs = DirectDepositsApiFetchParamCreator(configuration).getDirectdepositsTransitions(count, userToken, businessToken, directDepositToken, startIndex, sortBy, states, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a direct deposit transition
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsTransitionsToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectDepositTransitionResponse> {
            const localVarFetchArgs = DirectDepositsApiFetchParamCreator(configuration).getDirectdepositsTransitionsToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a direct deposit transition
         * @param {DirectDepositTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectdepositsTransitions(body?: DirectDepositTransitionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DirectDepositTransitionResponse> {
            const localVarFetchArgs = DirectDepositsApiFetchParamCreator(configuration).postDirectdepositsTransitions(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific direct deposit account
         * @param {string} userOrBusinessToken User or business token
         * @param {DepositAccountUpdateRequest} body Deposit account update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, body: DepositAccountUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DepositAccountResponse> {
            const localVarFetchArgs = DirectDepositsApiFetchParamCreator(configuration).putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DirectDepositsApi - factory interface
 * @export
 */
export const DirectDepositsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all direct deposits
         * @param {number} [count] Number of direct deposits to retrieve
         * @param {number} [startIndex] Start index
         * @param {boolean} [reversedAfterGracePeriod] Reversed after grace period
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {'PENDING' | 'APPLIED' | 'REVERSED' | 'REJECTED'} [directDepositState] Direct deposit state
         * @param {string} [startSettlementDate] Start settlement date
         * @param {string} [endSettlementDate] End settlement date
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdeposits(count?: number, startIndex?: number, reversedAfterGracePeriod?: boolean, userToken?: string, businessToken?: string, directDepositState?: 'PENDING' | 'APPLIED' | 'REVERSED' | 'REJECTED', startSettlementDate?: string, endSettlementDate?: string, sortBy?: string, options?: any) {
            return DirectDepositsApiFp(configuration).getDirectdeposits(count, startIndex, reversedAfterGracePeriod, userToken, businessToken, directDepositState, startSettlementDate, endSettlementDate, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns an account and routing number which can be used for direct deposit
         * @param {string} userOrBusinessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, options?: any) {
            return DirectDepositsApiFp(configuration).getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a direct deposit entry
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsToken(token: string, options?: any) {
            return DirectDepositsApiFp(configuration).getDirectdepositsToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a list of direct deposit transitions
         * @param {number} [count] Number of direct deposit transitions to retrieve
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [directDepositToken] Direct deposit token
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [states] Comma-delimited list of direct deposit states to display e.g. PENDING | REVERSED | APPLIED | REJECTED 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsTransitions(count?: number, userToken?: string, businessToken?: string, directDepositToken?: string, startIndex?: number, sortBy?: string, states?: string, options?: any) {
            return DirectDepositsApiFp(configuration).getDirectdepositsTransitions(count, userToken, businessToken, directDepositToken, startIndex, sortBy, states, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a direct deposit transition
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsTransitionsToken(token: string, options?: any) {
            return DirectDepositsApiFp(configuration).getDirectdepositsTransitionsToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a direct deposit transition
         * @param {DirectDepositTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectdepositsTransitions(body?: DirectDepositTransitionRequest, options?: any) {
            return DirectDepositsApiFp(configuration).postDirectdepositsTransitions(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific direct deposit account
         * @param {string} userOrBusinessToken User or business token
         * @param {DepositAccountUpdateRequest} body Deposit account update request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, body: DepositAccountUpdateRequest, options?: any) {
            return DirectDepositsApiFp(configuration).putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken, body, options)(fetch, basePath);
        },
    };
};

/**
 * DirectDepositsApi - object-oriented interface
 * @export
 * @class DirectDepositsApi
 * @extends {BaseAPI}
 */
export class DirectDepositsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all direct deposits
     * @param {number} [count] Number of direct deposits to retrieve
     * @param {number} [startIndex] Start index
     * @param {boolean} [reversedAfterGracePeriod] Reversed after grace period
     * @param {string} [userToken] User token
     * @param {string} [businessToken] Business token
     * @param {'PENDING' | 'APPLIED' | 'REVERSED' | 'REJECTED'} [directDepositState] Direct deposit state
     * @param {string} [startSettlementDate] Start settlement date
     * @param {string} [endSettlementDate] End settlement date
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositsApi
     */
    public getDirectdeposits(count?: number, startIndex?: number, reversedAfterGracePeriod?: boolean, userToken?: string, businessToken?: string, directDepositState?: 'PENDING' | 'APPLIED' | 'REVERSED' | 'REJECTED', startSettlementDate?: string, endSettlementDate?: string, sortBy?: string, options?: any) {
        return DirectDepositsApiFp(this.configuration).getDirectdeposits(count, startIndex, reversedAfterGracePeriod, userToken, businessToken, directDepositState, startSettlementDate, endSettlementDate, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns an account and routing number which can be used for direct deposit
     * @param {string} userOrBusinessToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositsApi
     */
    public getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, options?: any) {
        return DirectDepositsApiFp(this.configuration).getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a direct deposit entry
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositsApi
     */
    public getDirectdepositsToken(token: string, options?: any) {
        return DirectDepositsApiFp(this.configuration).getDirectdepositsToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a list of direct deposit transitions
     * @param {number} [count] Number of direct deposit transitions to retrieve
     * @param {string} [userToken] User token
     * @param {string} [businessToken] Business token
     * @param {string} [directDepositToken] Direct deposit token
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {string} [states] Comma-delimited list of direct deposit states to display e.g. PENDING | REVERSED | APPLIED | REJECTED 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositsApi
     */
    public getDirectdepositsTransitions(count?: number, userToken?: string, businessToken?: string, directDepositToken?: string, startIndex?: number, sortBy?: string, states?: string, options?: any) {
        return DirectDepositsApiFp(this.configuration).getDirectdepositsTransitions(count, userToken, businessToken, directDepositToken, startIndex, sortBy, states, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a direct deposit transition
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositsApi
     */
    public getDirectdepositsTransitionsToken(token: string, options?: any) {
        return DirectDepositsApiFp(this.configuration).getDirectdepositsTransitionsToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a direct deposit transition
     * @param {DirectDepositTransitionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositsApi
     */
    public postDirectdepositsTransitions(body?: DirectDepositTransitionRequest, options?: any) {
        return DirectDepositsApiFp(this.configuration).postDirectdepositsTransitions(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific direct deposit account
     * @param {string} userOrBusinessToken User or business token
     * @param {DepositAccountUpdateRequest} body Deposit account update request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectDepositsApi
     */
    public putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, body: DepositAccountUpdateRequest, options?: any) {
        return DirectDepositsApiFp(this.configuration).putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken, body, options)(this.fetch, this.basePath);
    }

}

/**
 * FeeTransfersApi - fetch parameter creator
 * @export
 */
export const FeeTransfersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a fee transfer
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeetransfersToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getFeetransfersToken.');
            }
            const localVarPath = `/feetransfers/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a fee transfer
         * @param {FeeTransferRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeetransfers(body?: FeeTransferRequest, options: any = {}): FetchArgs {
            const localVarPath = `/feetransfers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FeeTransferRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeeTransfersApi - functional programming interface
 * @export
 */
export const FeeTransfersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a fee transfer
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeetransfersToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FeeTransferResponse> {
            const localVarFetchArgs = FeeTransfersApiFetchParamCreator(configuration).getFeetransfersToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a fee transfer
         * @param {FeeTransferRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeetransfers(body?: FeeTransferRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FeeTransferResponse> {
            const localVarFetchArgs = FeeTransfersApiFetchParamCreator(configuration).postFeetransfers(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FeeTransfersApi - factory interface
 * @export
 */
export const FeeTransfersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns a fee transfer
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeetransfersToken(token: string, options?: any) {
            return FeeTransfersApiFp(configuration).getFeetransfersToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a fee transfer
         * @param {FeeTransferRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeetransfers(body?: FeeTransferRequest, options?: any) {
            return FeeTransfersApiFp(configuration).postFeetransfers(body, options)(fetch, basePath);
        },
    };
};

/**
 * FeeTransfersApi - object-oriented interface
 * @export
 * @class FeeTransfersApi
 * @extends {BaseAPI}
 */
export class FeeTransfersApi extends BaseAPI {
    /**
     * 
     * @summary Returns a fee transfer
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeTransfersApi
     */
    public getFeetransfersToken(token: string, options?: any) {
        return FeeTransfersApiFp(this.configuration).getFeetransfersToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a fee transfer
     * @param {FeeTransferRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeeTransfersApi
     */
    public postFeetransfers(body?: FeeTransferRequest, options?: any) {
        return FeeTransfersApiFp(this.configuration).postFeetransfers(body, options)(this.fetch, this.basePath);
    }

}

/**
 * FeesApi - fetch parameter creator
 * @export
 */
export const FeesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all fees
         * @param {number} [count] Number of fees to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFees(count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/fees`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific fee
         * @param {string} token Fee token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeesToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getFeesToken.');
            }
            const localVarPath = `/fees/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a fee
         * @param {FeeRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFees(body?: FeeRequest, options: any = {}): FetchArgs {
            const localVarPath = `/fees`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FeeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific fee
         * @param {string} token Fee token
         * @param {FeeUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeesToken(token: string, body?: FeeUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putFeesToken.');
            }
            const localVarPath = `/fees/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FeeUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeesApi - functional programming interface
 * @export
 */
export const FeesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all fees
         * @param {number} [count] Number of fees to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFees(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FeeListResponse> {
            const localVarFetchArgs = FeesApiFetchParamCreator(configuration).getFees(count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific fee
         * @param {string} token Fee token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeesToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Fee> {
            const localVarFetchArgs = FeesApiFetchParamCreator(configuration).getFeesToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a fee
         * @param {FeeRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFees(body?: FeeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Fee> {
            const localVarFetchArgs = FeesApiFetchParamCreator(configuration).postFees(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific fee
         * @param {string} token Fee token
         * @param {FeeUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeesToken(token: string, body?: FeeUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Fee> {
            const localVarFetchArgs = FeesApiFetchParamCreator(configuration).putFeesToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FeesApi - factory interface
 * @export
 */
export const FeesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all fees
         * @param {number} [count] Number of fees to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFees(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return FeesApiFp(configuration).getFees(count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific fee
         * @param {string} token Fee token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeesToken(token: string, options?: any) {
            return FeesApiFp(configuration).getFeesToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a fee
         * @param {FeeRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFees(body?: FeeRequest, options?: any) {
            return FeesApiFp(configuration).postFees(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific fee
         * @param {string} token Fee token
         * @param {FeeUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeesToken(token: string, body?: FeeUpdateRequest, options?: any) {
            return FeesApiFp(configuration).putFeesToken(token, body, options)(fetch, basePath);
        },
    };
};

/**
 * FeesApi - object-oriented interface
 * @export
 * @class FeesApi
 * @extends {BaseAPI}
 */
export class FeesApi extends BaseAPI {
    /**
     * 
     * @summary Lists all fees
     * @param {number} [count] Number of fees to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeesApi
     */
    public getFees(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return FeesApiFp(this.configuration).getFees(count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific fee
     * @param {string} token Fee token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeesApi
     */
    public getFeesToken(token: string, options?: any) {
        return FeesApiFp(this.configuration).getFeesToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a fee
     * @param {FeeRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeesApi
     */
    public postFees(body?: FeeRequest, options?: any) {
        return FeesApiFp(this.configuration).postFees(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific fee
     * @param {string} token Fee token
     * @param {FeeUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeesApi
     */
    public putFeesToken(token: string, body?: FeeUpdateRequest, options?: any) {
        return FeesApiFp(this.configuration).putFeesToken(token, body, options)(this.fetch, this.basePath);
    }

}

/**
 * FundingSourcesApi - fetch parameter creator
 * @export
 */
export const FundingSourcesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves a linked funding source balance from a partner
         * @param {string} fundingSourceToken Funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchPartnerLinkedFundingSourceBalance(fundingSourceToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            if (fundingSourceToken === null || fundingSourceToken === undefined) {
                throw new RequiredError('fundingSourceToken','Required parameter fundingSourceToken was null or undefined when calling getAchPartnerLinkedFundingSourceBalance.');
            }
            const localVarPath = `/fundingsources/ach/partner/{funding_source_token}/balance`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of Program ACH funding sources
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma delimited list of fields to return (e.g. field_1,field_2,..)
         * @param {string} [sortBy] Sort order
         * @param {boolean} [active] Returns programs with this active state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllACHFundingSources(count?: number, startIndex?: number, fields?: string, sortBy?: string, active?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/fundingsources/program/ach`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a user ACH account
         * @param {string} fundingSourceToken Funding account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            if (fundingSourceToken === null || fundingSourceToken === undefined) {
                throw new RequiredError('fundingSourceToken','Required parameter fundingSourceToken was null or undefined when calling getFundingsourcesAchFundingsourcetoken.');
            }
            const localVarPath = `/fundingsources/ach/{funding_source_token}`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the dollar amounts used to verify the ACH account
         * @param {string} fundingSourceToken Funding account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            if (fundingSourceToken === null || fundingSourceToken === undefined) {
                throw new RequiredError('fundingSourceToken','Required parameter fundingSourceToken was null or undefined when calling getFundingsourcesAchFundingsourcetokenVerificationamounts.');
            }
            const localVarPath = `/fundingsources/ach/{funding_source_token}/verificationamounts`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all addresses for a business
         * @param {string} businessToken Business token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesBusinessBusinesstoken(businessToken: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'businessToken' is not null or undefined
            if (businessToken === null || businessToken === undefined) {
                throw new RequiredError('businessToken','Required parameter businessToken was null or undefined when calling getFundingsourcesAddressesBusinessBusinesstoken.');
            }
            const localVarPath = `/fundingsources/addresses/business/{business_token}`
                .replace(`{${"business_token"}}`, encodeURIComponent(String(businessToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a user address for a funding source
         * @param {string} fundingSourceAddressToken Funding source address token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'fundingSourceAddressToken' is not null or undefined
            if (fundingSourceAddressToken === null || fundingSourceAddressToken === undefined) {
                throw new RequiredError('fundingSourceAddressToken','Required parameter fundingSourceAddressToken was null or undefined when calling getFundingsourcesAddressesFundingsourceaddresstoken.');
            }
            const localVarPath = `/fundingsources/addresses/{funding_source_address_token}`
                .replace(`{${"funding_source_address_token"}}`, encodeURIComponent(String(fundingSourceAddressToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all addresses for a user
         * @param {string} userToken User token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesUserUsertoken(userToken: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userToken' is not null or undefined
            if (userToken === null || userToken === undefined) {
                throw new RequiredError('userToken','Required parameter userToken was null or undefined when calling getFundingsourcesAddressesUserUsertoken.');
            }
            const localVarPath = `/fundingsources/addresses/user/{user_token}`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all funding sources for a business
         * @param {string} businessToken Business token
         * @param {string} [type] Type, such as a payment card or ACH
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesBusinessBusinesstoken(businessToken: string, type?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'businessToken' is not null or undefined
            if (businessToken === null || businessToken === undefined) {
                throw new RequiredError('businessToken','Required parameter businessToken was null or undefined when calling getFundingsourcesBusinessBusinesstoken.');
            }
            const localVarPath = `/fundingsources/business/{business_token}`
                .replace(`{${"business_token"}}`, encodeURIComponent(String(businessToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific payment card
         * @param {string} fundingSourceToken Funding token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            if (fundingSourceToken === null || fundingSourceToken === undefined) {
                throw new RequiredError('fundingSourceToken','Required parameter fundingSourceToken was null or undefined when calling getFundingsourcesPaymentcardFundingsourcetoken.');
            }
            const localVarPath = `/fundingsources/paymentcard/{funding_source_token}`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific program funding source
         * @param {string} token Program funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesProgramToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getFundingsourcesProgramToken.');
            }
            const localVarPath = `/fundingsources/program/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a gateway program funding source
         * @param {string} token Gateway program funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesProgramgatewayToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getFundingsourcesProgramgatewayToken.');
            }
            const localVarPath = `/fundingsources/programgateway/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all funding sources for a user
         * @param {string} userToken User token
         * @param {string} [type] Type, such as a payment card or ACH
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesUserUsertoken(userToken: string, type?: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userToken' is not null or undefined
            if (userToken === null || userToken === undefined) {
                throw new RequiredError('userToken','Required parameter userToken was null or undefined when calling getFundingsourcesUserUsertoken.');
            }
            const localVarPath = `/fundingsources/user/{user_token}`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Registers an ACH funding source
         * @param {AchModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAch(body?: AchModel, options: any = {}): FetchArgs {
            const localVarPath = `/fundingsources/ach`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AchModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Registers an ACH funding source through a partner
         * @param {AchPartnerRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAchPartner(body?: AchPartnerRequestModel, options: any = {}): FetchArgs {
            const localVarPath = `/fundingsources/ach/partner`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AchPartnerRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an account holder address for a funding source
         * @param {CardHolderAddressModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAddresses(body?: CardHolderAddressModel, options: any = {}): FetchArgs {
            const localVarPath = `/fundingsources/addresses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardHolderAddressModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Registers a payment card funding source
         * @param {TokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesPaymentcard(body?: TokenRequest, options: any = {}): FetchArgs {
            const localVarPath = `/fundingsources/paymentcard`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TokenRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a program funding source
         * @param {ProgramFundingSourceRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgram(body?: ProgramFundingSourceRequest, options: any = {}): FetchArgs {
            const localVarPath = `/fundingsources/program`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProgramFundingSourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Registers an ACH funding source for a program
         * @param {BaseAchRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgramAch(body?: BaseAchRequestModel, options: any = {}): FetchArgs {
            const localVarPath = `/fundingsources/program/ach`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BaseAchRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a gateway program funding source
         * @param {GatewayProgramFundingSourceRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgramgateway(body?: GatewayProgramFundingSourceRequest, options: any = {}): FetchArgs {
            const localVarPath = `/fundingsources/programgateway`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GatewayProgramFundingSourceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verifies a bank account as a funding source
         * @param {string} fundingSourceToken 
         * @param {AchVerificationModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, body?: AchVerificationModel, options: any = {}): FetchArgs {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            if (fundingSourceToken === null || fundingSourceToken === undefined) {
                throw new RequiredError('fundingSourceToken','Required parameter fundingSourceToken was null or undefined when calling putFundingsourcesAchFundingsourcetoken.');
            }
            const localVarPath = `/fundingsources/ach/{funding_source_token}`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AchVerificationModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the account holder address for a funding source
         * @param {string} fundingSourceAddressToken Funding source address token
         * @param {CardHolderAddressUpdateModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, body?: CardHolderAddressUpdateModel, options: any = {}): FetchArgs {
            // verify required parameter 'fundingSourceAddressToken' is not null or undefined
            if (fundingSourceAddressToken === null || fundingSourceAddressToken === undefined) {
                throw new RequiredError('fundingSourceAddressToken','Required parameter fundingSourceAddressToken was null or undefined when calling putFundingsourcesAddressesFundingsourceaddresstoken.');
            }
            const localVarPath = `/fundingsources/addresses/{funding_source_address_token}`
                .replace(`{${"funding_source_address_token"}}`, encodeURIComponent(String(fundingSourceAddressToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardHolderAddressUpdateModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific payment card 
         * @param {string} fundingSourceToken Funding account token
         * @param {TokenUpdateRequest} body Payment card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesFundingsourcetoken(fundingSourceToken: string, body: TokenUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            if (fundingSourceToken === null || fundingSourceToken === undefined) {
                throw new RequiredError('fundingSourceToken','Required parameter fundingSourceToken was null or undefined when calling putFundingsourcesFundingsourcetoken.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putFundingsourcesFundingsourcetoken.');
            }
            const localVarPath = `/fundingsources/paymentcard/{funding_source_token}`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TokenUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Configures a default funding source
         * @param {string} fundingSourceToken Funding account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesFundingsourcetokenDefault(fundingSourceToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            if (fundingSourceToken === null || fundingSourceToken === undefined) {
                throw new RequiredError('fundingSourceToken','Required parameter fundingSourceToken was null or undefined when calling putFundingsourcesFundingsourcetokenDefault.');
            }
            const localVarPath = `/fundingsources/{funding_source_token}/default`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific program funding source
         * @param {string} token Program funding source token
         * @param {ProgramFundingSourceUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramToken(token: string, body?: ProgramFundingSourceUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putFundingsourcesProgramToken.');
            }
            const localVarPath = `/fundingsources/program/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProgramFundingSourceUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific gateway program funding source Custom headers
         * @param {string} token Gateway program funding source token
         * @param {GatewayProgramCustomHeaderUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramgatewayCustomHeaderToken(token: string, body?: GatewayProgramCustomHeaderUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putFundingsourcesProgramgatewayCustomHeaderToken.');
            }
            const localVarPath = `/fundingsources/programgateway/customheaders/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GatewayProgramCustomHeaderUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific gateway program funding source
         * @param {string} token Gateway program funding source token
         * @param {GatewayProgramFundingSourceUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramgatewayToken(token: string, body?: GatewayProgramFundingSourceUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putFundingsourcesProgramgatewayToken.');
            }
            const localVarPath = `/fundingsources/programgateway/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GatewayProgramFundingSourceUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Registers an ACH funding source of type Billpay
         * @param {BaseAchRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerBillpayAchBankAccount(body?: BaseAchRequestModel, options: any = {}): FetchArgs {
            const localVarPath = `/fundingsources/billpay/ach`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BaseAchRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FundingSourcesApi - functional programming interface
 * @export
 */
export const FundingSourcesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves a linked funding source balance from a partner
         * @param {string} fundingSourceToken Funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchPartnerLinkedFundingSourceBalance(fundingSourceToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LinkedAccountBalanceResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).getAchPartnerLinkedFundingSourceBalance(fundingSourceToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a list of Program ACH funding sources
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma delimited list of fields to return (e.g. field_1,field_2,..)
         * @param {string} [sortBy] Sort order
         * @param {boolean} [active] Returns programs with this active state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllACHFundingSources(count?: number, startIndex?: number, fields?: string, sortBy?: string, active?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ACHListResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).getAllACHFundingSources(count, startIndex, fields, sortBy, active, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a user ACH account
         * @param {string} fundingSourceToken Funding account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AchResponseModel> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).getFundingsourcesAchFundingsourcetoken(fundingSourceToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the dollar amounts used to verify the ACH account
         * @param {string} fundingSourceToken Funding account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AchVerificationModel> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all addresses for a business
         * @param {string} businessToken Business token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesBusinessBusinesstoken(businessToken: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardholderAddressListResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).getFundingsourcesAddressesBusinessBusinesstoken(businessToken, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a user address for a funding source
         * @param {string} fundingSourceAddressToken Funding source address token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardholderAddressResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all addresses for a user
         * @param {string} userToken User token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesUserUsertoken(userToken: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardholderAddressListResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).getFundingsourcesAddressesUserUsertoken(userToken, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all funding sources for a business
         * @param {string} businessToken Business token
         * @param {string} [type] Type, such as a payment card or ACH
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesBusinessBusinesstoken(businessToken: string, type?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FundingAccountListResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).getFundingsourcesBusinessBusinesstoken(businessToken, type, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific payment card
         * @param {string} fundingSourceToken Funding token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentCardResponseModel> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific program funding source
         * @param {string} token Program funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesProgramToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramFundingSourceResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).getFundingsourcesProgramToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a gateway program funding source
         * @param {string} token Gateway program funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesProgramgatewayToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GatewayProgramFundingSourceResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).getFundingsourcesProgramgatewayToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all funding sources for a user
         * @param {string} userToken User token
         * @param {string} [type] Type, such as a payment card or ACH
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesUserUsertoken(userToken: string, type?: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FundingAccountListResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).getFundingsourcesUserUsertoken(userToken, type, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Registers an ACH funding source
         * @param {AchModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAch(body?: AchModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AchResponseModel> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).postFundingsourcesAch(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Registers an ACH funding source through a partner
         * @param {AchPartnerRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAchPartner(body?: AchPartnerRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AchResponseModel> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).postFundingsourcesAchPartner(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates an account holder address for a funding source
         * @param {CardHolderAddressModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAddresses(body?: CardHolderAddressModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardholderAddressResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).postFundingsourcesAddresses(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Registers a payment card funding source
         * @param {TokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesPaymentcard(body?: TokenRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentCardResponseModel> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).postFundingsourcesPaymentcard(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a program funding source
         * @param {ProgramFundingSourceRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgram(body?: ProgramFundingSourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramFundingSourceResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).postFundingsourcesProgram(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Registers an ACH funding source for a program
         * @param {BaseAchRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgramAch(body?: BaseAchRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseAchResponseModel> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).postFundingsourcesProgramAch(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a gateway program funding source
         * @param {GatewayProgramFundingSourceRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgramgateway(body?: GatewayProgramFundingSourceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GatewayProgramFundingSourceResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).postFundingsourcesProgramgateway(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Verifies a bank account as a funding source
         * @param {string} fundingSourceToken 
         * @param {AchVerificationModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, body?: AchVerificationModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AchResponseModel> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).putFundingsourcesAchFundingsourcetoken(fundingSourceToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the account holder address for a funding source
         * @param {string} fundingSourceAddressToken Funding source address token
         * @param {CardHolderAddressUpdateModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, body?: CardHolderAddressUpdateModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardholderAddressResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific payment card 
         * @param {string} fundingSourceToken Funding account token
         * @param {TokenUpdateRequest} body Payment card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesFundingsourcetoken(fundingSourceToken: string, body: TokenUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentCardResponseModel> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).putFundingsourcesFundingsourcetoken(fundingSourceToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Configures a default funding source
         * @param {string} fundingSourceToken Funding account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesFundingsourcetokenDefault(fundingSourceToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentCardResponseModel> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).putFundingsourcesFundingsourcetokenDefault(fundingSourceToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific program funding source
         * @param {string} token Program funding source token
         * @param {ProgramFundingSourceUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramToken(token: string, body?: ProgramFundingSourceUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramFundingSourceResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).putFundingsourcesProgramToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific gateway program funding source Custom headers
         * @param {string} token Gateway program funding source token
         * @param {GatewayProgramCustomHeaderUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramgatewayCustomHeaderToken(token: string, body?: GatewayProgramCustomHeaderUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GatewayProgramFundingSourceResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).putFundingsourcesProgramgatewayCustomHeaderToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific gateway program funding source
         * @param {string} token Gateway program funding source token
         * @param {GatewayProgramFundingSourceUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramgatewayToken(token: string, body?: GatewayProgramFundingSourceUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GatewayProgramFundingSourceResponse> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).putFundingsourcesProgramgatewayToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Registers an ACH funding source of type Billpay
         * @param {BaseAchRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerBillpayAchBankAccount(body?: BaseAchRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseAchResponseModel> {
            const localVarFetchArgs = FundingSourcesApiFetchParamCreator(configuration).registerBillpayAchBankAccount(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FundingSourcesApi - factory interface
 * @export
 */
export const FundingSourcesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Retrieves a linked funding source balance from a partner
         * @param {string} fundingSourceToken Funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchPartnerLinkedFundingSourceBalance(fundingSourceToken: string, options?: any) {
            return FundingSourcesApiFp(configuration).getAchPartnerLinkedFundingSourceBalance(fundingSourceToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a list of Program ACH funding sources
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma delimited list of fields to return (e.g. field_1,field_2,..)
         * @param {string} [sortBy] Sort order
         * @param {boolean} [active] Returns programs with this active state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllACHFundingSources(count?: number, startIndex?: number, fields?: string, sortBy?: string, active?: boolean, options?: any) {
            return FundingSourcesApiFp(configuration).getAllACHFundingSources(count, startIndex, fields, sortBy, active, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a user ACH account
         * @param {string} fundingSourceToken Funding account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, options?: any) {
            return FundingSourcesApiFp(configuration).getFundingsourcesAchFundingsourcetoken(fundingSourceToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the dollar amounts used to verify the ACH account
         * @param {string} fundingSourceToken Funding account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken: string, options?: any) {
            return FundingSourcesApiFp(configuration).getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all addresses for a business
         * @param {string} businessToken Business token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesBusinessBusinesstoken(businessToken: string, fields?: string, options?: any) {
            return FundingSourcesApiFp(configuration).getFundingsourcesAddressesBusinessBusinesstoken(businessToken, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a user address for a funding source
         * @param {string} fundingSourceAddressToken Funding source address token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, options?: any) {
            return FundingSourcesApiFp(configuration).getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all addresses for a user
         * @param {string} userToken User token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesUserUsertoken(userToken: string, fields?: string, options?: any) {
            return FundingSourcesApiFp(configuration).getFundingsourcesAddressesUserUsertoken(userToken, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all funding sources for a business
         * @param {string} businessToken Business token
         * @param {string} [type] Type, such as a payment card or ACH
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesBusinessBusinesstoken(businessToken: string, type?: string, fields?: string, options?: any) {
            return FundingSourcesApiFp(configuration).getFundingsourcesBusinessBusinesstoken(businessToken, type, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific payment card
         * @param {string} fundingSourceToken Funding token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken: string, options?: any) {
            return FundingSourcesApiFp(configuration).getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific program funding source
         * @param {string} token Program funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesProgramToken(token: string, options?: any) {
            return FundingSourcesApiFp(configuration).getFundingsourcesProgramToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a gateway program funding source
         * @param {string} token Gateway program funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesProgramgatewayToken(token: string, options?: any) {
            return FundingSourcesApiFp(configuration).getFundingsourcesProgramgatewayToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all funding sources for a user
         * @param {string} userToken User token
         * @param {string} [type] Type, such as a payment card or ACH
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesUserUsertoken(userToken: string, type?: string, fields?: string, options?: any) {
            return FundingSourcesApiFp(configuration).getFundingsourcesUserUsertoken(userToken, type, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Registers an ACH funding source
         * @param {AchModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAch(body?: AchModel, options?: any) {
            return FundingSourcesApiFp(configuration).postFundingsourcesAch(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Registers an ACH funding source through a partner
         * @param {AchPartnerRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAchPartner(body?: AchPartnerRequestModel, options?: any) {
            return FundingSourcesApiFp(configuration).postFundingsourcesAchPartner(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates an account holder address for a funding source
         * @param {CardHolderAddressModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAddresses(body?: CardHolderAddressModel, options?: any) {
            return FundingSourcesApiFp(configuration).postFundingsourcesAddresses(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Registers a payment card funding source
         * @param {TokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesPaymentcard(body?: TokenRequest, options?: any) {
            return FundingSourcesApiFp(configuration).postFundingsourcesPaymentcard(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a program funding source
         * @param {ProgramFundingSourceRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgram(body?: ProgramFundingSourceRequest, options?: any) {
            return FundingSourcesApiFp(configuration).postFundingsourcesProgram(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Registers an ACH funding source for a program
         * @param {BaseAchRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgramAch(body?: BaseAchRequestModel, options?: any) {
            return FundingSourcesApiFp(configuration).postFundingsourcesProgramAch(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a gateway program funding source
         * @param {GatewayProgramFundingSourceRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgramgateway(body?: GatewayProgramFundingSourceRequest, options?: any) {
            return FundingSourcesApiFp(configuration).postFundingsourcesProgramgateway(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Verifies a bank account as a funding source
         * @param {string} fundingSourceToken 
         * @param {AchVerificationModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, body?: AchVerificationModel, options?: any) {
            return FundingSourcesApiFp(configuration).putFundingsourcesAchFundingsourcetoken(fundingSourceToken, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the account holder address for a funding source
         * @param {string} fundingSourceAddressToken Funding source address token
         * @param {CardHolderAddressUpdateModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, body?: CardHolderAddressUpdateModel, options?: any) {
            return FundingSourcesApiFp(configuration).putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific payment card 
         * @param {string} fundingSourceToken Funding account token
         * @param {TokenUpdateRequest} body Payment card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesFundingsourcetoken(fundingSourceToken: string, body: TokenUpdateRequest, options?: any) {
            return FundingSourcesApiFp(configuration).putFundingsourcesFundingsourcetoken(fundingSourceToken, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Configures a default funding source
         * @param {string} fundingSourceToken Funding account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesFundingsourcetokenDefault(fundingSourceToken: string, options?: any) {
            return FundingSourcesApiFp(configuration).putFundingsourcesFundingsourcetokenDefault(fundingSourceToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific program funding source
         * @param {string} token Program funding source token
         * @param {ProgramFundingSourceUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramToken(token: string, body?: ProgramFundingSourceUpdateRequest, options?: any) {
            return FundingSourcesApiFp(configuration).putFundingsourcesProgramToken(token, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific gateway program funding source Custom headers
         * @param {string} token Gateway program funding source token
         * @param {GatewayProgramCustomHeaderUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramgatewayCustomHeaderToken(token: string, body?: GatewayProgramCustomHeaderUpdateRequest, options?: any) {
            return FundingSourcesApiFp(configuration).putFundingsourcesProgramgatewayCustomHeaderToken(token, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific gateway program funding source
         * @param {string} token Gateway program funding source token
         * @param {GatewayProgramFundingSourceUpdateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramgatewayToken(token: string, body?: GatewayProgramFundingSourceUpdateRequest, options?: any) {
            return FundingSourcesApiFp(configuration).putFundingsourcesProgramgatewayToken(token, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Registers an ACH funding source of type Billpay
         * @param {BaseAchRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerBillpayAchBankAccount(body?: BaseAchRequestModel, options?: any) {
            return FundingSourcesApiFp(configuration).registerBillpayAchBankAccount(body, options)(fetch, basePath);
        },
    };
};

/**
 * FundingSourcesApi - object-oriented interface
 * @export
 * @class FundingSourcesApi
 * @extends {BaseAPI}
 */
export class FundingSourcesApi extends BaseAPI {
    /**
     * 
     * @summary Retrieves a linked funding source balance from a partner
     * @param {string} fundingSourceToken Funding source token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getAchPartnerLinkedFundingSourceBalance(fundingSourceToken: string, options?: any) {
        return FundingSourcesApiFp(this.configuration).getAchPartnerLinkedFundingSourceBalance(fundingSourceToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a list of Program ACH funding sources
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [fields] Comma delimited list of fields to return (e.g. field_1,field_2,..)
     * @param {string} [sortBy] Sort order
     * @param {boolean} [active] Returns programs with this active state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getAllACHFundingSources(count?: number, startIndex?: number, fields?: string, sortBy?: string, active?: boolean, options?: any) {
        return FundingSourcesApiFp(this.configuration).getAllACHFundingSources(count, startIndex, fields, sortBy, active, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a user ACH account
     * @param {string} fundingSourceToken Funding account token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, options?: any) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesAchFundingsourcetoken(fundingSourceToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the dollar amounts used to verify the ACH account
     * @param {string} fundingSourceToken Funding account token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken: string, options?: any) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all addresses for a business
     * @param {string} businessToken Business token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getFundingsourcesAddressesBusinessBusinesstoken(businessToken: string, fields?: string, options?: any) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesAddressesBusinessBusinesstoken(businessToken, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a user address for a funding source
     * @param {string} fundingSourceAddressToken Funding source address token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, options?: any) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all addresses for a user
     * @param {string} userToken User token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getFundingsourcesAddressesUserUsertoken(userToken: string, fields?: string, options?: any) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesAddressesUserUsertoken(userToken, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all funding sources for a business
     * @param {string} businessToken Business token
     * @param {string} [type] Type, such as a payment card or ACH
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getFundingsourcesBusinessBusinesstoken(businessToken: string, type?: string, fields?: string, options?: any) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesBusinessBusinesstoken(businessToken, type, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific payment card
     * @param {string} fundingSourceToken Funding token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken: string, options?: any) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific program funding source
     * @param {string} token Program funding source token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getFundingsourcesProgramToken(token: string, options?: any) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesProgramToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a gateway program funding source
     * @param {string} token Gateway program funding source token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getFundingsourcesProgramgatewayToken(token: string, options?: any) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesProgramgatewayToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all funding sources for a user
     * @param {string} userToken User token
     * @param {string} [type] Type, such as a payment card or ACH
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public getFundingsourcesUserUsertoken(userToken: string, type?: string, fields?: string, options?: any) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesUserUsertoken(userToken, type, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Registers an ACH funding source
     * @param {AchModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public postFundingsourcesAch(body?: AchModel, options?: any) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesAch(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Registers an ACH funding source through a partner
     * @param {AchPartnerRequestModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public postFundingsourcesAchPartner(body?: AchPartnerRequestModel, options?: any) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesAchPartner(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates an account holder address for a funding source
     * @param {CardHolderAddressModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public postFundingsourcesAddresses(body?: CardHolderAddressModel, options?: any) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesAddresses(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Registers a payment card funding source
     * @param {TokenRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public postFundingsourcesPaymentcard(body?: TokenRequest, options?: any) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesPaymentcard(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a program funding source
     * @param {ProgramFundingSourceRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public postFundingsourcesProgram(body?: ProgramFundingSourceRequest, options?: any) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesProgram(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Registers an ACH funding source for a program
     * @param {BaseAchRequestModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public postFundingsourcesProgramAch(body?: BaseAchRequestModel, options?: any) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesProgramAch(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a gateway program funding source
     * @param {GatewayProgramFundingSourceRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public postFundingsourcesProgramgateway(body?: GatewayProgramFundingSourceRequest, options?: any) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesProgramgateway(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Verifies a bank account as a funding source
     * @param {string} fundingSourceToken 
     * @param {AchVerificationModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public putFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, body?: AchVerificationModel, options?: any) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesAchFundingsourcetoken(fundingSourceToken, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the account holder address for a funding source
     * @param {string} fundingSourceAddressToken Funding source address token
     * @param {CardHolderAddressUpdateModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, body?: CardHolderAddressUpdateModel, options?: any) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific payment card 
     * @param {string} fundingSourceToken Funding account token
     * @param {TokenUpdateRequest} body Payment card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public putFundingsourcesFundingsourcetoken(fundingSourceToken: string, body: TokenUpdateRequest, options?: any) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesFundingsourcetoken(fundingSourceToken, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Configures a default funding source
     * @param {string} fundingSourceToken Funding account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public putFundingsourcesFundingsourcetokenDefault(fundingSourceToken: string, options?: any) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesFundingsourcetokenDefault(fundingSourceToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific program funding source
     * @param {string} token Program funding source token
     * @param {ProgramFundingSourceUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public putFundingsourcesProgramToken(token: string, body?: ProgramFundingSourceUpdateRequest, options?: any) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesProgramToken(token, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific gateway program funding source Custom headers
     * @param {string} token Gateway program funding source token
     * @param {GatewayProgramCustomHeaderUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public putFundingsourcesProgramgatewayCustomHeaderToken(token: string, body?: GatewayProgramCustomHeaderUpdateRequest, options?: any) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesProgramgatewayCustomHeaderToken(token, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific gateway program funding source
     * @param {string} token Gateway program funding source token
     * @param {GatewayProgramFundingSourceUpdateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public putFundingsourcesProgramgatewayToken(token: string, body?: GatewayProgramFundingSourceUpdateRequest, options?: any) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesProgramgatewayToken(token, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Registers an ACH funding source of type Billpay
     * @param {BaseAchRequestModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundingSourcesApi
     */
    public registerBillpayAchBankAccount(body?: BaseAchRequestModel, options?: any) {
        return FundingSourcesApiFp(this.configuration).registerBillpayAchBankAccount(body, options)(this.fetch, this.basePath);
    }

}

/**
 * GpaOrdersApi - fetch parameter creator
 * @export
 */
export const GpaOrdersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a GPA order
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getGpaordersToken.');
            }
            const localVarPath = `/gpaorders/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all GPA returns
         * @param {number} [count] Number of GPA unloads to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [originalOrderToken] Original order token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersUnloads(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, originalOrderToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/gpaorders/unloads`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (originalOrderToken !== undefined) {
                localVarQueryParameter['original_order_token'] = originalOrderToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific GPA return
         * @param {string} unloadToken Unload token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersUnloadsUnloadtoken(unloadToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'unloadToken' is not null or undefined
            if (unloadToken === null || unloadToken === undefined) {
                throw new RequiredError('unloadToken','Required parameter unloadToken was null or undefined when calling getGpaordersUnloadsUnloadtoken.');
            }
            const localVarPath = `/gpaorders/unloads/{unload_token}`
                .replace(`{${"unload_token"}}`, encodeURIComponent(String(unloadToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Funds a user's GPA account
         * @param {GpaRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGpaorders(body?: GpaRequest, options: any = {}): FetchArgs {
            const localVarPath = `/gpaorders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GpaRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a GPA order
         * @param {UnloadRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGpaordersUnloads(body?: UnloadRequestModel, options: any = {}): FetchArgs {
            const localVarPath = `/gpaorders/unloads`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UnloadRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GpaOrdersApi - functional programming interface
 * @export
 */
export const GpaOrdersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a GPA order
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GpaResponse> {
            const localVarFetchArgs = GpaOrdersApiFetchParamCreator(configuration).getGpaordersToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all GPA returns
         * @param {number} [count] Number of GPA unloads to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [originalOrderToken] Original order token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersUnloads(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, originalOrderToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GPAUnloadListResponse> {
            const localVarFetchArgs = GpaOrdersApiFetchParamCreator(configuration).getGpaordersUnloads(count, startIndex, fields, sortBy, userToken, businessToken, originalOrderToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific GPA return
         * @param {string} unloadToken Unload token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersUnloadsUnloadtoken(unloadToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GpaReturns> {
            const localVarFetchArgs = GpaOrdersApiFetchParamCreator(configuration).getGpaordersUnloadsUnloadtoken(unloadToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Funds a user's GPA account
         * @param {GpaRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGpaorders(body?: GpaRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GpaResponse> {
            const localVarFetchArgs = GpaOrdersApiFetchParamCreator(configuration).postGpaorders(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a GPA order
         * @param {UnloadRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGpaordersUnloads(body?: UnloadRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GpaReturns> {
            const localVarFetchArgs = GpaOrdersApiFetchParamCreator(configuration).postGpaordersUnloads(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GpaOrdersApi - factory interface
 * @export
 */
export const GpaOrdersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns a GPA order
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersToken(token: string, options?: any) {
            return GpaOrdersApiFp(configuration).getGpaordersToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all GPA returns
         * @param {number} [count] Number of GPA unloads to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [originalOrderToken] Original order token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersUnloads(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, originalOrderToken?: string, options?: any) {
            return GpaOrdersApiFp(configuration).getGpaordersUnloads(count, startIndex, fields, sortBy, userToken, businessToken, originalOrderToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific GPA return
         * @param {string} unloadToken Unload token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersUnloadsUnloadtoken(unloadToken: string, options?: any) {
            return GpaOrdersApiFp(configuration).getGpaordersUnloadsUnloadtoken(unloadToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Funds a user's GPA account
         * @param {GpaRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGpaorders(body?: GpaRequest, options?: any) {
            return GpaOrdersApiFp(configuration).postGpaorders(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a GPA order
         * @param {UnloadRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGpaordersUnloads(body?: UnloadRequestModel, options?: any) {
            return GpaOrdersApiFp(configuration).postGpaordersUnloads(body, options)(fetch, basePath);
        },
    };
};

/**
 * GpaOrdersApi - object-oriented interface
 * @export
 * @class GpaOrdersApi
 * @extends {BaseAPI}
 */
export class GpaOrdersApi extends BaseAPI {
    /**
     * 
     * @summary Returns a GPA order
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GpaOrdersApi
     */
    public getGpaordersToken(token: string, options?: any) {
        return GpaOrdersApiFp(this.configuration).getGpaordersToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all GPA returns
     * @param {number} [count] Number of GPA unloads to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {string} [userToken] User token
     * @param {string} [businessToken] Business token
     * @param {string} [originalOrderToken] Original order token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GpaOrdersApi
     */
    public getGpaordersUnloads(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, originalOrderToken?: string, options?: any) {
        return GpaOrdersApiFp(this.configuration).getGpaordersUnloads(count, startIndex, fields, sortBy, userToken, businessToken, originalOrderToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific GPA return
     * @param {string} unloadToken Unload token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GpaOrdersApi
     */
    public getGpaordersUnloadsUnloadtoken(unloadToken: string, options?: any) {
        return GpaOrdersApiFp(this.configuration).getGpaordersUnloadsUnloadtoken(unloadToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Funds a user's GPA account
     * @param {GpaRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GpaOrdersApi
     */
    public postGpaorders(body?: GpaRequest, options?: any) {
        return GpaOrdersApiFp(this.configuration).postGpaorders(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a GPA order
     * @param {UnloadRequestModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GpaOrdersApi
     */
    public postGpaordersUnloads(body?: UnloadRequestModel, options?: any) {
        return GpaOrdersApiFp(this.configuration).postGpaordersUnloads(body, options)(this.fetch, this.basePath);
    }

}

/**
 * KycApi - fetch parameter creator
 * @export
 */
export const KycApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all KYC results for a business
         * @param {string} businessToken Business token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'businessToken' is not null or undefined
            if (businessToken === null || businessToken === undefined) {
                throw new RequiredError('businessToken','Required parameter businessToken was null or undefined when calling getKycBusinessBusinesstoken.');
            }
            const localVarPath = `/kyc/business/{business_token}`
                .replace(`{${"business_token"}}`, encodeURIComponent(String(businessToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific KYC result
         * @param {string} token KYC token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getKycToken.');
            }
            const localVarPath = `/kyc/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all KYC results for a user
         * @param {string} userToken User token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userToken' is not null or undefined
            if (userToken === null || userToken === undefined) {
                throw new RequiredError('userToken','Required parameter userToken was null or undefined when calling getKycUserUsertoken.');
            }
            const localVarPath = `/kyc/user/{user_token}`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Performs a KYC
         * @param {KycRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postKyc(body?: KycRequest, options: any = {}): FetchArgs {
            const localVarPath = `/kyc`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KycRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accepts KYC answers for questions from initial request
         * @param {string} token KYC token
         * @param {KYCSubmitAnswersRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putKycToken(token: string, body?: KYCSubmitAnswersRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putKycToken.');
            }
            const localVarPath = `/kyc/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"KYCSubmitAnswersRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KycApi - functional programming interface
 * @export
 */
export const KycApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all KYC results for a business
         * @param {string} businessToken Business token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KYCListResponse> {
            const localVarFetchArgs = KycApiFetchParamCreator(configuration).getKycBusinessBusinesstoken(businessToken, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific KYC result
         * @param {string} token KYC token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KycResponse> {
            const localVarFetchArgs = KycApiFetchParamCreator(configuration).getKycToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all KYC results for a user
         * @param {string} userToken User token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KYCListResponse> {
            const localVarFetchArgs = KycApiFetchParamCreator(configuration).getKycUserUsertoken(userToken, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Performs a KYC
         * @param {KycRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postKyc(body?: KycRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KycResponse> {
            const localVarFetchArgs = KycApiFetchParamCreator(configuration).postKyc(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Accepts KYC answers for questions from initial request
         * @param {string} token KYC token
         * @param {KYCSubmitAnswersRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putKycToken(token: string, body?: KYCSubmitAnswersRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<KycResponse> {
            const localVarFetchArgs = KycApiFetchParamCreator(configuration).putKycToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * KycApi - factory interface
 * @export
 */
export const KycApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all KYC results for a business
         * @param {string} businessToken Business token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return KycApiFp(configuration).getKycBusinessBusinesstoken(businessToken, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific KYC result
         * @param {string} token KYC token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycToken(token: string, options?: any) {
            return KycApiFp(configuration).getKycToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all KYC results for a user
         * @param {string} userToken User token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return KycApiFp(configuration).getKycUserUsertoken(userToken, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Performs a KYC
         * @param {KycRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postKyc(body?: KycRequest, options?: any) {
            return KycApiFp(configuration).postKyc(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Accepts KYC answers for questions from initial request
         * @param {string} token KYC token
         * @param {KYCSubmitAnswersRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putKycToken(token: string, body?: KYCSubmitAnswersRequestModel, options?: any) {
            return KycApiFp(configuration).putKycToken(token, body, options)(fetch, basePath);
        },
    };
};

/**
 * KycApi - object-oriented interface
 * @export
 * @class KycApi
 * @extends {BaseAPI}
 */
export class KycApi extends BaseAPI {
    /**
     * 
     * @summary Lists all KYC results for a business
     * @param {string} businessToken Business token
     * @param {number} [count] Number of items to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycApi
     */
    public getKycBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return KycApiFp(this.configuration).getKycBusinessBusinesstoken(businessToken, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific KYC result
     * @param {string} token KYC token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycApi
     */
    public getKycToken(token: string, options?: any) {
        return KycApiFp(this.configuration).getKycToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all KYC results for a user
     * @param {string} userToken User token
     * @param {number} [count] Number of items to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycApi
     */
    public getKycUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return KycApiFp(this.configuration).getKycUserUsertoken(userToken, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Performs a KYC
     * @param {KycRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycApi
     */
    public postKyc(body?: KycRequest, options?: any) {
        return KycApiFp(this.configuration).postKyc(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Accepts KYC answers for questions from initial request
     * @param {string} token KYC token
     * @param {KYCSubmitAnswersRequestModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KycApi
     */
    public putKycToken(token: string, body?: KYCSubmitAnswersRequestModel, options?: any) {
        return KycApiFp(this.configuration).putKycToken(token, body, options)(this.fetch, this.basePath);
    }

}

/**
 * MccGroupsApi - fetch parameter creator
 * @export
 */
export const MccGroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all MCC groups
         * @param {string} [mcc] MCC
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMccgroups(mcc?: string, count?: number, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/mccgroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mcc !== undefined) {
                localVarQueryParameter['mcc'] = mcc;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific MCC group
         * @param {string} token MCC group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMccgroupsToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getMccgroupsToken.');
            }
            const localVarPath = `/mccgroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an MCC group
         * @param {MccGroupModel} body MCC group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMccgroups(body: MccGroupModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postMccgroups.');
            }
            const localVarPath = `/mccgroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MccGroupModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an MCC group
         * @param {MccGroupUpdateModel} body MCC group
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMccgroupsToken(body: MccGroupUpdateModel, token: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putMccgroupsToken.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putMccgroupsToken.');
            }
            const localVarPath = `/mccgroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MccGroupUpdateModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MccGroupsApi - functional programming interface
 * @export
 */
export const MccGroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all MCC groups
         * @param {string} [mcc] MCC
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMccgroups(mcc?: string, count?: number, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MCCGroupListResponse> {
            const localVarFetchArgs = MccGroupsApiFetchParamCreator(configuration).getMccgroups(mcc, count, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific MCC group
         * @param {string} token MCC group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMccgroupsToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MccGroupModel> {
            const localVarFetchArgs = MccGroupsApiFetchParamCreator(configuration).getMccgroupsToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates an MCC group
         * @param {MccGroupModel} body MCC group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMccgroups(body: MccGroupModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MccGroupModel> {
            const localVarFetchArgs = MccGroupsApiFetchParamCreator(configuration).postMccgroups(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an MCC group
         * @param {MccGroupUpdateModel} body MCC group
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMccgroupsToken(body: MccGroupUpdateModel, token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MccGroupUpdateModel> {
            const localVarFetchArgs = MccGroupsApiFetchParamCreator(configuration).putMccgroupsToken(body, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MccGroupsApi - factory interface
 * @export
 */
export const MccGroupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all MCC groups
         * @param {string} [mcc] MCC
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMccgroups(mcc?: string, count?: number, startIndex?: number, sortBy?: string, options?: any) {
            return MccGroupsApiFp(configuration).getMccgroups(mcc, count, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific MCC group
         * @param {string} token MCC group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMccgroupsToken(token: string, options?: any) {
            return MccGroupsApiFp(configuration).getMccgroupsToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates an MCC group
         * @param {MccGroupModel} body MCC group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMccgroups(body: MccGroupModel, options?: any) {
            return MccGroupsApiFp(configuration).postMccgroups(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an MCC group
         * @param {MccGroupUpdateModel} body MCC group
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMccgroupsToken(body: MccGroupUpdateModel, token: string, options?: any) {
            return MccGroupsApiFp(configuration).putMccgroupsToken(body, token, options)(fetch, basePath);
        },
    };
};

/**
 * MccGroupsApi - object-oriented interface
 * @export
 * @class MccGroupsApi
 * @extends {BaseAPI}
 */
export class MccGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all MCC groups
     * @param {string} [mcc] MCC
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MccGroupsApi
     */
    public getMccgroups(mcc?: string, count?: number, startIndex?: number, sortBy?: string, options?: any) {
        return MccGroupsApiFp(this.configuration).getMccgroups(mcc, count, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific MCC group
     * @param {string} token MCC group token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MccGroupsApi
     */
    public getMccgroupsToken(token: string, options?: any) {
        return MccGroupsApiFp(this.configuration).getMccgroupsToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates an MCC group
     * @param {MccGroupModel} body MCC group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MccGroupsApi
     */
    public postMccgroups(body: MccGroupModel, options?: any) {
        return MccGroupsApiFp(this.configuration).postMccgroups(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an MCC group
     * @param {MccGroupUpdateModel} body MCC group
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MccGroupsApi
     */
    public putMccgroupsToken(body: MccGroupUpdateModel, token: string, options?: any) {
        return MccGroupsApiFp(this.configuration).putMccgroupsToken(body, token, options)(this.fetch, this.basePath);
    }

}

/**
 * MerchantgroupsApi - fetch parameter creator
 * @export
 */
export const MerchantgroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Merchant Group
         * @param {string} token Merchant Group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantGroup(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getMerchantGroup.');
            }
            const localVarPath = `/merchantgroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all Merchant Groups
         * @param {string} [mid] mid
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantGroups(mid?: string, count?: number, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/merchantgroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mid !== undefined) {
                localVarQueryParameter['mid'] = mid;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a merchant group
         * @param {MerchantGroupRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMerchantGroup(body?: MerchantGroupRequest, options: any = {}): FetchArgs {
            const localVarPath = `/merchantgroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MerchantGroupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an Merchant Group
         * @param {MerchantGroupUpdateRequest} body Merchant Group
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMerchantGroupsToken(body: MerchantGroupUpdateRequest, token: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putMerchantGroupsToken.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putMerchantGroupsToken.');
            }
            const localVarPath = `/merchantgroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MerchantGroupUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantgroupsApi - functional programming interface
 * @export
 */
export const MerchantgroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Merchant Group
         * @param {string} token Merchant Group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantGroup(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MerchantGroupResponse> {
            const localVarFetchArgs = MerchantgroupsApiFetchParamCreator(configuration).getMerchantGroup(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all Merchant Groups
         * @param {string} [mid] mid
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantGroups(mid?: string, count?: number, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MerchantGroupListResponse> {
            const localVarFetchArgs = MerchantgroupsApiFetchParamCreator(configuration).getMerchantGroups(mid, count, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a merchant group
         * @param {MerchantGroupRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMerchantGroup(body?: MerchantGroupRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MerchantGroupResponse> {
            const localVarFetchArgs = MerchantgroupsApiFetchParamCreator(configuration).postMerchantGroup(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an Merchant Group
         * @param {MerchantGroupUpdateRequest} body Merchant Group
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMerchantGroupsToken(body: MerchantGroupUpdateRequest, token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MerchantGroupResponse> {
            const localVarFetchArgs = MerchantgroupsApiFetchParamCreator(configuration).putMerchantGroupsToken(body, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MerchantgroupsApi - factory interface
 * @export
 */
export const MerchantgroupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns a Merchant Group
         * @param {string} token Merchant Group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantGroup(token: string, options?: any) {
            return MerchantgroupsApiFp(configuration).getMerchantGroup(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all Merchant Groups
         * @param {string} [mid] mid
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantGroups(mid?: string, count?: number, startIndex?: number, sortBy?: string, options?: any) {
            return MerchantgroupsApiFp(configuration).getMerchantGroups(mid, count, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a merchant group
         * @param {MerchantGroupRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMerchantGroup(body?: MerchantGroupRequest, options?: any) {
            return MerchantgroupsApiFp(configuration).postMerchantGroup(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an Merchant Group
         * @param {MerchantGroupUpdateRequest} body Merchant Group
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMerchantGroupsToken(body: MerchantGroupUpdateRequest, token: string, options?: any) {
            return MerchantgroupsApiFp(configuration).putMerchantGroupsToken(body, token, options)(fetch, basePath);
        },
    };
};

/**
 * MerchantgroupsApi - object-oriented interface
 * @export
 * @class MerchantgroupsApi
 * @extends {BaseAPI}
 */
export class MerchantgroupsApi extends BaseAPI {
    /**
     * 
     * @summary Returns a Merchant Group
     * @param {string} token Merchant Group token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantgroupsApi
     */
    public getMerchantGroup(token: string, options?: any) {
        return MerchantgroupsApiFp(this.configuration).getMerchantGroup(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all Merchant Groups
     * @param {string} [mid] mid
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantgroupsApi
     */
    public getMerchantGroups(mid?: string, count?: number, startIndex?: number, sortBy?: string, options?: any) {
        return MerchantgroupsApiFp(this.configuration).getMerchantGroups(mid, count, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a merchant group
     * @param {MerchantGroupRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantgroupsApi
     */
    public postMerchantGroup(body?: MerchantGroupRequest, options?: any) {
        return MerchantgroupsApiFp(this.configuration).postMerchantGroup(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an Merchant Group
     * @param {MerchantGroupUpdateRequest} body Merchant Group
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantgroupsApi
     */
    public putMerchantGroupsToken(body: MerchantGroupUpdateRequest, token: string, options?: any) {
        return MerchantgroupsApiFp(this.configuration).putMerchantGroupsToken(body, token, options)(this.fetch, this.basePath);
    }

}

/**
 * PeerTransfersApi - fetch parameter creator
 * @export
 */
export const PeerTransfersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns details of a previous transfer
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getPeertransfersToken.');
            }
            const localVarPath = `/peertransfers/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstoken(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userOrBusinessToken' is not null or undefined
            if (userOrBusinessToken === null || userOrBusinessToken === undefined) {
                throw new RequiredError('userOrBusinessToken','Required parameter userOrBusinessToken was null or undefined when calling getPeertransfersUserUserorbusinesstoken.');
            }
            const localVarPath = `/peertransfers/user/{user_or_business_token}`
                .replace(`{${"user_or_business_token"}}`, encodeURIComponent(String(userOrBusinessToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns received peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userOrBusinessToken' is not null or undefined
            if (userOrBusinessToken === null || userOrBusinessToken === undefined) {
                throw new RequiredError('userOrBusinessToken','Required parameter userOrBusinessToken was null or undefined when calling getPeertransfersUserUserorbusinesstokenRecipient.');
            }
            const localVarPath = `/peertransfers/user/{user_or_business_token}/recipient`
                .replace(`{${"user_or_business_token"}}`, encodeURIComponent(String(userOrBusinessToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns sent peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userOrBusinessToken' is not null or undefined
            if (userOrBusinessToken === null || userOrBusinessToken === undefined) {
                throw new RequiredError('userOrBusinessToken','Required parameter userOrBusinessToken was null or undefined when calling getPeertransfersUserUserorbusinesstokenSender.');
            }
            const localVarPath = `/peertransfers/user/{user_or_business_token}/sender`
                .replace(`{${"user_or_business_token"}}`, encodeURIComponent(String(userOrBusinessToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Performs a peer transfer from one user to another
         * @param {PeerTransferRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPeertransfers(body?: PeerTransferRequest, options: any = {}): FetchArgs {
            const localVarPath = `/peertransfers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PeerTransferRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeerTransfersApi - functional programming interface
 * @export
 */
export const PeerTransfersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns details of a previous transfer
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PeerTransferResponse> {
            const localVarFetchArgs = PeerTransfersApiFetchParamCreator(configuration).getPeertransfersToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstoken(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PeerTransferResponse> {
            const localVarFetchArgs = PeerTransfersApiFetchParamCreator(configuration).getPeertransfersUserUserorbusinesstoken(userOrBusinessToken, count, startIndex, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns received peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PeerTransferResponse> {
            const localVarFetchArgs = PeerTransfersApiFetchParamCreator(configuration).getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken, count, startIndex, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns sent peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PeerTransferResponse> {
            const localVarFetchArgs = PeerTransfersApiFetchParamCreator(configuration).getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken, count, startIndex, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Performs a peer transfer from one user to another
         * @param {PeerTransferRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPeertransfers(body?: PeerTransferRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PeerTransferResponse> {
            const localVarFetchArgs = PeerTransfersApiFetchParamCreator(configuration).postPeertransfers(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PeerTransfersApi - factory interface
 * @export
 */
export const PeerTransfersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns details of a previous transfer
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersToken(token: string, options?: any) {
            return PeerTransfersApiFp(configuration).getPeertransfersToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstoken(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: any) {
            return PeerTransfersApiFp(configuration).getPeertransfersUserUserorbusinesstoken(userOrBusinessToken, count, startIndex, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns received peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: any) {
            return PeerTransfersApiFp(configuration).getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken, count, startIndex, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns sent peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: any) {
            return PeerTransfersApiFp(configuration).getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken, count, startIndex, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Performs a peer transfer from one user to another
         * @param {PeerTransferRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPeertransfers(body?: PeerTransferRequest, options?: any) {
            return PeerTransfersApiFp(configuration).postPeertransfers(body, options)(fetch, basePath);
        },
    };
};

/**
 * PeerTransfersApi - object-oriented interface
 * @export
 * @class PeerTransfersApi
 * @extends {BaseAPI}
 */
export class PeerTransfersApi extends BaseAPI {
    /**
     * 
     * @summary Returns details of a previous transfer
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeerTransfersApi
     */
    public getPeertransfersToken(token: string, options?: any) {
        return PeerTransfersApiFp(this.configuration).getPeertransfersToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all peer transfers for a user
     * @param {string} userOrBusinessToken User or business token
     * @param {number} [count] Number of transfers to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeerTransfersApi
     */
    public getPeertransfersUserUserorbusinesstoken(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: any) {
        return PeerTransfersApiFp(this.configuration).getPeertransfersUserUserorbusinesstoken(userOrBusinessToken, count, startIndex, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns received peer transfers for a user
     * @param {string} userOrBusinessToken User or business token
     * @param {number} [count] Number of transfers to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeerTransfersApi
     */
    public getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: any) {
        return PeerTransfersApiFp(this.configuration).getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken, count, startIndex, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns sent peer transfers for a user
     * @param {string} userOrBusinessToken User or business token
     * @param {number} [count] Number of transfers to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeerTransfersApi
     */
    public getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: any) {
        return PeerTransfersApiFp(this.configuration).getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken, count, startIndex, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Performs a peer transfer from one user to another
     * @param {PeerTransferRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeerTransfersApi
     */
    public postPeertransfers(body?: PeerTransferRequest, options?: any) {
        return PeerTransfersApiFp(this.configuration).postPeertransfers(body, options)(this.fetch, this.basePath);
    }

}

/**
 * PingApi - fetch parameter creator
 * @export
 */
export const PingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Tests if the Marqeta server is available and responsive.
         * @summary Returns a heartbeat to the consumer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPing(options: any = {}): FetchArgs {
            const localVarPath = `/ping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Echo test for sending payload to server
         * @param {EchoPingRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPing(body?: EchoPingRequest, options: any = {}): FetchArgs {
            const localVarPath = `/ping`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EchoPingRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PingApi - functional programming interface
 * @export
 */
export const PingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Tests if the Marqeta server is available and responsive.
         * @summary Returns a heartbeat to the consumer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPing(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PingResponse> {
            const localVarFetchArgs = PingApiFetchParamCreator(configuration).getPing(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Echo test for sending payload to server
         * @param {EchoPingRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPing(body?: EchoPingRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EchoPingResponse> {
            const localVarFetchArgs = PingApiFetchParamCreator(configuration).postPing(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PingApi - factory interface
 * @export
 */
export const PingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Tests if the Marqeta server is available and responsive.
         * @summary Returns a heartbeat to the consumer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPing(options?: any) {
            return PingApiFp(configuration).getPing(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Echo test for sending payload to server
         * @param {EchoPingRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPing(body?: EchoPingRequest, options?: any) {
            return PingApiFp(configuration).postPing(body, options)(fetch, basePath);
        },
    };
};

/**
 * PingApi - object-oriented interface
 * @export
 * @class PingApi
 * @extends {BaseAPI}
 */
export class PingApi extends BaseAPI {
    /**
     * Tests if the Marqeta server is available and responsive.
     * @summary Returns a heartbeat to the consumer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PingApi
     */
    public getPing(options?: any) {
        return PingApiFp(this.configuration).getPing(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Echo test for sending payload to server
     * @param {EchoPingRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PingApi
     */
    public postPing(body?: EchoPingRequest, options?: any) {
        return PingApiFp(this.configuration).postPing(body, options)(this.fetch, this.basePath);
    }

}

/**
 * PinsApi - fetch parameter creator
 * @export
 */
export const PinsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new control token for a PIN, for the specified card for PIN debit or ATM transactions,or to allow for a pin to be revealed to authorized callers.
         * @summary Creates a new control token for a PIN
         * @param {ControlTokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPinsControltoken(body?: ControlTokenRequest, options: any = {}): FetchArgs {
            const localVarPath = `/pins/controltoken`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ControlTokenRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a PIN identified by its control token.
         * @summary Updates the PIN control token
         * @param {PinRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPins(body?: PinRequest, options: any = {}): FetchArgs {
            const localVarPath = `/pins`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PinRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reveals pin for card associated with given control token.
         * @summary Updates the PIN-reveal control token
         * @param {PinRevealRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revealPins(body?: PinRevealRequest, options: any = {}): FetchArgs {
            const localVarPath = `/pins/reveal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PinRevealRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PinsApi - functional programming interface
 * @export
 */
export const PinsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new control token for a PIN, for the specified card for PIN debit or ATM transactions,or to allow for a pin to be revealed to authorized callers.
         * @summary Creates a new control token for a PIN
         * @param {ControlTokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPinsControltoken(body?: ControlTokenRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ControlTokenResponse> {
            const localVarFetchArgs = PinsApiFetchParamCreator(configuration).postPinsControltoken(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a PIN identified by its control token.
         * @summary Updates the PIN control token
         * @param {PinRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPins(body?: PinRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PinsApiFetchParamCreator(configuration).putPins(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reveals pin for card associated with given control token.
         * @summary Updates the PIN-reveal control token
         * @param {PinRevealRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revealPins(body?: PinRevealRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PinsApiFetchParamCreator(configuration).revealPins(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PinsApi - factory interface
 * @export
 */
export const PinsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a new control token for a PIN, for the specified card for PIN debit or ATM transactions,or to allow for a pin to be revealed to authorized callers.
         * @summary Creates a new control token for a PIN
         * @param {ControlTokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPinsControltoken(body?: ControlTokenRequest, options?: any) {
            return PinsApiFp(configuration).postPinsControltoken(body, options)(fetch, basePath);
        },
        /**
         * Updates a PIN identified by its control token.
         * @summary Updates the PIN control token
         * @param {PinRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPins(body?: PinRequest, options?: any) {
            return PinsApiFp(configuration).putPins(body, options)(fetch, basePath);
        },
        /**
         * Reveals pin for card associated with given control token.
         * @summary Updates the PIN-reveal control token
         * @param {PinRevealRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revealPins(body?: PinRevealRequest, options?: any) {
            return PinsApiFp(configuration).revealPins(body, options)(fetch, basePath);
        },
    };
};

/**
 * PinsApi - object-oriented interface
 * @export
 * @class PinsApi
 * @extends {BaseAPI}
 */
export class PinsApi extends BaseAPI {
    /**
     * Creates a new control token for a PIN, for the specified card for PIN debit or ATM transactions,or to allow for a pin to be revealed to authorized callers.
     * @summary Creates a new control token for a PIN
     * @param {ControlTokenRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public postPinsControltoken(body?: ControlTokenRequest, options?: any) {
        return PinsApiFp(this.configuration).postPinsControltoken(body, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a PIN identified by its control token.
     * @summary Updates the PIN control token
     * @param {PinRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public putPins(body?: PinRequest, options?: any) {
        return PinsApiFp(this.configuration).putPins(body, options)(this.fetch, this.basePath);
    }

    /**
     * Reveals pin for card associated with given control token.
     * @summary Updates the PIN-reveal control token
     * @param {PinRevealRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public revealPins(body?: PinRevealRequest, options?: any) {
        return PinsApiFp(this.configuration).revealPins(body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProgramReserveApi - fetch parameter creator
 * @export
 */
export const ProgramReserveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProgramReserveDepositRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(body?: ProgramReserveDepositRequest, options: any = {}): FetchArgs {
            const localVarPath = `/programreserve/deposits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProgramReserveDepositRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramReserveDeposits(count?: number, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/programreserve/deposits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the latest balance in the program reserve account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramreserveBalances(options: any = {}): FetchArgs {
            const localVarPath = `/programreserve/balances`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of program reserve transactions (credits and debits)
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [body] Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramreserveTransactions(count?: number, startIndex?: number, sortBy?: string, body?: string, options: any = {}): FetchArgs {
            const localVarPath = `/programreserve/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Credits or debits the program reserve account
         * @param {ProgramReserveTransactionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramreserveTransactions(body?: ProgramReserveTransactionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/programreserve/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProgramReserveTransactionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramReserveApi - functional programming interface
 * @export
 */
export const ProgramReserveApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProgramReserveDepositRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(body?: ProgramReserveDepositRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProgramReserveApiFetchParamCreator(configuration).deposit(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramReserveDeposits(count?: number, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProgramReserveApiFetchParamCreator(configuration).getProgramReserveDeposits(count, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the latest balance in the program reserve account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramreserveBalances(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramReserveAccountBalance> {
            const localVarFetchArgs = ProgramReserveApiFetchParamCreator(configuration).getProgramreserveBalances(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a list of program reserve transactions (credits and debits)
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [body] Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramreserveTransactions(count?: number, startIndex?: number, sortBy?: string, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramReserveTransactionListResponse> {
            const localVarFetchArgs = ProgramReserveApiFetchParamCreator(configuration).getProgramreserveTransactions(count, startIndex, sortBy, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Credits or debits the program reserve account
         * @param {ProgramReserveTransactionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramreserveTransactions(body?: ProgramReserveTransactionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramReserveTransactionResponse> {
            const localVarFetchArgs = ProgramReserveApiFetchParamCreator(configuration).postProgramreserveTransactions(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProgramReserveApi - factory interface
 * @export
 */
export const ProgramReserveApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {ProgramReserveDepositRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(body?: ProgramReserveDepositRequest, options?: any) {
            return ProgramReserveApiFp(configuration).deposit(body, options)(fetch, basePath);
        },
        /**
         * 
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramReserveDeposits(count?: number, startIndex?: number, sortBy?: string, options?: any) {
            return ProgramReserveApiFp(configuration).getProgramReserveDeposits(count, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the latest balance in the program reserve account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramreserveBalances(options?: any) {
            return ProgramReserveApiFp(configuration).getProgramreserveBalances(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a list of program reserve transactions (credits and debits)
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [body] Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramreserveTransactions(count?: number, startIndex?: number, sortBy?: string, body?: string, options?: any) {
            return ProgramReserveApiFp(configuration).getProgramreserveTransactions(count, startIndex, sortBy, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Credits or debits the program reserve account
         * @param {ProgramReserveTransactionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramreserveTransactions(body?: ProgramReserveTransactionRequest, options?: any) {
            return ProgramReserveApiFp(configuration).postProgramreserveTransactions(body, options)(fetch, basePath);
        },
    };
};

/**
 * ProgramReserveApi - object-oriented interface
 * @export
 * @class ProgramReserveApi
 * @extends {BaseAPI}
 */
export class ProgramReserveApi extends BaseAPI {
    /**
     * 
     * @param {ProgramReserveDepositRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramReserveApi
     */
    public deposit(body?: ProgramReserveDepositRequest, options?: any) {
        return ProgramReserveApiFp(this.configuration).deposit(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {number} [count] Number of items to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramReserveApi
     */
    public getProgramReserveDeposits(count?: number, startIndex?: number, sortBy?: string, options?: any) {
        return ProgramReserveApiFp(this.configuration).getProgramReserveDeposits(count, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the latest balance in the program reserve account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramReserveApi
     */
    public getProgramreserveBalances(options?: any) {
        return ProgramReserveApiFp(this.configuration).getProgramreserveBalances(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a list of program reserve transactions (credits and debits)
     * @param {number} [count] Number of items to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {string} [body] Type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramReserveApi
     */
    public getProgramreserveTransactions(count?: number, startIndex?: number, sortBy?: string, body?: string, options?: any) {
        return ProgramReserveApiFp(this.configuration).getProgramreserveTransactions(count, startIndex, sortBy, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Credits or debits the program reserve account
     * @param {ProgramReserveTransactionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramReserveApi
     */
    public postProgramreserveTransactions(body?: ProgramReserveTransactionRequest, options?: any) {
        return ProgramReserveApiFp(this.configuration).postProgramreserveTransactions(body, options)(this.fetch, this.basePath);
    }

}

/**
 * ProgramTransfersApi - fetch parameter creator
 * @export
 */
export const ProgramTransfersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all program transfers
         * @param {number} [count] Number of program transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [typeToken] Program type token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfers(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, typeToken?: string, options: any = {}): FetchArgs {
            const localVarPath = `/programtransfers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (typeToken !== undefined) {
                localVarQueryParameter['type_token'] = typeToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific program transfer
         * @param {string} token Program transfer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getProgramtransfersToken.');
            }
            const localVarPath = `/programtransfers/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all program transfer types
         * @param {number} [count] Number of program transfer types to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersTypes(count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/programtransfers/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific program transfer type
         * @param {string} typeToken Type token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersTypesTypetoken(typeToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'typeToken' is not null or undefined
            if (typeToken === null || typeToken === undefined) {
                throw new RequiredError('typeToken','Required parameter typeToken was null or undefined when calling getProgramtransfersTypesTypetoken.');
            }
            const localVarPath = `/programtransfers/types/{type_token}`
                .replace(`{${"type_token"}}`, encodeURIComponent(String(typeToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfers to a program funding source
         * @param {ProgramTransfer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramtransfers(body?: ProgramTransfer, options: any = {}): FetchArgs {
            const localVarPath = `/programtransfers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProgramTransfer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a program transfer type
         * @param {ProgramTransferTypeRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramtransfersTypes(body?: ProgramTransferTypeRequest, options: any = {}): FetchArgs {
            const localVarPath = `/programtransfers/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProgramTransferTypeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific program transfer type
         * @param {string} typeToken Type token
         * @param {ProgramTransferTypeRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProgramtransfersTypesTypetoken(typeToken: string, body?: ProgramTransferTypeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'typeToken' is not null or undefined
            if (typeToken === null || typeToken === undefined) {
                throw new RequiredError('typeToken','Required parameter typeToken was null or undefined when calling putProgramtransfersTypesTypetoken.');
            }
            const localVarPath = `/programtransfers/types/{type_token}`
                .replace(`{${"type_token"}}`, encodeURIComponent(String(typeToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProgramTransferTypeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramTransfersApi - functional programming interface
 * @export
 */
export const ProgramTransfersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all program transfers
         * @param {number} [count] Number of program transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [typeToken] Program type token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfers(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, typeToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramTransferListResponse> {
            const localVarFetchArgs = ProgramTransfersApiFetchParamCreator(configuration).getProgramtransfers(count, startIndex, fields, sortBy, userToken, businessToken, typeToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific program transfer
         * @param {string} token Program transfer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramTransferResponse> {
            const localVarFetchArgs = ProgramTransfersApiFetchParamCreator(configuration).getProgramtransfersToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all program transfer types
         * @param {number} [count] Number of program transfer types to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersTypes(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramTransferTypeListResponse> {
            const localVarFetchArgs = ProgramTransfersApiFetchParamCreator(configuration).getProgramtransfersTypes(count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific program transfer type
         * @param {string} typeToken Type token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersTypesTypetoken(typeToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramTransferTypeResponse> {
            const localVarFetchArgs = ProgramTransfersApiFetchParamCreator(configuration).getProgramtransfersTypesTypetoken(typeToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Transfers to a program funding source
         * @param {ProgramTransfer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramtransfers(body?: ProgramTransfer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramTransferResponse> {
            const localVarFetchArgs = ProgramTransfersApiFetchParamCreator(configuration).postProgramtransfers(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a program transfer type
         * @param {ProgramTransferTypeRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramtransfersTypes(body?: ProgramTransferTypeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramTransferTypeResponse> {
            const localVarFetchArgs = ProgramTransfersApiFetchParamCreator(configuration).postProgramtransfersTypes(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific program transfer type
         * @param {string} typeToken Type token
         * @param {ProgramTransferTypeRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProgramtransfersTypesTypetoken(typeToken: string, body?: ProgramTransferTypeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProgramTransferTypeResponse> {
            const localVarFetchArgs = ProgramTransfersApiFetchParamCreator(configuration).putProgramtransfersTypesTypetoken(typeToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProgramTransfersApi - factory interface
 * @export
 */
export const ProgramTransfersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all program transfers
         * @param {number} [count] Number of program transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [typeToken] Program type token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfers(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, typeToken?: string, options?: any) {
            return ProgramTransfersApiFp(configuration).getProgramtransfers(count, startIndex, fields, sortBy, userToken, businessToken, typeToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific program transfer
         * @param {string} token Program transfer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersToken(token: string, options?: any) {
            return ProgramTransfersApiFp(configuration).getProgramtransfersToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all program transfer types
         * @param {number} [count] Number of program transfer types to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersTypes(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return ProgramTransfersApiFp(configuration).getProgramtransfersTypes(count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific program transfer type
         * @param {string} typeToken Type token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersTypesTypetoken(typeToken: string, options?: any) {
            return ProgramTransfersApiFp(configuration).getProgramtransfersTypesTypetoken(typeToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Transfers to a program funding source
         * @param {ProgramTransfer} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramtransfers(body?: ProgramTransfer, options?: any) {
            return ProgramTransfersApiFp(configuration).postProgramtransfers(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a program transfer type
         * @param {ProgramTransferTypeRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramtransfersTypes(body?: ProgramTransferTypeRequest, options?: any) {
            return ProgramTransfersApiFp(configuration).postProgramtransfersTypes(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific program transfer type
         * @param {string} typeToken Type token
         * @param {ProgramTransferTypeRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProgramtransfersTypesTypetoken(typeToken: string, body?: ProgramTransferTypeRequest, options?: any) {
            return ProgramTransfersApiFp(configuration).putProgramtransfersTypesTypetoken(typeToken, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProgramTransfersApi - object-oriented interface
 * @export
 * @class ProgramTransfersApi
 * @extends {BaseAPI}
 */
export class ProgramTransfersApi extends BaseAPI {
    /**
     * 
     * @summary Lists all program transfers
     * @param {number} [count] Number of program transfers to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {string} [userToken] User token
     * @param {string} [businessToken] Business token
     * @param {string} [typeToken] Program type token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramTransfersApi
     */
    public getProgramtransfers(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, typeToken?: string, options?: any) {
        return ProgramTransfersApiFp(this.configuration).getProgramtransfers(count, startIndex, fields, sortBy, userToken, businessToken, typeToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific program transfer
     * @param {string} token Program transfer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramTransfersApi
     */
    public getProgramtransfersToken(token: string, options?: any) {
        return ProgramTransfersApiFp(this.configuration).getProgramtransfersToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all program transfer types
     * @param {number} [count] Number of program transfer types to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramTransfersApi
     */
    public getProgramtransfersTypes(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return ProgramTransfersApiFp(this.configuration).getProgramtransfersTypes(count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific program transfer type
     * @param {string} typeToken Type token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramTransfersApi
     */
    public getProgramtransfersTypesTypetoken(typeToken: string, options?: any) {
        return ProgramTransfersApiFp(this.configuration).getProgramtransfersTypesTypetoken(typeToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Transfers to a program funding source
     * @param {ProgramTransfer} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramTransfersApi
     */
    public postProgramtransfers(body?: ProgramTransfer, options?: any) {
        return ProgramTransfersApiFp(this.configuration).postProgramtransfers(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a program transfer type
     * @param {ProgramTransferTypeRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramTransfersApi
     */
    public postProgramtransfersTypes(body?: ProgramTransferTypeRequest, options?: any) {
        return ProgramTransfersApiFp(this.configuration).postProgramtransfersTypes(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific program transfer type
     * @param {string} typeToken Type token
     * @param {ProgramTransferTypeRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramTransfersApi
     */
    public putProgramtransfersTypesTypetoken(typeToken: string, body?: ProgramTransferTypeRequest, options?: any) {
        return ProgramTransfersApiFp(this.configuration).putProgramtransfersTypesTypetoken(typeToken, body, options)(this.fetch, this.basePath);
    }

}

/**
 * PushToCardApi - fetch parameter creator
 * @export
 */
export const PushToCardApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all push-to-card disbursements
         * @param {number} [count] Number of push-to-card disbursements to retrieve
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsDisburse(count?: number, fields?: string, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/pushtocards/disburse`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific push-to-card disbursement
         * @param {string} token Push-to-card disbursement token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsDisburseToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getPushtocardsDisburseToken.');
            }
            const localVarPath = `/pushtocards/disburse/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all push-to-card payment card details
         * @param {string} userToken User token
         * @param {number} [count] Number of push-to-card payment cards to retrieve
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsPaymentcard(userToken: string, count?: number, fields?: string, startIndex?: number, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userToken' is not null or undefined
            if (userToken === null || userToken === undefined) {
                throw new RequiredError('userToken','Required parameter userToken was null or undefined when calling getPushtocardsPaymentcard.');
            }
            const localVarPath = `/pushtocards/paymentcard`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific paymentcard object
         * @param {string} token Push-to-card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsPaymentcardToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getPushtocardsPaymentcardToken.');
            }
            const localVarPath = `/pushtocards/paymentcard/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiates a push-to-card money disbursement
         * @param {PushToCardDisburseRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPushtocardsDisburse(body?: PushToCardDisburseRequest, options: any = {}): FetchArgs {
            const localVarPath = `/pushtocards/disburse`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PushToCardDisburseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds an external card to which funds will be pushed
         * @param {PushToCardRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPushtocardsPaymentcard(body?: PushToCardRequest, options: any = {}): FetchArgs {
            const localVarPath = `/pushtocards/paymentcard`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PushToCardRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushToCardApi - functional programming interface
 * @export
 */
export const PushToCardApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all push-to-card disbursements
         * @param {number} [count] Number of push-to-card disbursements to retrieve
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsDisburse(count?: number, fields?: string, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PushToCardDisburseListResponse> {
            const localVarFetchArgs = PushToCardApiFetchParamCreator(configuration).getPushtocardsDisburse(count, fields, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific push-to-card disbursement
         * @param {string} token Push-to-card disbursement token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsDisburseToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PushToCardDisbursementResponse> {
            const localVarFetchArgs = PushToCardApiFetchParamCreator(configuration).getPushtocardsDisburseToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all push-to-card payment card details
         * @param {string} userToken User token
         * @param {number} [count] Number of push-to-card payment cards to retrieve
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsPaymentcard(userToken: string, count?: number, fields?: string, startIndex?: number, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PushToCardListResponse> {
            const localVarFetchArgs = PushToCardApiFetchParamCreator(configuration).getPushtocardsPaymentcard(userToken, count, fields, startIndex, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific paymentcard object
         * @param {string} token Push-to-card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsPaymentcardToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PushToCardResponse> {
            const localVarFetchArgs = PushToCardApiFetchParamCreator(configuration).getPushtocardsPaymentcardToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Initiates a push-to-card money disbursement
         * @param {PushToCardDisburseRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPushtocardsDisburse(body?: PushToCardDisburseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PushToCardDisbursementResponse> {
            const localVarFetchArgs = PushToCardApiFetchParamCreator(configuration).postPushtocardsDisburse(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds an external card to which funds will be pushed
         * @param {PushToCardRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPushtocardsPaymentcard(body?: PushToCardRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PushToCardResponse> {
            const localVarFetchArgs = PushToCardApiFetchParamCreator(configuration).postPushtocardsPaymentcard(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PushToCardApi - factory interface
 * @export
 */
export const PushToCardApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all push-to-card disbursements
         * @param {number} [count] Number of push-to-card disbursements to retrieve
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsDisburse(count?: number, fields?: string, startIndex?: number, sortBy?: string, options?: any) {
            return PushToCardApiFp(configuration).getPushtocardsDisburse(count, fields, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific push-to-card disbursement
         * @param {string} token Push-to-card disbursement token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsDisburseToken(token: string, fields?: string, options?: any) {
            return PushToCardApiFp(configuration).getPushtocardsDisburseToken(token, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all push-to-card payment card details
         * @param {string} userToken User token
         * @param {number} [count] Number of push-to-card payment cards to retrieve
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsPaymentcard(userToken: string, count?: number, fields?: string, startIndex?: number, sortBy?: string, options?: any) {
            return PushToCardApiFp(configuration).getPushtocardsPaymentcard(userToken, count, fields, startIndex, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific paymentcard object
         * @param {string} token Push-to-card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsPaymentcardToken(token: string, fields?: string, options?: any) {
            return PushToCardApiFp(configuration).getPushtocardsPaymentcardToken(token, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Initiates a push-to-card money disbursement
         * @param {PushToCardDisburseRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPushtocardsDisburse(body?: PushToCardDisburseRequest, options?: any) {
            return PushToCardApiFp(configuration).postPushtocardsDisburse(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds an external card to which funds will be pushed
         * @param {PushToCardRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPushtocardsPaymentcard(body?: PushToCardRequest, options?: any) {
            return PushToCardApiFp(configuration).postPushtocardsPaymentcard(body, options)(fetch, basePath);
        },
    };
};

/**
 * PushToCardApi - object-oriented interface
 * @export
 * @class PushToCardApi
 * @extends {BaseAPI}
 */
export class PushToCardApi extends BaseAPI {
    /**
     * 
     * @summary Lists all push-to-card disbursements
     * @param {number} [count] Number of push-to-card disbursements to retrieve
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushToCardApi
     */
    public getPushtocardsDisburse(count?: number, fields?: string, startIndex?: number, sortBy?: string, options?: any) {
        return PushToCardApiFp(this.configuration).getPushtocardsDisburse(count, fields, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific push-to-card disbursement
     * @param {string} token Push-to-card disbursement token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushToCardApi
     */
    public getPushtocardsDisburseToken(token: string, fields?: string, options?: any) {
        return PushToCardApiFp(this.configuration).getPushtocardsDisburseToken(token, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all push-to-card payment card details
     * @param {string} userToken User token
     * @param {number} [count] Number of push-to-card payment cards to retrieve
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushToCardApi
     */
    public getPushtocardsPaymentcard(userToken: string, count?: number, fields?: string, startIndex?: number, sortBy?: string, options?: any) {
        return PushToCardApiFp(this.configuration).getPushtocardsPaymentcard(userToken, count, fields, startIndex, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific paymentcard object
     * @param {string} token Push-to-card token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushToCardApi
     */
    public getPushtocardsPaymentcardToken(token: string, fields?: string, options?: any) {
        return PushToCardApiFp(this.configuration).getPushtocardsPaymentcardToken(token, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Initiates a push-to-card money disbursement
     * @param {PushToCardDisburseRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushToCardApi
     */
    public postPushtocardsDisburse(body?: PushToCardDisburseRequest, options?: any) {
        return PushToCardApiFp(this.configuration).postPushtocardsDisburse(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds an external card to which funds will be pushed
     * @param {PushToCardRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushToCardApi
     */
    public postPushtocardsPaymentcard(body?: PushToCardRequest, options?: any) {
        return PushToCardApiFp(this.configuration).postPushtocardsPaymentcard(body, options)(this.fetch, this.basePath);
    }

}

/**
 * RealTimeFeeGroupsApi - fetch parameter creator
 * @export
 */
export const RealTimeFeeGroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all real-time fee groups
         * @param {number} [count] Number of real-time fee groups to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimefeegroups(count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/realtimefeegroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific real-time fee group
         * @param {string} token Real-time fee group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimefeegroupsToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getRealtimefeegroupsToken.');
            }
            const localVarPath = `/realtimefeegroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a real-time fee group
         * @param {RealTimeFeeGroupCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRealtimefeegroups(body?: RealTimeFeeGroupCreateRequest, options: any = {}): FetchArgs {
            const localVarPath = `/realtimefeegroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RealTimeFeeGroupCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific real-time fee group
         * @param {string} token Real-time fee group token
         * @param {RealTimeFeeGroupRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRealtimefeegroupsToken(token: string, body?: RealTimeFeeGroupRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putRealtimefeegroupsToken.');
            }
            const localVarPath = `/realtimefeegroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RealTimeFeeGroupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealTimeFeeGroupsApi - functional programming interface
 * @export
 */
export const RealTimeFeeGroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all real-time fee groups
         * @param {number} [count] Number of real-time fee groups to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimefeegroups(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RealTimeFeeGroupListResponse> {
            const localVarFetchArgs = RealTimeFeeGroupsApiFetchParamCreator(configuration).getRealtimefeegroups(count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific real-time fee group
         * @param {string} token Real-time fee group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimefeegroupsToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RealTimeFeeGroup> {
            const localVarFetchArgs = RealTimeFeeGroupsApiFetchParamCreator(configuration).getRealtimefeegroupsToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a real-time fee group
         * @param {RealTimeFeeGroupCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRealtimefeegroups(body?: RealTimeFeeGroupCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RealTimeFeeGroup> {
            const localVarFetchArgs = RealTimeFeeGroupsApiFetchParamCreator(configuration).postRealtimefeegroups(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific real-time fee group
         * @param {string} token Real-time fee group token
         * @param {RealTimeFeeGroupRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRealtimefeegroupsToken(token: string, body?: RealTimeFeeGroupRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RealTimeFeeGroup> {
            const localVarFetchArgs = RealTimeFeeGroupsApiFetchParamCreator(configuration).putRealtimefeegroupsToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RealTimeFeeGroupsApi - factory interface
 * @export
 */
export const RealTimeFeeGroupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all real-time fee groups
         * @param {number} [count] Number of real-time fee groups to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimefeegroups(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return RealTimeFeeGroupsApiFp(configuration).getRealtimefeegroups(count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific real-time fee group
         * @param {string} token Real-time fee group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimefeegroupsToken(token: string, options?: any) {
            return RealTimeFeeGroupsApiFp(configuration).getRealtimefeegroupsToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a real-time fee group
         * @param {RealTimeFeeGroupCreateRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRealtimefeegroups(body?: RealTimeFeeGroupCreateRequest, options?: any) {
            return RealTimeFeeGroupsApiFp(configuration).postRealtimefeegroups(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific real-time fee group
         * @param {string} token Real-time fee group token
         * @param {RealTimeFeeGroupRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRealtimefeegroupsToken(token: string, body?: RealTimeFeeGroupRequest, options?: any) {
            return RealTimeFeeGroupsApiFp(configuration).putRealtimefeegroupsToken(token, body, options)(fetch, basePath);
        },
    };
};

/**
 * RealTimeFeeGroupsApi - object-oriented interface
 * @export
 * @class RealTimeFeeGroupsApi
 * @extends {BaseAPI}
 */
export class RealTimeFeeGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all real-time fee groups
     * @param {number} [count] Number of real-time fee groups to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealTimeFeeGroupsApi
     */
    public getRealtimefeegroups(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return RealTimeFeeGroupsApiFp(this.configuration).getRealtimefeegroups(count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific real-time fee group
     * @param {string} token Real-time fee group token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealTimeFeeGroupsApi
     */
    public getRealtimefeegroupsToken(token: string, options?: any) {
        return RealTimeFeeGroupsApiFp(this.configuration).getRealtimefeegroupsToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a real-time fee group
     * @param {RealTimeFeeGroupCreateRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealTimeFeeGroupsApi
     */
    public postRealtimefeegroups(body?: RealTimeFeeGroupCreateRequest, options?: any) {
        return RealTimeFeeGroupsApiFp(this.configuration).postRealtimefeegroups(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific real-time fee group
     * @param {string} token Real-time fee group token
     * @param {RealTimeFeeGroupRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RealTimeFeeGroupsApi
     */
    public putRealtimefeegroupsToken(token: string, body?: RealTimeFeeGroupRequest, options?: any) {
        return RealTimeFeeGroupsApiFp(this.configuration).putRealtimefeegroupsToken(token, body, options)(this.fetch, this.basePath);
    }

}

/**
 * SimulateApi - fetch parameter creator
 * @export
 */
export const SimulateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Simulates an authorization
         * @param {AuthRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateAuthorization(body?: AuthRequestModel, options: any = {}): FetchArgs {
            const localVarPath = `/simulate/authorization`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates an authorization advice transaction
         * @param {AuthorizationAdviceModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateAuthorizationAdvice(body?: AuthorizationAdviceModel, options: any = {}): FetchArgs {
            const localVarPath = `/simulate/authorization/advice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthorizationAdviceModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates a clearing/settlement transaction
         * @param {ClearingModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateClearing(body?: ClearingModel, options: any = {}): FetchArgs {
            const localVarPath = `/simulate/clearing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ClearingModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates the creation of direct deposit
         * @param {DirectDepositRequest} body Direct deposit simulate request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateDirectdeposits(body: DirectDepositRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSimulateDirectdeposits.');
            }
            const localVarPath = `/simulate/directdeposits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DirectDepositRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates a financial request (PIN debit) transaction with optional cash back
         * @param {FinancialRequestModel} body Financial request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancial(body: FinancialRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSimulateFinancial.');
            }
            const localVarPath = `/simulate/financial`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FinancialRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates a financial advice transaction
         * @param {AuthorizationAdviceModel} body Financial advice request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialAdvice(body: AuthorizationAdviceModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSimulateFinancialAdvice.');
            }
            const localVarPath = `/simulate/financial/advice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthorizationAdviceModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates a balance inquiry
         * @param {BalanceInquiryRequestModel} body Balance inquiry request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialBalanceinquiry(body: BalanceInquiryRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSimulateFinancialBalanceinquiry.');
            }
            const localVarPath = `/simulate/financial/balanceinquiry`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BalanceInquiryRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates an orignal credit transaction
         * @param {OrignalcreditRequestModel} body Orignal Credit request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialOriginalcredit(body: OrignalcreditRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSimulateFinancialOriginalcredit.');
            }
            const localVarPath = `/simulate/financial/originalcredit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrignalcreditRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates an ATM withdrawal transaction
         * @param {WithdrawalRequestModel} body ATM withdrawal request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialWithdrawal(body: WithdrawalRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSimulateFinancialWithdrawal.');
            }
            const localVarPath = `/simulate/financial/withdrawal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WithdrawalRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates a reversal transaction
         * @param {ReversalModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateReversal(body?: ReversalModel, options: any = {}): FetchArgs {
            const localVarPath = `/simulate/reversal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReversalModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimulateApi - functional programming interface
 * @export
 */
export const SimulateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Simulates an authorization
         * @param {AuthRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateAuthorization(body?: AuthRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationResponseModel> {
            const localVarFetchArgs = SimulateApiFetchParamCreator(configuration).postSimulateAuthorization(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Simulates an authorization advice transaction
         * @param {AuthorizationAdviceModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateAuthorizationAdvice(body?: AuthorizationAdviceModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationResponseModel> {
            const localVarFetchArgs = SimulateApiFetchParamCreator(configuration).postSimulateAuthorizationAdvice(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Simulates a clearing/settlement transaction
         * @param {ClearingModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateClearing(body?: ClearingModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationResponseModel> {
            const localVarFetchArgs = SimulateApiFetchParamCreator(configuration).postSimulateClearing(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Simulates the creation of direct deposit
         * @param {DirectDepositRequest} body Direct deposit simulate request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateDirectdeposits(body: DirectDepositRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DepositDepositResponse> {
            const localVarFetchArgs = SimulateApiFetchParamCreator(configuration).postSimulateDirectdeposits(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Simulates a financial request (PIN debit) transaction with optional cash back
         * @param {FinancialRequestModel} body Financial request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancial(body: FinancialRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationResponseModel> {
            const localVarFetchArgs = SimulateApiFetchParamCreator(configuration).postSimulateFinancial(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Simulates a financial advice transaction
         * @param {AuthorizationAdviceModel} body Financial advice request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialAdvice(body: AuthorizationAdviceModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationResponseModel> {
            const localVarFetchArgs = SimulateApiFetchParamCreator(configuration).postSimulateFinancialAdvice(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Simulates a balance inquiry
         * @param {BalanceInquiryRequestModel} body Balance inquiry request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialBalanceinquiry(body: BalanceInquiryRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationResponseModel> {
            const localVarFetchArgs = SimulateApiFetchParamCreator(configuration).postSimulateFinancialBalanceinquiry(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Simulates an orignal credit transaction
         * @param {OrignalcreditRequestModel} body Orignal Credit request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialOriginalcredit(body: OrignalcreditRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationResponseModel> {
            const localVarFetchArgs = SimulateApiFetchParamCreator(configuration).postSimulateFinancialOriginalcredit(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Simulates an ATM withdrawal transaction
         * @param {WithdrawalRequestModel} body ATM withdrawal request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialWithdrawal(body: WithdrawalRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationResponseModel> {
            const localVarFetchArgs = SimulateApiFetchParamCreator(configuration).postSimulateFinancialWithdrawal(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Simulates a reversal transaction
         * @param {ReversalModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateReversal(body?: ReversalModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimulationResponseModel> {
            const localVarFetchArgs = SimulateApiFetchParamCreator(configuration).postSimulateReversal(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SimulateApi - factory interface
 * @export
 */
export const SimulateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Simulates an authorization
         * @param {AuthRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateAuthorization(body?: AuthRequestModel, options?: any) {
            return SimulateApiFp(configuration).postSimulateAuthorization(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Simulates an authorization advice transaction
         * @param {AuthorizationAdviceModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateAuthorizationAdvice(body?: AuthorizationAdviceModel, options?: any) {
            return SimulateApiFp(configuration).postSimulateAuthorizationAdvice(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Simulates a clearing/settlement transaction
         * @param {ClearingModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateClearing(body?: ClearingModel, options?: any) {
            return SimulateApiFp(configuration).postSimulateClearing(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Simulates the creation of direct deposit
         * @param {DirectDepositRequest} body Direct deposit simulate request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateDirectdeposits(body: DirectDepositRequest, options?: any) {
            return SimulateApiFp(configuration).postSimulateDirectdeposits(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Simulates a financial request (PIN debit) transaction with optional cash back
         * @param {FinancialRequestModel} body Financial request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancial(body: FinancialRequestModel, options?: any) {
            return SimulateApiFp(configuration).postSimulateFinancial(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Simulates a financial advice transaction
         * @param {AuthorizationAdviceModel} body Financial advice request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialAdvice(body: AuthorizationAdviceModel, options?: any) {
            return SimulateApiFp(configuration).postSimulateFinancialAdvice(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Simulates a balance inquiry
         * @param {BalanceInquiryRequestModel} body Balance inquiry request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialBalanceinquiry(body: BalanceInquiryRequestModel, options?: any) {
            return SimulateApiFp(configuration).postSimulateFinancialBalanceinquiry(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Simulates an orignal credit transaction
         * @param {OrignalcreditRequestModel} body Orignal Credit request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialOriginalcredit(body: OrignalcreditRequestModel, options?: any) {
            return SimulateApiFp(configuration).postSimulateFinancialOriginalcredit(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Simulates an ATM withdrawal transaction
         * @param {WithdrawalRequestModel} body ATM withdrawal request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialWithdrawal(body: WithdrawalRequestModel, options?: any) {
            return SimulateApiFp(configuration).postSimulateFinancialWithdrawal(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Simulates a reversal transaction
         * @param {ReversalModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateReversal(body?: ReversalModel, options?: any) {
            return SimulateApiFp(configuration).postSimulateReversal(body, options)(fetch, basePath);
        },
    };
};

/**
 * SimulateApi - object-oriented interface
 * @export
 * @class SimulateApi
 * @extends {BaseAPI}
 */
export class SimulateApi extends BaseAPI {
    /**
     * 
     * @summary Simulates an authorization
     * @param {AuthRequestModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulateApi
     */
    public postSimulateAuthorization(body?: AuthRequestModel, options?: any) {
        return SimulateApiFp(this.configuration).postSimulateAuthorization(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Simulates an authorization advice transaction
     * @param {AuthorizationAdviceModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulateApi
     */
    public postSimulateAuthorizationAdvice(body?: AuthorizationAdviceModel, options?: any) {
        return SimulateApiFp(this.configuration).postSimulateAuthorizationAdvice(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Simulates a clearing/settlement transaction
     * @param {ClearingModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulateApi
     */
    public postSimulateClearing(body?: ClearingModel, options?: any) {
        return SimulateApiFp(this.configuration).postSimulateClearing(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Simulates the creation of direct deposit
     * @param {DirectDepositRequest} body Direct deposit simulate request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulateApi
     */
    public postSimulateDirectdeposits(body: DirectDepositRequest, options?: any) {
        return SimulateApiFp(this.configuration).postSimulateDirectdeposits(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Simulates a financial request (PIN debit) transaction with optional cash back
     * @param {FinancialRequestModel} body Financial request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulateApi
     */
    public postSimulateFinancial(body: FinancialRequestModel, options?: any) {
        return SimulateApiFp(this.configuration).postSimulateFinancial(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Simulates a financial advice transaction
     * @param {AuthorizationAdviceModel} body Financial advice request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulateApi
     */
    public postSimulateFinancialAdvice(body: AuthorizationAdviceModel, options?: any) {
        return SimulateApiFp(this.configuration).postSimulateFinancialAdvice(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Simulates a balance inquiry
     * @param {BalanceInquiryRequestModel} body Balance inquiry request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulateApi
     */
    public postSimulateFinancialBalanceinquiry(body: BalanceInquiryRequestModel, options?: any) {
        return SimulateApiFp(this.configuration).postSimulateFinancialBalanceinquiry(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Simulates an orignal credit transaction
     * @param {OrignalcreditRequestModel} body Orignal Credit request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulateApi
     */
    public postSimulateFinancialOriginalcredit(body: OrignalcreditRequestModel, options?: any) {
        return SimulateApiFp(this.configuration).postSimulateFinancialOriginalcredit(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Simulates an ATM withdrawal transaction
     * @param {WithdrawalRequestModel} body ATM withdrawal request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulateApi
     */
    public postSimulateFinancialWithdrawal(body: WithdrawalRequestModel, options?: any) {
        return SimulateApiFp(this.configuration).postSimulateFinancialWithdrawal(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Simulates a reversal transaction
     * @param {ReversalModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulateApi
     */
    public postSimulateReversal(body?: ReversalModel, options?: any) {
        return SimulateApiFp(this.configuration).postSimulateReversal(body, options)(this.fetch, this.basePath);
    }

}

/**
 * TransactionsApi - fetch parameter creator
 * @export
 */
export const TransactionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns transactions
         * @param {number} [count] Number of transactions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {'-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time'} [sortBy] Sort order
         * @param {string} [startDate] Start date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
         * @param {string} [endDate] End date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
         * @param {string} [type] Comma-delimited list of transaction types to include
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [actingUserToken] Acting user token
         * @param {string} [cardToken] Card token
         * @param {string} [merchantToken] Merchant token
         * @param {string} [campaignToken] Campaign token
         * @param {string} [state] Comma-delimited list of transaction states to display e.g. PENDING | CLEARED | COMPLETION | DECLINED | ERROR | ALL
         * @param {string} [version] 
         * @param {boolean} [verbose] 
         * @param {number} [startIdentifier] Start identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(count?: number, startIndex?: number, fields?: string, sortBy?: '-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time', startDate?: string, endDate?: string, type?: string, userToken?: string, businessToken?: string, actingUserToken?: string, cardToken?: string, merchantToken?: string, campaignToken?: string, state?: string, version?: string, verbose?: boolean, startIdentifier?: number, options: any = {}): FetchArgs {
            const localVarPath = `/transactions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (actingUserToken !== undefined) {
                localVarQueryParameter['acting_user_token'] = actingUserToken;
            }

            if (cardToken !== undefined) {
                localVarQueryParameter['card_token'] = cardToken;
            }

            if (merchantToken !== undefined) {
                localVarQueryParameter['merchant_token'] = merchantToken;
            }

            if (campaignToken !== undefined) {
                localVarQueryParameter['campaign_token'] = campaignToken;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (verbose !== undefined) {
                localVarQueryParameter['verbose'] = verbose;
            }

            if (startIdentifier !== undefined) {
                localVarQueryParameter['start_identifier'] = startIdentifier;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns transactions for a specific funding account
         * @param {string} fundingSourceToken Funding account token
         * @param {number} [count] Number of transactions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {'-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time'} [sortBy] Sort order
         * @param {string} [startDate] Start date (yyyy-MM-dd)
         * @param {string} [endDate] End date (yyyy-MM-dd)
         * @param {string} [type] Comma-delimited list of transaction types to include
         * @param {'CREDIT' | 'DEBIT' | 'PENDING_CREDIT' | 'PENDING_DEBIT'} [polarity] Type of transactions to retrieve: CREDIT or DEBIT
         * @param {string} [version] 
         * @param {boolean} [verbose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: '-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time', startDate?: string, endDate?: string, type?: string, polarity?: 'CREDIT' | 'DEBIT' | 'PENDING_CREDIT' | 'PENDING_DEBIT', version?: string, verbose?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            if (fundingSourceToken === null || fundingSourceToken === undefined) {
                throw new RequiredError('fundingSourceToken','Required parameter fundingSourceToken was null or undefined when calling getTransactionsFundingsourceFundingsourcetoken.');
            }
            const localVarPath = `/transactions/fundingsource/{funding_source_token}`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (polarity !== undefined) {
                localVarQueryParameter['polarity'] = polarity;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (verbose !== undefined) {
                localVarQueryParameter['verbose'] = verbose;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a transaction
         * @param {string} token Transaction token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [version] 
         * @param {boolean} [verbose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsToken(token: string, fields?: string, version?: string, verbose?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getTransactionsToken.');
            }
            const localVarPath = `/transactions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (verbose !== undefined) {
                localVarQueryParameter['verbose'] = verbose;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns related transactions
         * @param {string} token Transaction token
         * @param {number} [count] Number of transactions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {'-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time'} [sortBy] Sort order
         * @param {string} [startDate] Start date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
         * @param {string} [endDate] End date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
         * @param {string} [type] Comma-delimited list of transaction types to include
         * @param {string} [state] Comma-delimited list of transaction states to display e.g. PENDING | CLEARED | COMPLETION | ALL
         * @param {string} [version] 
         * @param {boolean} [verbose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsTokenRelated(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: '-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time', startDate?: string, endDate?: string, type?: string, state?: string, version?: string, verbose?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getTransactionsTokenRelated.');
            }
            const localVarPath = `/transactions/{token}/related`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (verbose !== undefined) {
                localVarQueryParameter['verbose'] = verbose;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns transactions
         * @param {number} [count] Number of transactions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {'-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time'} [sortBy] Sort order
         * @param {string} [startDate] Start date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
         * @param {string} [endDate] End date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
         * @param {string} [type] Comma-delimited list of transaction types to include
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [actingUserToken] Acting user token
         * @param {string} [cardToken] Card token
         * @param {string} [merchantToken] Merchant token
         * @param {string} [campaignToken] Campaign token
         * @param {string} [state] Comma-delimited list of transaction states to display e.g. PENDING | CLEARED | COMPLETION | DECLINED | ERROR | ALL
         * @param {string} [version] 
         * @param {boolean} [verbose] 
         * @param {number} [startIdentifier] Start identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(count?: number, startIndex?: number, fields?: string, sortBy?: '-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time', startDate?: string, endDate?: string, type?: string, userToken?: string, businessToken?: string, actingUserToken?: string, cardToken?: string, merchantToken?: string, campaignToken?: string, state?: string, version?: string, verbose?: boolean, startIdentifier?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionModelListResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactions(count, startIndex, fields, sortBy, startDate, endDate, type, userToken, businessToken, actingUserToken, cardToken, merchantToken, campaignToken, state, version, verbose, startIdentifier, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns transactions for a specific funding account
         * @param {string} fundingSourceToken Funding account token
         * @param {number} [count] Number of transactions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {'-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time'} [sortBy] Sort order
         * @param {string} [startDate] Start date (yyyy-MM-dd)
         * @param {string} [endDate] End date (yyyy-MM-dd)
         * @param {string} [type] Comma-delimited list of transaction types to include
         * @param {'CREDIT' | 'DEBIT' | 'PENDING_CREDIT' | 'PENDING_DEBIT'} [polarity] Type of transactions to retrieve: CREDIT or DEBIT
         * @param {string} [version] 
         * @param {boolean} [verbose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: '-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time', startDate?: string, endDate?: string, type?: string, polarity?: 'CREDIT' | 'DEBIT' | 'PENDING_CREDIT' | 'PENDING_DEBIT', version?: string, verbose?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionModelListResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken, count, startIndex, fields, sortBy, startDate, endDate, type, polarity, version, verbose, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a transaction
         * @param {string} token Transaction token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [version] 
         * @param {boolean} [verbose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsToken(token: string, fields?: string, version?: string, verbose?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionModel> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionsToken(token, fields, version, verbose, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns related transactions
         * @param {string} token Transaction token
         * @param {number} [count] Number of transactions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {'-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time'} [sortBy] Sort order
         * @param {string} [startDate] Start date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
         * @param {string} [endDate] End date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
         * @param {string} [type] Comma-delimited list of transaction types to include
         * @param {string} [state] Comma-delimited list of transaction states to display e.g. PENDING | CLEARED | COMPLETION | ALL
         * @param {string} [version] 
         * @param {boolean} [verbose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsTokenRelated(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: '-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time', startDate?: string, endDate?: string, type?: string, state?: string, version?: string, verbose?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionModelListResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionsTokenRelated(token, count, startIndex, fields, sortBy, startDate, endDate, type, state, version, verbose, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns transactions
         * @param {number} [count] Number of transactions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {'-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time'} [sortBy] Sort order
         * @param {string} [startDate] Start date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
         * @param {string} [endDate] End date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
         * @param {string} [type] Comma-delimited list of transaction types to include
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [actingUserToken] Acting user token
         * @param {string} [cardToken] Card token
         * @param {string} [merchantToken] Merchant token
         * @param {string} [campaignToken] Campaign token
         * @param {string} [state] Comma-delimited list of transaction states to display e.g. PENDING | CLEARED | COMPLETION | DECLINED | ERROR | ALL
         * @param {string} [version] 
         * @param {boolean} [verbose] 
         * @param {number} [startIdentifier] Start identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(count?: number, startIndex?: number, fields?: string, sortBy?: '-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time', startDate?: string, endDate?: string, type?: string, userToken?: string, businessToken?: string, actingUserToken?: string, cardToken?: string, merchantToken?: string, campaignToken?: string, state?: string, version?: string, verbose?: boolean, startIdentifier?: number, options?: any) {
            return TransactionsApiFp(configuration).getTransactions(count, startIndex, fields, sortBy, startDate, endDate, type, userToken, businessToken, actingUserToken, cardToken, merchantToken, campaignToken, state, version, verbose, startIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns transactions for a specific funding account
         * @param {string} fundingSourceToken Funding account token
         * @param {number} [count] Number of transactions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {'-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time'} [sortBy] Sort order
         * @param {string} [startDate] Start date (yyyy-MM-dd)
         * @param {string} [endDate] End date (yyyy-MM-dd)
         * @param {string} [type] Comma-delimited list of transaction types to include
         * @param {'CREDIT' | 'DEBIT' | 'PENDING_CREDIT' | 'PENDING_DEBIT'} [polarity] Type of transactions to retrieve: CREDIT or DEBIT
         * @param {string} [version] 
         * @param {boolean} [verbose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: '-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time', startDate?: string, endDate?: string, type?: string, polarity?: 'CREDIT' | 'DEBIT' | 'PENDING_CREDIT' | 'PENDING_DEBIT', version?: string, verbose?: boolean, options?: any) {
            return TransactionsApiFp(configuration).getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken, count, startIndex, fields, sortBy, startDate, endDate, type, polarity, version, verbose, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a transaction
         * @param {string} token Transaction token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [version] 
         * @param {boolean} [verbose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsToken(token: string, fields?: string, version?: string, verbose?: boolean, options?: any) {
            return TransactionsApiFp(configuration).getTransactionsToken(token, fields, version, verbose, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns related transactions
         * @param {string} token Transaction token
         * @param {number} [count] Number of transactions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {'-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time'} [sortBy] Sort order
         * @param {string} [startDate] Start date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
         * @param {string} [endDate] End date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
         * @param {string} [type] Comma-delimited list of transaction types to include
         * @param {string} [state] Comma-delimited list of transaction states to display e.g. PENDING | CLEARED | COMPLETION | ALL
         * @param {string} [version] 
         * @param {boolean} [verbose] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsTokenRelated(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: '-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time', startDate?: string, endDate?: string, type?: string, state?: string, version?: string, verbose?: boolean, options?: any) {
            return TransactionsApiFp(configuration).getTransactionsTokenRelated(token, count, startIndex, fields, sortBy, startDate, endDate, type, state, version, verbose, options)(fetch, basePath);
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * 
     * @summary Returns transactions
     * @param {number} [count] Number of transactions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {'-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time'} [sortBy] Sort order
     * @param {string} [startDate] Start date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
     * @param {string} [endDate] End date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
     * @param {string} [type] Comma-delimited list of transaction types to include
     * @param {string} [userToken] User token
     * @param {string} [businessToken] Business token
     * @param {string} [actingUserToken] Acting user token
     * @param {string} [cardToken] Card token
     * @param {string} [merchantToken] Merchant token
     * @param {string} [campaignToken] Campaign token
     * @param {string} [state] Comma-delimited list of transaction states to display e.g. PENDING | CLEARED | COMPLETION | DECLINED | ERROR | ALL
     * @param {string} [version] 
     * @param {boolean} [verbose] 
     * @param {number} [startIdentifier] Start identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactions(count?: number, startIndex?: number, fields?: string, sortBy?: '-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time', startDate?: string, endDate?: string, type?: string, userToken?: string, businessToken?: string, actingUserToken?: string, cardToken?: string, merchantToken?: string, campaignToken?: string, state?: string, version?: string, verbose?: boolean, startIdentifier?: number, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactions(count, startIndex, fields, sortBy, startDate, endDate, type, userToken, businessToken, actingUserToken, cardToken, merchantToken, campaignToken, state, version, verbose, startIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns transactions for a specific funding account
     * @param {string} fundingSourceToken Funding account token
     * @param {number} [count] Number of transactions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {'-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time'} [sortBy] Sort order
     * @param {string} [startDate] Start date (yyyy-MM-dd)
     * @param {string} [endDate] End date (yyyy-MM-dd)
     * @param {string} [type] Comma-delimited list of transaction types to include
     * @param {'CREDIT' | 'DEBIT' | 'PENDING_CREDIT' | 'PENDING_DEBIT'} [polarity] Type of transactions to retrieve: CREDIT or DEBIT
     * @param {string} [version] 
     * @param {boolean} [verbose] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: '-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time', startDate?: string, endDate?: string, type?: string, polarity?: 'CREDIT' | 'DEBIT' | 'PENDING_CREDIT' | 'PENDING_DEBIT', version?: string, verbose?: boolean, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken, count, startIndex, fields, sortBy, startDate, endDate, type, polarity, version, verbose, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a transaction
     * @param {string} token Transaction token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [version] 
     * @param {boolean} [verbose] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsToken(token: string, fields?: string, version?: string, verbose?: boolean, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionsToken(token, fields, version, verbose, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns related transactions
     * @param {string} token Transaction token
     * @param {number} [count] Number of transactions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {'-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time'} [sortBy] Sort order
     * @param {string} [startDate] Start date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
     * @param {string} [endDate] End date (yyyy-MM-dd | yyyy-MM-ddTHH:mm:ss.SS)
     * @param {string} [type] Comma-delimited list of transaction types to include
     * @param {string} [state] Comma-delimited list of transaction states to display e.g. PENDING | CLEARED | COMPLETION | ALL
     * @param {string} [version] 
     * @param {boolean} [verbose] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsTokenRelated(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: '-created_time' | 'created_time' | '-user_transaction_time' | 'user_transaction_time', startDate?: string, endDate?: string, type?: string, state?: string, version?: string, verbose?: boolean, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionsTokenRelated(token, count, startIndex, fields, sortBy, startDate, endDate, type, state, version, verbose, options)(this.fetch, this.basePath);
    }

}

/**
 * UserTransitionsApi - fetch parameter creator
 * @export
 */
export const UserTransitionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a user transition
         * @param {string} token Transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsertransitionsToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getUsertransitionsToken.');
            }
            const localVarPath = `/usertransitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns transitions for a specific user
         * @param {string} userToken User token
         * @param {number} [count] Number of user transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsertransitionsUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userToken' is not null or undefined
            if (userToken === null || userToken === undefined) {
                throw new RequiredError('userToken','Required parameter userToken was null or undefined when calling getUsertransitionsUserUsertoken.');
            }
            const localVarPath = `/usertransitions/user/{user_token}`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a user transition
         * @param {UserTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsertransitions(body?: UserTransitionRequest, options: any = {}): FetchArgs {
            const localVarPath = `/usertransitions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserTransitionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserTransitionsApi - functional programming interface
 * @export
 */
export const UserTransitionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a user transition
         * @param {string} token Transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsertransitionsToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserTransitionResponse> {
            const localVarFetchArgs = UserTransitionsApiFetchParamCreator(configuration).getUsertransitionsToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns transitions for a specific user
         * @param {string} userToken User token
         * @param {number} [count] Number of user transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsertransitionsUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserTransitionListResponse> {
            const localVarFetchArgs = UserTransitionsApiFetchParamCreator(configuration).getUsertransitionsUserUsertoken(userToken, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a user transition
         * @param {UserTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsertransitions(body?: UserTransitionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserTransitionResponse> {
            const localVarFetchArgs = UserTransitionsApiFetchParamCreator(configuration).postUsertransitions(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserTransitionsApi - factory interface
 * @export
 */
export const UserTransitionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns a user transition
         * @param {string} token Transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsertransitionsToken(token: string, fields?: string, options?: any) {
            return UserTransitionsApiFp(configuration).getUsertransitionsToken(token, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns transitions for a specific user
         * @param {string} userToken User token
         * @param {number} [count] Number of user transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsertransitionsUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return UserTransitionsApiFp(configuration).getUsertransitionsUserUsertoken(userToken, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a user transition
         * @param {UserTransitionRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsertransitions(body?: UserTransitionRequest, options?: any) {
            return UserTransitionsApiFp(configuration).postUsertransitions(body, options)(fetch, basePath);
        },
    };
};

/**
 * UserTransitionsApi - object-oriented interface
 * @export
 * @class UserTransitionsApi
 * @extends {BaseAPI}
 */
export class UserTransitionsApi extends BaseAPI {
    /**
     * 
     * @summary Returns a user transition
     * @param {string} token Transition token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTransitionsApi
     */
    public getUsertransitionsToken(token: string, fields?: string, options?: any) {
        return UserTransitionsApiFp(this.configuration).getUsertransitionsToken(token, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns transitions for a specific user
     * @param {string} userToken User token
     * @param {number} [count] Number of user transitions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTransitionsApi
     */
    public getUsertransitionsUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return UserTransitionsApiFp(this.configuration).getUsertransitionsUserUsertoken(userToken, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a user transition
     * @param {UserTransitionRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTransitionsApi
     */
    public postUsertransitions(body?: UserTransitionRequest, options?: any) {
        return UserTransitionsApiFp(this.configuration).postUsertransitions(body, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all users
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a client access token
         * @param {string} token Client access token
         * @param {string} [applicationToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAuthClientaccesstokenToken(token: string, applicationToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getUsersAuthClientaccesstokenToken.');
            }
            const localVarPath = `/users/auth/clientaccesstoken/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applicationToken !== undefined) {
                localVarQueryParameter['application_token'] = applicationToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all children of a parent user
         * @param {string} parentToken Token of parent cardholder
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'parentToken' is not null or undefined
            if (parentToken === null || parentToken === undefined) {
                throw new RequiredError('parentToken','Required parameter parentToken was null or undefined when calling getUsersParenttokenChildren.');
            }
            const localVarPath = `/users/{parent_token}/children`
                .replace(`{${"parent_token"}}`, encodeURIComponent(String(parentToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all users who match a phone number
         * @param {string} phoneNumber Phone number
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPhonenumberPhonenumber(phoneNumber: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'phoneNumber' is not null or undefined
            if (phoneNumber === null || phoneNumber === undefined) {
                throw new RequiredError('phoneNumber','Required parameter phoneNumber was null or undefined when calling getUsersPhonenumberPhonenumber.');
            }
            const localVarPath = `/users/phonenumber/{phone_number}`
                .replace(`{${"phone_number"}}`, encodeURIComponent(String(phoneNumber)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific user
         * @param {string} token User token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getUsersToken.');
            }
            const localVarPath = `/users/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists cardholder notes
         * @param {string} token User token
         * @param {number} [startIndex] Start index
         * @param {number} [count] Number of notes to retrieve
         * @param {string} [createdBy] Created by
         * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
         * @param {boolean} [includePrivate] Include private notes and private fields in note response
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getUsersTokenNotes.');
            }
            const localVarPath = `/users/{token}/notes`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (createdByUserRole !== undefined) {
                localVarQueryParameter['created_by_user_role'] = createdByUserRole;
            }

            if (includePrivate !== undefined) {
                localVarQueryParameter['include_private'] = includePrivate;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific user's SSN
         * @param {string} token User token
         * @param {boolean} [fullSsn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTokenSsn(token: string, fullSsn?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getUsersTokenSsn.');
            }
            const localVarPath = `/users/{token}/ssn`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fullSsn !== undefined) {
                localVarQueryParameter['full_ssn'] = fullSsn;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a user
         * @param {CardHolderModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(body?: CardHolderModel, options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardHolderModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a user password
         * @param {PasswordUpdateModel} body Password update object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthChangepassword(body: PasswordUpdateModel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postUsersAuthChangepassword.');
            }
            const localVarPath = `/users/auth/changepassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PasswordUpdateModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a client access token
         * @param {ClientAccessTokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthClientaccesstoken(body?: ClientAccessTokenRequest, options: any = {}): FetchArgs {
            const localVarPath = `/users/auth/clientaccesstoken`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ClientAccessTokenRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs in a user
         * @param {LoginRequestModel} [body] User login object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthLogin(body?: LoginRequestModel, options: any = {}): FetchArgs {
            const localVarPath = `/users/auth/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs out a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthLogout(options: any = {}): FetchArgs {
            const localVarPath = `/users/auth/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a one-time token
         * @param {OneTimeRequestModel} [body] One-time object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthOnetime(body?: OneTimeRequestModel, options: any = {}): FetchArgs {
            const localVarPath = `/users/auth/onetime`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OneTimeRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generates a reset password email
         * @param {ResetUserPasswordEmailModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthResetpassword(body?: ResetUserPasswordEmailModel, options: any = {}): FetchArgs {
            const localVarPath = `/users/auth/resetpassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetUserPasswordEmailModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resets a user password
         * @param {string} token Reset password verification token
         * @param {ResetUserPasswordModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthResetpasswordToken(token: string, body?: ResetUserPasswordModel, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling postUsersAuthResetpasswordToken.');
            }
            const localVarPath = `/users/auth/resetpassword/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetUserPasswordModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generates an email verification request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthVerifyemail(options: any = {}): FetchArgs {
            const localVarPath = `/users/auth/verifyemail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verifies the email token
         * @param {string} token Email verification token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthVerifyemailToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling postUsersAuthVerifyemailToken.');
            }
            const localVarPath = `/users/auth/verifyemail/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all users
         * @param {UserCardHolderSearchModel} [body] 
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersLookup(body?: UserCardHolderSearchModel, count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/users/lookup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserCardHolderSearchModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a note for the cardholder
         * @param {string} token User token
         * @param {CardholderNoteRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersTokenNotes(token: string, body?: CardholderNoteRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling postUsersTokenNotes.');
            }
            const localVarPath = `/users/{token}/notes`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardholderNoteRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific user
         * @param {string} token User token
         * @param {UserCardHolderUpdateModel} body User object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersToken(token: string, body: UserCardHolderUpdateModel, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putUsersToken.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putUsersToken.');
            }
            const localVarPath = `/users/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserCardHolderUpdateModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific note for a cardholder
         * @param {string} token User token
         * @param {string} notesToken Notes token
         * @param {CardholderNoteUpdateRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersTokenNotesNotestoken(token: string, notesToken: string, body?: CardholderNoteUpdateRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putUsersTokenNotesNotestoken.');
            }
            // verify required parameter 'notesToken' is not null or undefined
            if (notesToken === null || notesToken === undefined) {
                throw new RequiredError('notesToken','Required parameter notesToken was null or undefined when calling putUsersTokenNotesNotestoken.');
            }
            const localVarPath = `/users/{token}/notes/{notes_token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"notes_token"}}`, encodeURIComponent(String(notesToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardholderNoteUpdateRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all users
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserCardHolderListResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUsers(count, startIndex, searchType, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a client access token
         * @param {string} token Client access token
         * @param {string} [applicationToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAuthClientaccesstokenToken(token: string, applicationToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClientAccessTokenResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUsersAuthClientaccesstokenToken(token, applicationToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all children of a parent user
         * @param {string} parentToken Token of parent cardholder
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserCardHolderListResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUsersParenttokenChildren(parentToken, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all users who match a phone number
         * @param {string} phoneNumber Phone number
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPhonenumberPhonenumber(phoneNumber: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserCardHolderListResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUsersPhonenumberPhonenumber(phoneNumber, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific user
         * @param {string} token User token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserCardHolderResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUsersToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists cardholder notes
         * @param {string} token User token
         * @param {number} [startIndex] Start index
         * @param {number} [count] Number of notes to retrieve
         * @param {string} [createdBy] Created by
         * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
         * @param {boolean} [includePrivate] Include private notes and private fields in note response
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardHolderNoteListResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUsersTokenNotes(token, startIndex, count, createdBy, createdByUserRole, includePrivate, searchType, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific user's SSN
         * @param {string} token User token
         * @param {boolean} [fullSsn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTokenSsn(token: string, fullSsn?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SsnResponseModel> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUsersTokenSsn(token, fullSsn, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a user
         * @param {CardHolderModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(body?: CardHolderModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserCardHolderResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUsers(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a user password
         * @param {PasswordUpdateModel} body Password update object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthChangepassword(body: PasswordUpdateModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUsersAuthChangepassword(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a client access token
         * @param {ClientAccessTokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthClientaccesstoken(body?: ClientAccessTokenRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClientAccessTokenResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUsersAuthClientaccesstoken(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Logs in a user
         * @param {LoginRequestModel} [body] User login object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthLogin(body?: LoginRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoginResponseModel> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUsersAuthLogin(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Logs out a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUsersAuthLogout(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a one-time token
         * @param {OneTimeRequestModel} [body] One-time object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthOnetime(body?: OneTimeRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessTokenResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUsersAuthOnetime(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Generates a reset password email
         * @param {ResetUserPasswordEmailModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthResetpassword(body?: ResetUserPasswordEmailModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUsersAuthResetpassword(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Resets a user password
         * @param {string} token Reset password verification token
         * @param {ResetUserPasswordModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthResetpasswordToken(token: string, body?: ResetUserPasswordModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUsersAuthResetpasswordToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Generates an email verification request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthVerifyemail(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUsersAuthVerifyemail(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Verifies the email token
         * @param {string} token Email verification token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthVerifyemailToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUsersAuthVerifyemailToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Lists all users
         * @param {UserCardHolderSearchModel} [body] 
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersLookup(body?: UserCardHolderSearchModel, count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserCardHolderListResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUsersLookup(body, count, startIndex, searchType, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a note for the cardholder
         * @param {string} token User token
         * @param {CardholderNoteRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersTokenNotes(token: string, body?: CardholderNoteRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardholderNoteResponseModel> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUsersTokenNotes(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific user
         * @param {string} token User token
         * @param {UserCardHolderUpdateModel} body User object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersToken(token: string, body: UserCardHolderUpdateModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardHolderModel> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).putUsersToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific note for a cardholder
         * @param {string} token User token
         * @param {string} notesToken Notes token
         * @param {CardholderNoteUpdateRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersTokenNotesNotestoken(token: string, notesToken: string, body?: CardholderNoteUpdateRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CardholderNoteResponseModel> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).putUsersTokenNotesNotestoken(token, notesToken, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all users
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, options?: any) {
            return UsersApiFp(configuration).getUsers(count, startIndex, searchType, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a client access token
         * @param {string} token Client access token
         * @param {string} [applicationToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAuthClientaccesstokenToken(token: string, applicationToken?: string, options?: any) {
            return UsersApiFp(configuration).getUsersAuthClientaccesstokenToken(token, applicationToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all children of a parent user
         * @param {string} parentToken Token of parent cardholder
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return UsersApiFp(configuration).getUsersParenttokenChildren(parentToken, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all users who match a phone number
         * @param {string} phoneNumber Phone number
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPhonenumberPhonenumber(phoneNumber: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return UsersApiFp(configuration).getUsersPhonenumberPhonenumber(phoneNumber, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific user
         * @param {string} token User token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersToken(token: string, fields?: string, options?: any) {
            return UsersApiFp(configuration).getUsersToken(token, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists cardholder notes
         * @param {string} token User token
         * @param {number} [startIndex] Start index
         * @param {number} [count] Number of notes to retrieve
         * @param {string} [createdBy] Created by
         * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
         * @param {boolean} [includePrivate] Include private notes and private fields in note response
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: any) {
            return UsersApiFp(configuration).getUsersTokenNotes(token, startIndex, count, createdBy, createdByUserRole, includePrivate, searchType, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific user's SSN
         * @param {string} token User token
         * @param {boolean} [fullSsn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTokenSsn(token: string, fullSsn?: boolean, options?: any) {
            return UsersApiFp(configuration).getUsersTokenSsn(token, fullSsn, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a user
         * @param {CardHolderModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(body?: CardHolderModel, options?: any) {
            return UsersApiFp(configuration).postUsers(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a user password
         * @param {PasswordUpdateModel} body Password update object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthChangepassword(body: PasswordUpdateModel, options?: any) {
            return UsersApiFp(configuration).postUsersAuthChangepassword(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a client access token
         * @param {ClientAccessTokenRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthClientaccesstoken(body?: ClientAccessTokenRequest, options?: any) {
            return UsersApiFp(configuration).postUsersAuthClientaccesstoken(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logs in a user
         * @param {LoginRequestModel} [body] User login object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthLogin(body?: LoginRequestModel, options?: any) {
            return UsersApiFp(configuration).postUsersAuthLogin(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logs out a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthLogout(options?: any) {
            return UsersApiFp(configuration).postUsersAuthLogout(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a one-time token
         * @param {OneTimeRequestModel} [body] One-time object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthOnetime(body?: OneTimeRequestModel, options?: any) {
            return UsersApiFp(configuration).postUsersAuthOnetime(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Generates a reset password email
         * @param {ResetUserPasswordEmailModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthResetpassword(body?: ResetUserPasswordEmailModel, options?: any) {
            return UsersApiFp(configuration).postUsersAuthResetpassword(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Resets a user password
         * @param {string} token Reset password verification token
         * @param {ResetUserPasswordModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthResetpasswordToken(token: string, body?: ResetUserPasswordModel, options?: any) {
            return UsersApiFp(configuration).postUsersAuthResetpasswordToken(token, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Generates an email verification request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthVerifyemail(options?: any) {
            return UsersApiFp(configuration).postUsersAuthVerifyemail(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Verifies the email token
         * @param {string} token Email verification token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthVerifyemailToken(token: string, options?: any) {
            return UsersApiFp(configuration).postUsersAuthVerifyemailToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists all users
         * @param {UserCardHolderSearchModel} [body] 
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersLookup(body?: UserCardHolderSearchModel, count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, options?: any) {
            return UsersApiFp(configuration).postUsersLookup(body, count, startIndex, searchType, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a note for the cardholder
         * @param {string} token User token
         * @param {CardholderNoteRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersTokenNotes(token: string, body?: CardholderNoteRequestModel, options?: any) {
            return UsersApiFp(configuration).postUsersTokenNotes(token, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific user
         * @param {string} token User token
         * @param {UserCardHolderUpdateModel} body User object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersToken(token: string, body: UserCardHolderUpdateModel, options?: any) {
            return UsersApiFp(configuration).putUsersToken(token, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific note for a cardholder
         * @param {string} token User token
         * @param {string} notesToken Notes token
         * @param {CardholderNoteUpdateRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersTokenNotesNotestoken(token: string, notesToken: string, body?: CardholderNoteUpdateRequestModel, options?: any) {
            return UsersApiFp(configuration).putUsersTokenNotesNotestoken(token, notesToken, body, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Lists all users
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [searchType] Search type
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsers(count, startIndex, searchType, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a client access token
     * @param {string} token Client access token
     * @param {string} [applicationToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersAuthClientaccesstokenToken(token: string, applicationToken?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersAuthClientaccesstokenToken(token, applicationToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all children of a parent user
     * @param {string} parentToken Token of parent cardholder
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersParenttokenChildren(parentToken, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all users who match a phone number
     * @param {string} phoneNumber Phone number
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersPhonenumberPhonenumber(phoneNumber: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersPhonenumberPhonenumber(phoneNumber, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific user
     * @param {string} token User token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersToken(token: string, fields?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersToken(token, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists cardholder notes
     * @param {string} token User token
     * @param {number} [startIndex] Start index
     * @param {number} [count] Number of notes to retrieve
     * @param {string} [createdBy] Created by
     * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
     * @param {boolean} [includePrivate] Include private notes and private fields in note response
     * @param {string} [searchType] Search type
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersTokenNotes(token, startIndex, count, createdBy, createdByUserRole, includePrivate, searchType, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific user's SSN
     * @param {string} token User token
     * @param {boolean} [fullSsn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersTokenSsn(token: string, fullSsn?: boolean, options?: any) {
        return UsersApiFp(this.configuration).getUsersTokenSsn(token, fullSsn, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a user
     * @param {CardHolderModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsers(body?: CardHolderModel, options?: any) {
        return UsersApiFp(this.configuration).postUsers(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a user password
     * @param {PasswordUpdateModel} body Password update object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersAuthChangepassword(body: PasswordUpdateModel, options?: any) {
        return UsersApiFp(this.configuration).postUsersAuthChangepassword(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a client access token
     * @param {ClientAccessTokenRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersAuthClientaccesstoken(body?: ClientAccessTokenRequest, options?: any) {
        return UsersApiFp(this.configuration).postUsersAuthClientaccesstoken(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Logs in a user
     * @param {LoginRequestModel} [body] User login object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersAuthLogin(body?: LoginRequestModel, options?: any) {
        return UsersApiFp(this.configuration).postUsersAuthLogin(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Logs out a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersAuthLogout(options?: any) {
        return UsersApiFp(this.configuration).postUsersAuthLogout(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a one-time token
     * @param {OneTimeRequestModel} [body] One-time object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersAuthOnetime(body?: OneTimeRequestModel, options?: any) {
        return UsersApiFp(this.configuration).postUsersAuthOnetime(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Generates a reset password email
     * @param {ResetUserPasswordEmailModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersAuthResetpassword(body?: ResetUserPasswordEmailModel, options?: any) {
        return UsersApiFp(this.configuration).postUsersAuthResetpassword(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Resets a user password
     * @param {string} token Reset password verification token
     * @param {ResetUserPasswordModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersAuthResetpasswordToken(token: string, body?: ResetUserPasswordModel, options?: any) {
        return UsersApiFp(this.configuration).postUsersAuthResetpasswordToken(token, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Generates an email verification request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersAuthVerifyemail(options?: any) {
        return UsersApiFp(this.configuration).postUsersAuthVerifyemail(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Verifies the email token
     * @param {string} token Email verification token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersAuthVerifyemailToken(token: string, options?: any) {
        return UsersApiFp(this.configuration).postUsersAuthVerifyemailToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Lists all users
     * @param {UserCardHolderSearchModel} [body] 
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [searchType] Search type
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersLookup(body?: UserCardHolderSearchModel, count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, options?: any) {
        return UsersApiFp(this.configuration).postUsersLookup(body, count, startIndex, searchType, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a note for the cardholder
     * @param {string} token User token
     * @param {CardholderNoteRequestModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsersTokenNotes(token: string, body?: CardholderNoteRequestModel, options?: any) {
        return UsersApiFp(this.configuration).postUsersTokenNotes(token, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific user
     * @param {string} token User token
     * @param {UserCardHolderUpdateModel} body User object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putUsersToken(token: string, body: UserCardHolderUpdateModel, options?: any) {
        return UsersApiFp(this.configuration).putUsersToken(token, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific note for a cardholder
     * @param {string} token User token
     * @param {string} notesToken Notes token
     * @param {CardholderNoteUpdateRequestModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putUsersTokenNotesNotestoken(token: string, notesToken: string, body?: CardholderNoteUpdateRequestModel, options?: any) {
        return UsersApiFp(this.configuration).putUsersTokenNotesNotestoken(token, notesToken, body, options)(this.fetch, this.basePath);
    }

}

/**
 * VelocityControlsApi - fetch parameter creator
 * @export
 */
export const VelocityControlsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Queries velocity controls
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get velocity controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get velocity controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/velocitycontrols`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cardProduct !== undefined) {
                localVarQueryParameter['card_product'] = cardProduct;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific velocity control
         * @param {string} token Velocity control token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrolsToken(token: string, fields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getVelocitycontrolsToken.');
            }
            const localVarPath = `/velocitycontrols/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Queries a user's velocity control balances
         * @param {string} userToken User token
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {string} [forceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrolsUserUsertokenAvailable(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, forceDto?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userToken' is not null or undefined
            if (userToken === null || userToken === undefined) {
                throw new RequiredError('userToken','Required parameter userToken was null or undefined when calling getVelocitycontrolsUserUsertokenAvailable.');
            }
            const localVarPath = `/velocitycontrols/user/{user_token}/available`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (forceDto !== undefined) {
                localVarQueryParameter['force_dto'] = forceDto;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a velocity control
         * @param {VelocityControlRequest} body Velocity control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVelocitycontrols(body: VelocityControlRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postVelocitycontrols.');
            }
            const localVarPath = `/velocitycontrols`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VelocityControlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific velocity control
         * @param {string} token Velocity control token
         * @param {VelocityControlUpdateRequest} body Velocity control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVelocitycontrolsToken(token: string, body: VelocityControlUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putVelocitycontrolsToken.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putVelocitycontrolsToken.');
            }
            const localVarPath = `/velocitycontrols/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VelocityControlUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VelocityControlsApi - functional programming interface
 * @export
 */
export const VelocityControlsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Queries velocity controls
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get velocity controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get velocity controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VelocityControlListResponse> {
            const localVarFetchArgs = VelocityControlsApiFetchParamCreator(configuration).getVelocitycontrols(cardProduct, user, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific velocity control
         * @param {string} token Velocity control token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrolsToken(token: string, fields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VelocityControlResponse> {
            const localVarFetchArgs = VelocityControlsApiFetchParamCreator(configuration).getVelocitycontrolsToken(token, fields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Queries a user's velocity control balances
         * @param {string} userToken User token
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {string} [forceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrolsUserUsertokenAvailable(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, forceDto?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VelocityControlBalanceListResponse> {
            const localVarFetchArgs = VelocityControlsApiFetchParamCreator(configuration).getVelocitycontrolsUserUsertokenAvailable(userToken, count, startIndex, fields, sortBy, forceDto, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a velocity control
         * @param {VelocityControlRequest} body Velocity control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVelocitycontrols(body: VelocityControlRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VelocityControlResponse> {
            const localVarFetchArgs = VelocityControlsApiFetchParamCreator(configuration).postVelocitycontrols(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific velocity control
         * @param {string} token Velocity control token
         * @param {VelocityControlUpdateRequest} body Velocity control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVelocitycontrolsToken(token: string, body: VelocityControlUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VelocityControlResponse> {
            const localVarFetchArgs = VelocityControlsApiFetchParamCreator(configuration).putVelocitycontrolsToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VelocityControlsApi - factory interface
 * @export
 */
export const VelocityControlsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Queries velocity controls
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get velocity controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get velocity controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return VelocityControlsApiFp(configuration).getVelocitycontrols(cardProduct, user, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific velocity control
         * @param {string} token Velocity control token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrolsToken(token: string, fields?: string, options?: any) {
            return VelocityControlsApiFp(configuration).getVelocitycontrolsToken(token, fields, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries a user's velocity control balances
         * @param {string} userToken User token
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {string} [forceDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrolsUserUsertokenAvailable(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, forceDto?: string, options?: any) {
            return VelocityControlsApiFp(configuration).getVelocitycontrolsUserUsertokenAvailable(userToken, count, startIndex, fields, sortBy, forceDto, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a velocity control
         * @param {VelocityControlRequest} body Velocity control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVelocitycontrols(body: VelocityControlRequest, options?: any) {
            return VelocityControlsApiFp(configuration).postVelocitycontrols(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific velocity control
         * @param {string} token Velocity control token
         * @param {VelocityControlUpdateRequest} body Velocity control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVelocitycontrolsToken(token: string, body: VelocityControlUpdateRequest, options?: any) {
            return VelocityControlsApiFp(configuration).putVelocitycontrolsToken(token, body, options)(fetch, basePath);
        },
    };
};

/**
 * VelocityControlsApi - object-oriented interface
 * @export
 * @class VelocityControlsApi
 * @extends {BaseAPI}
 */
export class VelocityControlsApi extends BaseAPI {
    /**
     * 
     * @summary Queries velocity controls
     * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get velocity controls that are not associated with any card product.
     * @param {string} [user] User token. Use \&quot;null\&quot; to get velocity controls that are not associated with any user.
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VelocityControlsApi
     */
    public getVelocitycontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return VelocityControlsApiFp(this.configuration).getVelocitycontrols(cardProduct, user, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific velocity control
     * @param {string} token Velocity control token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VelocityControlsApi
     */
    public getVelocitycontrolsToken(token: string, fields?: string, options?: any) {
        return VelocityControlsApiFp(this.configuration).getVelocitycontrolsToken(token, fields, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Queries a user's velocity control balances
     * @param {string} userToken User token
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {string} [forceDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VelocityControlsApi
     */
    public getVelocitycontrolsUserUsertokenAvailable(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, forceDto?: string, options?: any) {
        return VelocityControlsApiFp(this.configuration).getVelocitycontrolsUserUsertokenAvailable(userToken, count, startIndex, fields, sortBy, forceDto, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a velocity control
     * @param {VelocityControlRequest} body Velocity control object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VelocityControlsApi
     */
    public postVelocitycontrols(body: VelocityControlRequest, options?: any) {
        return VelocityControlsApiFp(this.configuration).postVelocitycontrols(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific velocity control
     * @param {string} token Velocity control token
     * @param {VelocityControlUpdateRequest} body Velocity control object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VelocityControlsApi
     */
    public putVelocitycontrolsToken(token: string, body: VelocityControlUpdateRequest, options?: any) {
        return VelocityControlsApiFp(this.configuration).putVelocitycontrolsToken(token, body, options)(this.fetch, this.basePath);
    }

}

/**
 * WebPushProvisioningApi - fetch parameter creator
 * @export
 */
export const WebPushProvisioningApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary API to generate a Javascript object token containing a JWT to initiate Apple Pay web push provisioning
         * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
         * @param {RequestForApplePayWppJWT} requestBodyForApplePayWPPJWT 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateApplePayWPPJWT(reqSysId: string, requestBodyForApplePayWPPJWT: RequestForApplePayWppJWT, options: any = {}): FetchArgs {
            // verify required parameter 'reqSysId' is not null or undefined
            if (reqSysId === null || reqSysId === undefined) {
                throw new RequiredError('reqSysId','Required parameter reqSysId was null or undefined when calling generateApplePayWPPJWT.');
            }
            // verify required parameter 'requestBodyForApplePayWPPJWT' is not null or undefined
            if (requestBodyForApplePayWPPJWT === null || requestBodyForApplePayWPPJWT === undefined) {
                throw new RequiredError('requestBodyForApplePayWPPJWT','Required parameter requestBodyForApplePayWPPJWT was null or undefined when calling generateApplePayWPPJWT.');
            }
            const localVarPath = `/digitalwallets/wpp/applePayJWT`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (reqSysId !== undefined && reqSysId !== null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RequestForApplePayWppJWT" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBodyForApplePayWPPJWT || {}) : (requestBodyForApplePayWPPJWT || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary API to query for the web push provisioning related parameters, such as: google piaid/integrator_id, apple partnerId, apple Card Template Identifier
         * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
         * @param {RequestForWppParameters} requestBodyForWPPParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWPPParameters(reqSysId: string, requestBodyForWPPParameters: RequestForWppParameters, options: any = {}): FetchArgs {
            // verify required parameter 'reqSysId' is not null or undefined
            if (reqSysId === null || reqSysId === undefined) {
                throw new RequiredError('reqSysId','Required parameter reqSysId was null or undefined when calling getWPPParameters.');
            }
            // verify required parameter 'requestBodyForWPPParameters' is not null or undefined
            if (requestBodyForWPPParameters === null || requestBodyForWPPParameters === undefined) {
                throw new RequiredError('requestBodyForWPPParameters','Required parameter requestBodyForWPPParameters was null or undefined when calling getWPPParameters.');
            }
            const localVarPath = `/digitalwallets/wpp/parameters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (reqSysId !== undefined && reqSysId !== null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RequestForWppParameters" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBodyForWPPParameters || {}) : (requestBodyForWPPParameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request sending OPC data to google pay
         * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
         * @param {SendingProvisioningDataToGooglePayBackendRequest} requestBodyToInitiateGooglePayWebPushProvisioning 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOPCDataToGooglePay(reqSysId: string, requestBodyToInitiateGooglePayWebPushProvisioning: SendingProvisioningDataToGooglePayBackendRequest, options: any = {}): FetchArgs {
            // verify required parameter 'reqSysId' is not null or undefined
            if (reqSysId === null || reqSysId === undefined) {
                throw new RequiredError('reqSysId','Required parameter reqSysId was null or undefined when calling sendOPCDataToGooglePay.');
            }
            // verify required parameter 'requestBodyToInitiateGooglePayWebPushProvisioning' is not null or undefined
            if (requestBodyToInitiateGooglePayWebPushProvisioning === null || requestBodyToInitiateGooglePayWebPushProvisioning === undefined) {
                throw new RequiredError('requestBodyToInitiateGooglePayWebPushProvisioning','Required parameter requestBodyToInitiateGooglePayWebPushProvisioning was null or undefined when calling sendOPCDataToGooglePay.');
            }
            const localVarPath = `/digitalwallets/wpp/googlePayPushProvisioningNotification`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (reqSysId !== undefined && reqSysId !== null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SendingProvisioningDataToGooglePayBackendRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(requestBodyToInitiateGooglePayWebPushProvisioning || {}) : (requestBodyToInitiateGooglePayWebPushProvisioning || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebPushProvisioningApi - functional programming interface
 * @export
 */
export const WebPushProvisioningApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary API to generate a Javascript object token containing a JWT to initiate Apple Pay web push provisioning
         * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
         * @param {RequestForApplePayWppJWT} requestBodyForApplePayWPPJWT 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateApplePayWPPJWT(reqSysId: string, requestBodyForApplePayWPPJWT: RequestForApplePayWppJWT, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebPushProvisioningApplePayJWTResponse> {
            const localVarFetchArgs = WebPushProvisioningApiFetchParamCreator(configuration).generateApplePayWPPJWT(reqSysId, requestBodyForApplePayWPPJWT, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary API to query for the web push provisioning related parameters, such as: google piaid/integrator_id, apple partnerId, apple Card Template Identifier
         * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
         * @param {RequestForWppParameters} requestBodyForWPPParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWPPParameters(reqSysId: string, requestBodyForWPPParameters: RequestForWppParameters, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebPushProvisioning> {
            const localVarFetchArgs = WebPushProvisioningApiFetchParamCreator(configuration).getWPPParameters(reqSysId, requestBodyForWPPParameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Request sending OPC data to google pay
         * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
         * @param {SendingProvisioningDataToGooglePayBackendRequest} requestBodyToInitiateGooglePayWebPushProvisioning 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOPCDataToGooglePay(reqSysId: string, requestBodyToInitiateGooglePayWebPushProvisioning: SendingProvisioningDataToGooglePayBackendRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebPushProvisioningApiFetchParamCreator(configuration).sendOPCDataToGooglePay(reqSysId, requestBodyToInitiateGooglePayWebPushProvisioning, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebPushProvisioningApi - factory interface
 * @export
 */
export const WebPushProvisioningApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary API to generate a Javascript object token containing a JWT to initiate Apple Pay web push provisioning
         * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
         * @param {RequestForApplePayWppJWT} requestBodyForApplePayWPPJWT 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateApplePayWPPJWT(reqSysId: string, requestBodyForApplePayWPPJWT: RequestForApplePayWppJWT, options?: any) {
            return WebPushProvisioningApiFp(configuration).generateApplePayWPPJWT(reqSysId, requestBodyForApplePayWPPJWT, options)(fetch, basePath);
        },
        /**
         * 
         * @summary API to query for the web push provisioning related parameters, such as: google piaid/integrator_id, apple partnerId, apple Card Template Identifier
         * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
         * @param {RequestForWppParameters} requestBodyForWPPParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWPPParameters(reqSysId: string, requestBodyForWPPParameters: RequestForWppParameters, options?: any) {
            return WebPushProvisioningApiFp(configuration).getWPPParameters(reqSysId, requestBodyForWPPParameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Request sending OPC data to google pay
         * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
         * @param {SendingProvisioningDataToGooglePayBackendRequest} requestBodyToInitiateGooglePayWebPushProvisioning 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOPCDataToGooglePay(reqSysId: string, requestBodyToInitiateGooglePayWebPushProvisioning: SendingProvisioningDataToGooglePayBackendRequest, options?: any) {
            return WebPushProvisioningApiFp(configuration).sendOPCDataToGooglePay(reqSysId, requestBodyToInitiateGooglePayWebPushProvisioning, options)(fetch, basePath);
        },
    };
};

/**
 * WebPushProvisioningApi - object-oriented interface
 * @export
 * @class WebPushProvisioningApi
 * @extends {BaseAPI}
 */
export class WebPushProvisioningApi extends BaseAPI {
    /**
     * 
     * @summary API to generate a Javascript object token containing a JWT to initiate Apple Pay web push provisioning
     * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
     * @param {RequestForApplePayWppJWT} requestBodyForApplePayWPPJWT 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebPushProvisioningApi
     */
    public generateApplePayWPPJWT(reqSysId: string, requestBodyForApplePayWPPJWT: RequestForApplePayWppJWT, options?: any) {
        return WebPushProvisioningApiFp(this.configuration).generateApplePayWPPJWT(reqSysId, requestBodyForApplePayWPPJWT, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary API to query for the web push provisioning related parameters, such as: google piaid/integrator_id, apple partnerId, apple Card Template Identifier
     * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
     * @param {RequestForWppParameters} requestBodyForWPPParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebPushProvisioningApi
     */
    public getWPPParameters(reqSysId: string, requestBodyForWPPParameters: RequestForWppParameters, options?: any) {
        return WebPushProvisioningApiFp(this.configuration).getWPPParameters(reqSysId, requestBodyForWPPParameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Request sending OPC data to google pay
     * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
     * @param {SendingProvisioningDataToGooglePayBackendRequest} requestBodyToInitiateGooglePayWebPushProvisioning 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebPushProvisioningApi
     */
    public sendOPCDataToGooglePay(reqSysId: string, requestBodyToInitiateGooglePayWebPushProvisioning: SendingProvisioningDataToGooglePayBackendRequest, options?: any) {
        return WebPushProvisioningApiFp(this.configuration).sendOPCDataToGooglePay(reqSysId, requestBodyToInitiateGooglePayWebPushProvisioning, options)(this.fetch, this.basePath);
    }

}

/**
 * WebhooksApi - fetch parameter creator
 * @export
 */
export const WebhooksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of webhook configurations
         * @param {boolean} [active] Return only active webhook configurations
         * @param {number} [count] Number of reward programs to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(active?: boolean, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: any = {}): FetchArgs {
            const localVarPath = `/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a webhook configuration
         * @param {string} token Webhook token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksToken(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling getWebhooksToken.');
            }
            const localVarPath = `/webhooks/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a webhook configuration
         * @param {WebhookRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooks(body?: WebhookRequestModel, options: any = {}): FetchArgs {
            const localVarPath = `/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replays an event to a webhook
         * @param {string} token Webhook token
         * @param {'chargebacktransition' | 'digitalwallettokentransition' | 'cardtransition' | 'usertransition' | 'businesstransition' | 'transaction' | 'threedstransition'} eventType Event type
         * @param {string} eventToken Event token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksTokenEventtypeEventtoken(token: string, eventType: 'chargebacktransition' | 'digitalwallettokentransition' | 'cardtransition' | 'usertransition' | 'businesstransition' | 'transaction' | 'threedstransition', eventToken: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling postWebhooksTokenEventtypeEventtoken.');
            }
            // verify required parameter 'eventType' is not null or undefined
            if (eventType === null || eventType === undefined) {
                throw new RequiredError('eventType','Required parameter eventType was null or undefined when calling postWebhooksTokenEventtypeEventtoken.');
            }
            // verify required parameter 'eventToken' is not null or undefined
            if (eventToken === null || eventToken === undefined) {
                throw new RequiredError('eventToken','Required parameter eventToken was null or undefined when calling postWebhooksTokenEventtypeEventtoken.');
            }
            const localVarPath = `/webhooks/{token}/{event_type}/{event_token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"event_type"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"event_token"}}`, encodeURIComponent(String(eventToken)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoints must respond with a 200 status code.
         * @summary Pings a webhook
         * @param {string} token Ping a webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksTokenPing(token: string, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling postWebhooksTokenPing.');
            }
            const localVarPath = `/webhooks/{token}/ping`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific webhook configuration with custom headers
         * @param {string} token Webhook token
         * @param {WebhookUpdateCustomHeaderRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksCustomHeadersToken(token: string, body?: WebhookUpdateCustomHeaderRequest, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putWebhooksCustomHeadersToken.');
            }
            const localVarPath = `/webhooks/customheaders/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookUpdateCustomHeaderRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific webhook configuration
         * @param {string} token Webhook token
         * @param {WebhookBaseModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksToken(token: string, body?: WebhookBaseModel, options: any = {}): FetchArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling putWebhooksToken.');
            }
            const localVarPath = `/webhooks/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookBaseModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of webhook configurations
         * @param {boolean} [active] Return only active webhook configurations
         * @param {number} [count] Number of reward programs to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(active?: boolean, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookResponseModelListResponse> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).getWebhooks(active, count, startIndex, fields, sortBy, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a webhook configuration
         * @param {string} token Webhook token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksToken(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookResponseModel> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).getWebhooksToken(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a webhook configuration
         * @param {WebhookRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooks(body?: WebhookRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookResponseModel> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).postWebhooks(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Replays an event to a webhook
         * @param {string} token Webhook token
         * @param {'chargebacktransition' | 'digitalwallettokentransition' | 'cardtransition' | 'usertransition' | 'businesstransition' | 'transaction' | 'threedstransition'} eventType Event type
         * @param {string} eventToken Event token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksTokenEventtypeEventtoken(token: string, eventType: 'chargebacktransition' | 'digitalwallettokentransition' | 'cardtransition' | 'usertransition' | 'businesstransition' | 'transaction' | 'threedstransition', eventToken: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).postWebhooksTokenEventtypeEventtoken(token, eventType, eventToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Endpoints must respond with a 200 status code.
         * @summary Pings a webhook
         * @param {string} token Ping a webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksTokenPing(token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookPingModel> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).postWebhooksTokenPing(token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific webhook configuration with custom headers
         * @param {string} token Webhook token
         * @param {WebhookUpdateCustomHeaderRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksCustomHeadersToken(token: string, body?: WebhookUpdateCustomHeaderRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookResponseModel> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).putWebhooksCustomHeadersToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a specific webhook configuration
         * @param {string} token Webhook token
         * @param {WebhookBaseModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksToken(token: string, body?: WebhookBaseModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookResponseModel> {
            const localVarFetchArgs = WebhooksApiFetchParamCreator(configuration).putWebhooksToken(token, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns a list of webhook configurations
         * @param {boolean} [active] Return only active webhook configurations
         * @param {number} [count] Number of reward programs to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(active?: boolean, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
            return WebhooksApiFp(configuration).getWebhooks(active, count, startIndex, fields, sortBy, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a webhook configuration
         * @param {string} token Webhook token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksToken(token: string, options?: any) {
            return WebhooksApiFp(configuration).getWebhooksToken(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a webhook configuration
         * @param {WebhookRequestModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooks(body?: WebhookRequestModel, options?: any) {
            return WebhooksApiFp(configuration).postWebhooks(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replays an event to a webhook
         * @param {string} token Webhook token
         * @param {'chargebacktransition' | 'digitalwallettokentransition' | 'cardtransition' | 'usertransition' | 'businesstransition' | 'transaction' | 'threedstransition'} eventType Event type
         * @param {string} eventToken Event token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksTokenEventtypeEventtoken(token: string, eventType: 'chargebacktransition' | 'digitalwallettokentransition' | 'cardtransition' | 'usertransition' | 'businesstransition' | 'transaction' | 'threedstransition', eventToken: string, options?: any) {
            return WebhooksApiFp(configuration).postWebhooksTokenEventtypeEventtoken(token, eventType, eventToken, options)(fetch, basePath);
        },
        /**
         * Endpoints must respond with a 200 status code.
         * @summary Pings a webhook
         * @param {string} token Ping a webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksTokenPing(token: string, options?: any) {
            return WebhooksApiFp(configuration).postWebhooksTokenPing(token, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific webhook configuration with custom headers
         * @param {string} token Webhook token
         * @param {WebhookUpdateCustomHeaderRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksCustomHeadersToken(token: string, body?: WebhookUpdateCustomHeaderRequest, options?: any) {
            return WebhooksApiFp(configuration).putWebhooksCustomHeadersToken(token, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a specific webhook configuration
         * @param {string} token Webhook token
         * @param {WebhookBaseModel} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksToken(token: string, body?: WebhookBaseModel, options?: any) {
            return WebhooksApiFp(configuration).putWebhooksToken(token, body, options)(fetch, basePath);
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * 
     * @summary Returns a list of webhook configurations
     * @param {boolean} [active] Return only active webhook configurations
     * @param {number} [count] Number of reward programs to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooks(active?: boolean, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: any) {
        return WebhooksApiFp(this.configuration).getWebhooks(active, count, startIndex, fields, sortBy, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a webhook configuration
     * @param {string} token Webhook token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooksToken(token: string, options?: any) {
        return WebhooksApiFp(this.configuration).getWebhooksToken(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a webhook configuration
     * @param {WebhookRequestModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postWebhooks(body?: WebhookRequestModel, options?: any) {
        return WebhooksApiFp(this.configuration).postWebhooks(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Replays an event to a webhook
     * @param {string} token Webhook token
     * @param {'chargebacktransition' | 'digitalwallettokentransition' | 'cardtransition' | 'usertransition' | 'businesstransition' | 'transaction' | 'threedstransition'} eventType Event type
     * @param {string} eventToken Event token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postWebhooksTokenEventtypeEventtoken(token: string, eventType: 'chargebacktransition' | 'digitalwallettokentransition' | 'cardtransition' | 'usertransition' | 'businesstransition' | 'transaction' | 'threedstransition', eventToken: string, options?: any) {
        return WebhooksApiFp(this.configuration).postWebhooksTokenEventtypeEventtoken(token, eventType, eventToken, options)(this.fetch, this.basePath);
    }

    /**
     * Endpoints must respond with a 200 status code.
     * @summary Pings a webhook
     * @param {string} token Ping a webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postWebhooksTokenPing(token: string, options?: any) {
        return WebhooksApiFp(this.configuration).postWebhooksTokenPing(token, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific webhook configuration with custom headers
     * @param {string} token Webhook token
     * @param {WebhookUpdateCustomHeaderRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public putWebhooksCustomHeadersToken(token: string, body?: WebhookUpdateCustomHeaderRequest, options?: any) {
        return WebhooksApiFp(this.configuration).putWebhooksCustomHeadersToken(token, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a specific webhook configuration
     * @param {string} token Webhook token
     * @param {WebhookBaseModel} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public putWebhooksToken(token: string, body?: WebhookBaseModel, options?: any) {
        return WebhooksApiFp(this.configuration).putWebhooksToken(token, body, options)(this.fetch, this.basePath);
    }

}

